<?xml version="1.0" encoding="UTF-8" ?>
<config>
    <luceneMatchVersion>5.2.0</luceneMatchVersion>

  <jmx />

  <lib dir="lib" regex="solr-dataimporthandler-.*\.jar" />


  <updateHandler class="solr.DirectUpdateHandler2">


    <!-- Limit the number of deletions Solr will buffer during doc updating.

        Setting this lower can help bound memory use during indexing.
    -->
    <maxPendingDeletes>100000</maxPendingDeletes>

      <updateLog>
          <str name="dir">${solr.ulog.dir:}</str>
      </updateLog>



  </updateHandler>


    <query>
    <!-- Maximum number of clauses in a boolean query... can affect
        range or prefix queries that expand to big boolean
        queries.  An exception is thrown if exceeded.  -->
    <maxBooleanClauses>1024</maxBooleanClauses>

    
    <!-- Cache used by SolrIndexSearcher for filters (DocSets),
         unordered sets of *all* documents that match a query.
         When a new searcher is opened, its caches may be prepopulated
         or "autowarmed" using data from caches in the old searcher.
         autowarmCount is the number of items to prepopulate.  For LRUCache,
         the autowarmed items will be the most recently accessed items.
       Parameters:
         class - the SolrCache implementation (currently only LRUCache)
         size - the maximum number of entries in the cache
         initialSize - the initial capacity (number of entries) of
           the cache.  (seel java.util.HashMap)
         autowarmCount - the number of entries to prepopulate from
           and old cache.
         -->
    <filterCache
      class="solr.LRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>

   <!-- queryResultCache caches results of searches - ordered lists of
         document ids (DocList) based on a query, a sort, and the range
         of documents requested.  -->
    <queryResultCache
      class="solr.LRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>

  <!-- documentCache caches Lucene Document objects (the stored fields for each document).
       Since Lucene internal document ids are transient, this cache will not be autowarmed.  -->
    <documentCache
      class="solr.LRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>

    <!-- If true, stored fields that are not requested will be loaded lazily.

    This can result in a significant speed improvement if the usual case is to
    not load all stored fields, especially if the skipped fields are large compressed
    text fields.
    -->
    <enableLazyFieldLoading>true</enableLazyFieldLoading>

    <!-- Example of a generic cache.  These caches may be accessed by name
         through SolrIndexSearcher.getCache(),cacheLookup(), and cacheInsert().
         The purpose is to enable easy caching of user/application level data.
         The regenerator argument should be specified as an implementation
         of solr.search.CacheRegenerator if autowarming is desired.  -->
    <!--
    <cache name="myUserCache"
      class="solr.LRUCache"
      size="4096"
      initialSize="1024"
      autowarmCount="1024"
      regenerator="org.mycompany.mypackage.MyRegenerator"
      />
    -->

   <!-- An optimization that attempts to use a filter to satisfy a search.
         If the requested sort does not include score, then the filterCache
         will be checked for a filter matching the query. If found, the filter
         will be used as the source of document ids, and then the sort will be
         applied to that.
    <useFilterForSortedQuery>true</useFilterForSortedQuery>
   -->

   <!-- An optimization for use with the queryResultCache.  When a search
         is requested, a superset of the requested number of document ids
         are collected.  For example, if a search for a particular query
         requests matching documents 10 through 19, and queryWindowSize is 50,
         then documents 0 through 49 will be collected and cached.  Any further
         requests in that range can be satisfied via the cache.  -->
    <queryResultWindowSize>50</queryResultWindowSize>
    
    <!-- Maximum number of documents to cache for any entry in the
         queryResultCache. -->
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

    <!-- This entry enables an int hash representation for filters (DocSets)
         when the number of items in the set is less than maxSize.  For smaller
         sets, this representation is more memory efficient, more efficient to
         iterate over, and faster to take intersections.  -->
    <HashDocSet maxSize="3000" loadFactor="0.75"/>

    <!-- a newSearcher event is fired whenever a new searcher is being prepared
         and there is a current searcher handling requests (aka registered). -->
    <!-- QuerySenderListener takes an array of NamedList and executes a
         local query request for each NamedList in sequence. -->
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst> <str name="q">fgf</str> <str name="start">0</str> <str name="rows">10</str> </lst>
        <lst> <str name="q">brain</str> <str name="start">0</str> <str name="rows">10</str> </lst>
        <lst><str name="q">Westerfield</str></lst>
      </arr>
    </listener>

    <!-- a firstSearcher event is fired whenever a new searcher is being
         prepared but there is no current registered searcher to handle
         requests or to gain autowarming data from. -->
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst><str name="q">Westerfield</str></lst>
      </arr>
    </listener>

    <!-- If a search request comes in and there is no current registered searcher,
         then immediately register the still warming searcher and use it.  If
         "false" then all requests will block until the first searcher is done
         warming. -->
    <useColdSearcher>false</useColdSearcher>

    <!-- Maximum number of searchers that may be warming in the background
      concurrently.  An error is returned if this limit is exceeded. Recommend
      1-2 for read-only slaves, higher for masters w/o cache warming. -->
    <maxWarmingSearchers>4</maxWarmingSearchers>

  </query>

  <!-- 
    Let the dispatch filter handler /select?qt=XXX
    handleSelect=true will use consistent error handling for /select and /update
    handleSelect=false will use solr1.1 style error formatting
    -->
  <requestDispatcher handleSelect="true" >
    <!--Make sure your system has some authentication before enabling remote streaming!  -->
    <requestParsers enableRemoteStreaming="false" multipartUploadLimitInKB="2048" />
        
    <!-- Set HTTP caching related parameters (for proxy caches and clients).
          
         To get the behaviour of Solr 1.2 (ie: no caching related headers)
         use the never304="true" option and do not specify a value for
         <cacheControl>
    -->
    <httpCaching never304="true">
    <!--httpCaching lastModifiedFrom="openTime"
                 etagSeed="Solr"-->
       <!-- lastModFrom="openTime" is the default, the Last-Modified value
            (and validation against If-Modified-Since requests) will all be
            relative to when the current Searcher was opened.
            You can change it to lastModFrom="dirLastMod" if you want the
            value to exactly corrispond to when the physical index was last
            modified.
               
            etagSeed="..." is an option you can change to force the ETag
            header (and validation against If-None-Match requests) to be
            differnet even if the index has not changed (ie: when making
            significant changes to your config file)

            lastModifiedFrom and etagSeed are both ignored if you use the
            never304="true" option.
       -->
       <!-- If you include a <cacheControl> directive, it will be used to
            generate a Cache-Control header, as well as an Expires header
            if the value contains "max-age="
               
            By default, no Cache-Control header is generated.

            You can use the <cacheControl> option even if you have set
            never304="true"
       -->
       <!-- <cacheControl>max-age=30, public</cacheControl> -->
    </httpCaching>
  </requestDispatcher>
  
      
  <!-- requestHandler plugins... incoming queries will be dispatched to the
     correct handler based on the path or the 'qt' param.
     Names starting with a '/' are accessed with the a path equal to the 
     registered name.  Names without a leading '/' are accessed with:
      http://host/app/select?qt=name
     If no qt is defined, the requestHandler that declares default="true"
     will be used.
  -->


  <requestHandler name="standard" class="solr.StandardRequestHandler" default="true">

      <!-- Always append these -->
      <lst name="appends">
          <!-- The 'Autocomplete' category should always be excluded from search -->
          <str name="fq">-category:Autocomplete</str>
      </lst>

      <!-- default values for query parameters -->

      <lst name="defaults">
       <str name="echoParams">explicit</str>
         <str name="sort">score desc, name_sort asc</str>

         <str name="facet">true</str>
         <str name="facet.sort">count</str>
         <str name="facet.limit">5</str>
         <str name="facet.mincount">1</str>

         <!-- initial settings for special case facets -->
         <str name="f.category.facet.sort">index</str>
         <str name="f.category.facet.limit">50</str>
         <str name="f.curator.facet.limit">50</str>
         <str name="f.stage.facet.limit">50</str>
         <str name="f.type.facet.limit">50</str>
         <str name="f.chromosome.facet.limit">50</str>



        <str name="q.alt">*:*</str>
        <str name="defType">edismax</str>
        <!-- there is an override in SearchPrototypeController that mirrors this list but includes an extra, so they should be updated in tandem -->
        <!--screen used to be here, removed as a result of case 11323-->
        <str name="fl">name, type, id, category, full_name, url, thumbnail, image, snapshot, date, attribution_count, has_orthology, xpat_zdb_id, fig_zdb_id, score,pgcmid</str>

          <!-- fast vector highlighter config -->
         <str name="hl.tag.pre"><![CDATA[<span class="search-result-highlight">]]></str>
         <str name="hl.tag.post"><![CDATA[</span>]]></str>

         <!-- standard highlighter config -->
         <str name="hl.simple.pre"><![CDATA[<span class="search-result-highlight">]]></str>
         <str name="hl.simple.post"><![CDATA[</span>]]></str>

         <str name="hl">false</str>
         <str name="hl.useFastVectorHighligter">true</str>
         <str name="hl.snippets">2</str>
         <str name="hl.fragsize">100</str>
         <str name="hl.requireFieldMatch">false</str> <!-- starting as false, but we probably want true -->

         <str name="hl.phraseLimit">10</str>

         <!-- Specifies the maximum number of entries in a multi-valued field to examine before stopping. -->
         <str name="hl.maxMultiValuedToExamine">100</str>
         <!-- Specifies the maximum number of matches in a multi-valued field that are found before stopping -->
         <str name="hl.maxMultiValuedToMatch">1</str>

       <!-- hl.fl ** Which fields should be highlighted.
              Unfortunately highlighting lots of fields is very expensive.
              Because we're using the FastVectorHighlighter, fields that are listed here need to have additional
                flags set in the schema
              http://wiki.apache.org/solr/HighlightingParameters#hl.useFastVectorHighlighter
                 These should have termVectors=on, termPositions=on and termOffsets=on
              -->
          <!-- The sad minimum fallback of dumping everything into a single text field for highlighting: -->
          <str name="hl.fl">
              text
          </str>
         <!--  This is the set of fields that (currently) have the right schema settings -->
         <!--
         <str name="hl.fl">
             name
             full_name
             alias
             expression_observation
             expression_anatomy_hl
             expressed_in_hl
             affected_anatomy_hl
             phenotype_quality_hl
             molecular_function_hl
             biological_process_hl
             cellular_component_hl
             affected_molecular_function_hl
             affected_biological_process_hl
             affected_cellular_component_hl
             labeled_anatomy_hl
             labeled_cellular_component_hl

         </str>
-->


         <!-- an experiment for phrase boosting -->

         <str name="ps">4</str>

         <str name="pf2">
             proper_name^10.0
             name
                                     category_t
                                     type_t
                                     name_t
                                     full_name^5.0
                                     id_t
             alias^4.0
             alias_t^4.0
             construct_name^2.0
             construct_alias

             construct
             construct_t


             ortholog_other_species_name
             disease_model_t
             disease_t
             phenotype_statement_t
             synonym_phenotype_statement_t
             expression_statement_t
             journal_t
             journal_name_t
             registered_author_t
                          registered_author
             author_string
             author_year
             full_mesh_term
             full_mesh_term_t
                                     related_accession
                                     related_marker
                                     affected_gene_t
             term_t

             sequence_targeting_reagent_t

             gene
             gene_full_name
             gene_previous_name

             zebrafish_gene
             zebrafish_gene_full_name
             zebrafish_gene_previous_name

             affected_gene_full_name
             affected_gene_previous_name

                          affected_gene
                                     expressed_gene_t

             expressed_gene_full_name
             expressed_gene_previous_name
                          expressed_gene
                          misexpressed_gene
                                     insertion_gene_t
             insertion_gene_full_name
             insertion_gene_previous_name
                          insertion_gene
                                     expressed_in_t
                          expressed_in
                                     regulatory_region_t
                          regulatory_region
                                     coding_sequence_t
                          coding_sequence
                                     promoter_full_name
                                     coding_sequence_full_name
                                     engineered_region_full_name
             targeted_gene
             targeted_gene_full_name
             targeted_gene_previous_name

             experimental_conditions

             prefix
             institution
             institution_t
             lab_of_origin
             background_t
                                     related_accession
                                     related_marker
                                     allele_t
                          allele
                                     expression_observation
                                     chromosome
             person_name
             lab_member_name
             email_address
                                     postal_address
                                     note^0.5
                                     caption^0.5
                                     abstract^0.5
                                     biography^0.5
                                     definition^0.5
            attributed_publication^.01
         </str>
         <str name="pf3">
             proper_name^10.0
             name
                                     category_t
                                     type_t
                                     name_t
                                     full_name^5.0
                                     id_t
                                     alias^4.0
                                     alias_t^4.0

             construct_name^2.0
             construct_alias

             construct
             construct_t


             ortholog_other_species_name
             disease_model_t
             disease_t
             phenotype_statement_t
             synonym_phenotype_statement_t
             expression_statement_t
                                     registered_author_t
                                     author_string
                                     author_year
             full_mesh_term
             full_mesh_term_t
                                     related_accession
                                     related_marker
                                     affected_gene_t
             term_t

             sequence_targeting_reagent_t

             gene_full_name
             gene_previous_name


             zebrafish_gene_full_name
             zebrafish_gene_previous_name

             reporter_gene_full_name

             affected_gene_full_name
             affected_gene_previous_name

                          affected_gene
                                     expressed_gene_t

             expressed_gene_full_name
             expressed_gene_previous_name
                          expressed_gene
             misexpressed_gene
                                     insertion_gene_t
             insertion_gene_full_name
             insertion_gene_previous_name
                          insertion_gene
                                     expressed_in_t
                          expressed_in
                                     regulatory_region_t
                          regulatory_region
                                     coding_sequence_t
                          coding_sequence
                                     promoter_full_name
                                     coding_sequence_full_name
                                     engineered_region_full_name
             background_t

             targeted_gene
             targeted_gene_full_name
             targeted_gene_previous_name

             experimental_conditions
             journal_t
             journal_name_t
             prefix
             institution
             institution_t
             lab_of_origin
                                     related_accession
                                     related_marker
                                     allele_t
                          allele
                                     expression_observation
                                     chromosome
             person_name
             lab_member_name
             email_address
                                     postal_address
                                     note^0.5
                                     caption^0.5
                                     abstract^0.5
                                     biography^0.5
                                     definition^0.5
             attributed_publication^.01
         </str>

         <!-- boost function, rord is reverse ordinal value, so the lowest complexity is 0, next is 1, etc, I think,
              there are some memory warnings about rord, so it's possible that we don't actually want it.. -->
      <!--   <str name="bf">rord(complexity)^1.0 </str> -->
<!-- sqrt(map(attribution_count,1000,99999999,0))^0.2 -->

         <str name="bf">
             sum($complexity_boost,$popularity_boost,$images_boost,$jtype_boost)
         </str>


         <str name="complexity_boost">mul(recip(complexity,1,1,1),1000000)</str>
         <str name="popularity_boost">mul(sqrt(popularity),0.001)</str>
         <!-- not currently in use now that most records have 'date' as their creation date, rather than last updated date,
              but I want to keep it around in case we want to use it for just pubs and figures -->
         <!-- <str name="recency_boost">mul(recip(ms(NOW/HOUR,tdate),3.16e-11,1,1),0.001) </str>-->
         <str name="images_boost">mul(exists(has_image),0.1)</str>
         <str name="jtype_boost">mul(exists(query({!v='publication_type:Journal'})),0.001)</str>
         <!-- since you can't negatively boost, this pattern boosts everything BUT the records that match these queries-->
          <str name="bq">(*:* -is_wildtype:false)^1000 (*:* -name_t:unspecified)^10000 </str>

         <str name="qf">
             proper_name_k^50.0
             proper_name^10.0
             name
             category_t
             type_t
             name_t

             full_name^2.0

             id_t
             alias^4.0
             alias_t^4.0

             ortholog_other_species_symbol^2.0
             ortholog_other_species_symbol_t^2.0
             construct_name^2.0
             construct_alias

             construct
             construct_t
             construct_name

             full_name_ac^0.1
             alias_ac^0.1

             marker_abbrev^4.0

             ortholog_other_species_name
             ortholog_organism
             ortholog_other_species_name_t
             ortholog_organism_t
             disease_model
             disease_model_t
             disease
             disease_t
             omim_id

             phenotype_statement_t
             phenotype_statement
             synonym_phenotype_statement_t
             synonym_phenotype_statement

             journal journal_t
             journal journal_name_t
             registered_author_t^0.5
             registered_author^0.5
             author_string
             author_year
             full_mesh_term
             full_mesh_term_t

             related_accession
             related_marker
             affected_gene_t

             term_t
             labeled_anatomy_direct^1.1
             labeled_anatomy_parent^1.0
             labeled_cellular_component_direct^1.1
             labeled_cellular_component_parent^1.0
             expression_anatomy_direct^1.1
             expression_anatomy_parent^1.0
             expressed_in_direct^1.0
             expressed_in_parent^1.0
             affected_anatomy_direct^1.1
             affected_anatomy_parent^1.0
             anatomy_direct^1.1
             anatomy_parent^1.0
             phenotype_quality_direct^1.1
             phenotype_quality_parent^1.0
             molecular_function_direct^1.1
             molecular_function_direct^1.0
             biological_process_direct^1.1
             biological_process_parent^1.0
             cellular_component_direct^1.1
             cellular_component_parent^1.0

             affected_molecular_function_direct^1.1
             affected_molecular_function_direct^1.0
             affected_biological_process_direct^1.1
             affected_biological_process_parent^1.0
             affected_cellular_component_direct^1.1
             affected_cellular_component_parent^1.0

             sequence_targeting_reagent
             sequence_targeting_reagent_t

             antigen_gene
             antigen_gene_full_name^0.8
             antigen_gene_previous_name^0.7

             gene
             gene_full_name^0.8
             gene_previous_name^0.7

             zebrafish_gene
             zebrafish_gene_full_name^0.8
             zebrafish_gene_previous_name^0.7

             reporter_gene
             reporter_gene_full_name^0.8
             reporter_gene_previous_name^0.7

             affected_gene_full_name^0.8
             affected_gene_previous_name^0.7
             affected_gene
             expressed_gene_t
             expressed_gene_full_name^0.8
             expressed_gene_previous_name^0.7
             expressed_gene
             misexpressed_gene
             inserted_in_gene_full_name^0.8
             inserted_in_gene_previous_name^0.7
             inserted_in_gene_t
             inserted_in_gene
             regulatory_region_t
             regulatory_region
             coding_sequence_t
             coding_sequence
             promoter_full_name
             coding_sequence_full_name
             engineered_region_full_name
             targeted_gene
             targeted_gene_full_name
             targeted_gene_previous_name

             clone
             probe
             related_gene_symbol

             prefix
             institution
             institution_t
             lab_of_origin
             rna_consequence
             related_accession
             related_marker
             allele_t
             background background_t
             sequence_alteration sequence_alteration_t
             probe
             mutagen
             allele
             expression_observation
             chromosome

             experimental_conditions

             person_name
             lab_member_name
             email_address
             postal_address
             note^0.5
             caption^0.5
             abstract^0.5
             biography^0.5
             definition^0.5
             attributed_publication^.01
         </str>


     </lst>
  </requestHandler>





    <requestHandler name="/name-autocomplete" class="solr.StandardRequestHandler">
        <!-- default values for query parameters -->
        <lst name="defaults">
            <str name="defType">edismax</str>
            <str name="wt">json</str>
            <str name="indent">true</str>
            <str name="q.alt">*:*</str>
            <str name="qf">
                name_ac^10
                full_name_ac^5
                alias_ac^7
                ortholog_other_species_symbol_ac^4
                ortholog_other_species_name_ac^3
                name_t
                alias_t
                full_name_t
            </str>
            <str name="bf">recip(complexity,1,1,1)^10 sqrt(popularity)^20</str>
            <str name="fq">-category:Publication -category:Figure</str>
            <str name="hl">true</str>
            <str name="hl.snippets">1</str>
            <str name="hl.fl">
                name_ac
                full_name_ac
                alias_ac
                ortholog_other_species_symbol_ac
                ortholog_other_species_name_ac
                name_t
                alias_t
                full_name_t
            </str>
            <str name="hl.simple.pre"><![CDATA[<span class="search-result-highlight">]]></str>
            <str name="hl.simple.post"><![CDATA[</span>]]></str>
            <str name="fl">id,name,category,type,full_name</str>
        </lst>
    </requestHandler>

    <requestHandler name="/pub-drug" class="solr.StandardRequestHandler">
        <lst name="appends">
            <!-- The 'Autocomplete' category should always be excluded from search -->
            <str name="fq">category:Publication AND publication_type:Journal</str>
        </lst>
        <lst name="defaults">
        <str name="defType">edismax</str>
        <str name="wt">json</str>
        <str name="indent">true</str>
        <str name="q.alt">*:*</str>
        <str name="rows">500000</str>
        <str name="fl">
            related_accession,full_name,abstract,keyword
        </str>
        <str name="qf">
            full_name_t
            abstract
            keyword
        </str>
        <str name="pf2">
            full_name_t
            abstract
            keyword
        </str>
        <str name="pf3">
            full_name_t
            abstract
            keyword
        </str>
        </lst>
    </requestHandler>


    <requestHandler name="/replication" class="solr.ReplicationHandler" >
            <lst name="master">
              <str name="enable">${enable.master:false}</str>
              <str name="confFiles">
                schema.xml,
                db-data-config.xml,
                all-term-contains-synonyms-reversed.txt,
                organism-synonyms.txt,
                synonyms.txt,
                all-term-contains-synonyms.txt,
                popularity.txt,
                term_popularity.txt,
                chromosome_keepwords.txt,
                protwords.txt,
                term_stopwords.txt,
                colors.txt,
                publication-keyword-stopwords.txt,
                zfa_stopwords.txt,
                external_popularity.txt,
                reporter-color-synonyms.txt,
                zfin_synonyms.txt,
                organism-abbrev.txt,
                reporter-names.txt,
                organism-name.txt,
                stopwords.txt
            </str>
        </lst>
        <lst name="slave">
	    <str name="enable">${enable.slave:false}</str>
           <!-- <str name="masterUrl">http://localhost:9520/solr/prototype/replication</str> -->
           <!-- <str name="pollInterval">00:00:20</str> -->
        </lst>
    </requestHandler>
  
  <!--
   
   Search components are registered to SolrCore and used by Search Handlers
   
   By default, the following components are avaliable:
    
   <searchComponent name="query"     class="org.apache.solr.handler.component.QueryComponent" />
   <searchComponent name="facet"     class="org.apache.solr.handler.component.FacetComponent" />
   <searchComponent name="mlt"       class="org.apache.solr.handler.component.MoreLikeThisComponent" />
   <searchComponent name="highlight" class="org.apache.solr.handler.component.HighlightComponent" />
   <searchComponent name="debug"     class="org.apache.solr.handler.component.DebugComponent" />
  
   If you register a searchComponent to one of the standard names, that will be used instead.
  
   -->

   <requestHandler name="/dataimport" class="org.apache.solr.handler.dataimport.DataImportHandler">
     <lst name="defaults">
     	<str name="config">db-data-config.xml</str>
     </lst>
   </requestHandler>

    <requestHandler name="/mlt" class="solr.MoreLikeThisHandler">
      <lst name="defaults">
        <int name="mlt.mindf">1</int>
      </lst>
    </requestHandler>

    <requestHandler name="/pub-mlt" class="solr.MoreLikeThisHandler">
      <lst name="defaults">
        <str name="fq">category:Publication</str>
        <str name="wt">json</str>
        <str name="indent">true</str>
        <str name="mlt.fl">full_name,gene,sequence_alteration,abstract,registered_author,author_string,author_year</str>
        <str name="fl">score,id,name,full_name,abstract,gene,sequence_alteration</str>
        <int name="mlt.mindf">1</int>
        <str name="mlt.interestingTerms">details</str>
        <str name="mlt.boost">true</str>
        <str name="mlt.maxqt">5000</str>
        <str name="mlt.mintf">1</str>
        <str name="mlt.mindf">2</str>
      </lst>
    </requestHandler>

    <requestHandler name="/gene-mlt" class="solr.MoreLikeThisHandler">
      <lst name="defaults">
        <str name="fq">category:Gene</str>
        <str name="wt">csv</str>
        <str name="indent">true</str>
        <str name="mlt.fl">expressed_in,affected_anatomy</str>
        <str name="fl">score,id,name,full_name</str>
        <int name="mlt.mindf">1</int>
<!--
        <str name="mlt.interestingTerms">details</str>
-->
        <str name="mlt.boost">false</str>
        <str name="mlt.maxqt">5000</str>
        <str name="mlt.mintf">1</str>
        <str name="mlt.mindf">2</str>
      </lst>
    </requestHandler>

    <requestHandler name="/fish-search" class="org.apache.solr.handler.component.SearchHandler">
        <lst name="appends">
            <str name="fq">(category:Fish) OR (category:"Mutation / Tg" AND (lab_of_origin:"Stemple Lab" OR lab_of_origin:"Burgess &amp; Lin Lab"))</str>
        </lst>
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <str name="sort">complexity asc, score desc, name_sort asc</str>

            <str name="q.alt">*:*</str>
            <str name="defType">edismax</str>
            <!-- This list needs to match the fl for the primary requesthandler, or, more importantly, it needs to match the annotations in SearchResult.java  -->
            <str name="fl">name, type, id, category, full_name, url, thumbnail, image, snapshot, date, attribution_count,  has_orthology, xpat_zdb_id, fig_zdb_id, score,pgcmid</str>
            <str name="qf">proper_name^10.0
                name
                category_t
                type_t
                name_t

                full_name^2.0

                id_t
                alias^4.0
                alias_t^4.0

                construct
                construct_t

                sequence_targeting_reagent
                sequence_targeting_reagent_t

                affected_gene_full_name^0.8
                affected_gene_previous_name^0.7
                affected_gene

                allele_t
                background background_t
                sequence_alteration sequence_alteration_t

                feature feature_t
                related_gene_symbol
            </str>

            <str name="bf">
                sum($complexity_boost,$popularity_boost,$images_boost,$jtype_boost)
            </str>

            <str name="complexity_boost">mul(recip(complexity,1,1,1),1000000)</str>
            <str name="popularity_boost">mul(sqrt(popularity),0.001)</str>
            <!--<str name="recency_boost">mul(recip(ms(NOW/HOUR,tdate),3.16e-11,1,1),0.001)</str>-->
            <str name="images_boost">mul(exists(has_image),0.1)</str>
            <str name="jtype_boost">mul(exists(query({!v='publication_type:Journal'})),0.001)</str>
        </lst>
    </requestHandler>

  <requestHandler name="/search" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <!--
    By default, this will register the following components:
    
    <arr name="components">
      <str>query</str>
      <str>facet</str>
      <str>mlt</str>
      <str>highlight</str>
      <str>debug</str>
    </arr>
    
    To insert handlers before or after the 'standard' components, use:
    
    <arr name="first-components">
      <str>first</str>
    </arr>
    
    <arr name="last-components">
      <str>last</str>
    </arr>
    
    -->
  </requestHandler>
<!--
  <searchComponent class="solr.SpellCheckComponent" name="suggest">
        <lst name="spellchecker">
            <str name="name">suggest</str>
            <str name="classname">org.apache.solr.spelling.suggest.Suggester</str>
            <str name="lookupImpl">org.apache.solr.spelling.suggest.fst.FSTLookup</str>
            <str name="field">nomenclature_suggest</str>  &lt;!&ndash; the indexed field to derive suggestions from &ndash;&gt;
            &lt;!&ndash; minimum fraction of documents that must have the term, doc says [0..1], hopefully 0
                 is equivalent to say it only needs to be in one doc.. &ndash;&gt;
            <float name="threshold">0</float>
            <str name="buildOnCommit">true</str>
            &lt;!&ndash; <str name="sourceLocation">american-english</str> &ndash;&gt;

        </lst>
      <str name="queryAnalyzerFieldType">word_suggest</str>
  </searchComponent>

  <requestHandler class="org.apache.solr.handler.component.SearchHandler" name="/suggest">
        <lst name="defaults">
            <str name="spellcheck">true</str>
            <str name="spellcheck.dictionary">suggest</str>
            <str name="spellcheck.onlyMorePopular">true</str>
            <str name="spellcheck.count">5</str>
            <str name="spellcheck.collate">true</str>
        </lst>
        <arr name="components">
            <str>suggest</str>
        </arr>
  </requestHandler>-->


  <requestHandler name="/update" class="solr.UpdateRequestHandler"  />


  <!-- 
   Admin Handlers - This will register all the standard admin RequestHandlers.  Adding 
   this single handler is equivolent to registering:
   
  <requestHandler name="/admin/luke"       class="org.apache.solr.handler.admin.LukeRequestHandler" />
  <requestHandler name="/admin/system"     class="org.apache.solr.handler.admin.SystemInfoHandler" />
  <requestHandler name="/admin/plugins"    class="org.apache.solr.handler.admin.PluginInfoHandler" />
  <requestHandler name="/admin/threads"    class="org.apache.solr.handler.admin.ThreadDumpHandler" />
  <requestHandler name="/admin/properties" class="org.apache.solr.handler.admin.PropertiesRequestHandler" />
  <requestHandler name="/admin/file"       class="org.apache.solr.handler.admin.ShowFileRequestHandler" >
  
  If you wish to hide files under ${solr.home}/conf, explicitly register the ShowFileRequestHandler using:
  <requestHandler name="/admin/file" class="org.apache.solr.handler.admin.ShowFileRequestHandler" >
    <lst name="invariants">
     <str name="hidden">synonyms.txt</str> 
     <str name="hidden">anotherfile.txt</str> 
    </lst>
  </requestHandler>
  -->
  <requestHandler name="/admin/" class="org.apache.solr.handler.admin.AdminHandlers" />
  <requestHandler name="/analysis/field" class="solr.FieldAnalysisRequestHandler" />
  
  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    <lst name="defaults">
     <str name="echoParams">explicit</str> <!-- for all params (including the default etc) use: 'all' -->
     <str name="echoHandler">true</str>
    </lst>
  </requestHandler>
  
    <!-- Highlighting Component

         http://wiki.apache.org/solr/HighlightingParameters
      -->
    <searchComponent class="solr.HighlightComponent" name="highlight">
      <highlighting>
        <!-- Configure the standard fragmenter -->
        <!-- This could most likely be commented out in the "default" case -->
        <fragmenter name="gap"
                    default="true"
                    class="solr.highlight.GapFragmenter">
          <lst name="defaults">
            <int name="hl.fragsize">100</int>
          </lst>
        </fragmenter>

        <!-- A regular-expression-based fragmenter
             (for sentence extraction)
          -->
        <fragmenter name="regex"
                    class="solr.highlight.RegexFragmenter">
          <lst name="defaults">
            <!-- slightly smaller fragsizes work better because of slop -->
            <int name="hl.fragsize">70</int>
            <!-- allow 50% slop on fragment sizes -->
            <float name="hl.regex.slop">0.5</float>
            <!-- a basic sentence pattern -->
            <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
          </lst>
        </fragmenter>

        <!-- Configure the standard formatter -->
        <formatter name="html"
                   default="true"
                   class="solr.highlight.HtmlFormatter">
          <lst name="defaults">
            <str name="hl.simple.pre"><![CDATA[<em>]]></str>
            <str name="hl.simple.post"><![CDATA[</em>]]></str>
          </lst>
        </formatter>

        <!-- Configure the standard encoder -->
        <encoder name="html"
                 class="solr.highlight.HtmlEncoder" />

        <!-- Configure the standard fragListBuilder -->
        <fragListBuilder name="simple"
                         class="solr.highlight.SimpleFragListBuilder"/>

        <!-- Configure the single fragListBuilder -->
        <fragListBuilder name="single"
                         class="solr.highlight.SingleFragListBuilder"/>

        <!-- Configure the weighted fragListBuilder -->
        <fragListBuilder name="weighted"
                         default="true"
                         class="solr.highlight.WeightedFragListBuilder"/>

        <!-- default tag FragmentsBuilder -->
        <fragmentsBuilder name="default"
                          default="true"
                          class="solr.highlight.ScoreOrderFragmentsBuilder">
          <!--
          <lst name="defaults">
            <str name="hl.multiValuedSeparatorChar">/</str>
          </lst>
          -->
        </fragmentsBuilder>

        <!-- multi-colored tag FragmentsBuilder -->
        <fragmentsBuilder name="colored"
                          class="solr.highlight.ScoreOrderFragmentsBuilder">
          <lst name="defaults">
            <str name="hl.tag.pre"><![CDATA[
                 <b style="background:yellow">,<b style="background:lawgreen">,
                 <b style="background:aquamarine">,<b style="background:magenta">,
                 <b style="background:palegreen">,<b style="background:coral">,
                 <b style="background:wheat">,<b style="background:khaki">,
                 <b style="background:lime">,<b style="background:deepskyblue">]]></str>
            <str name="hl.tag.post"><![CDATA[</b>]]></str>
          </lst>
        </fragmentsBuilder>

        <boundaryScanner name="default"
                         default="true"
                         class="solr.highlight.SimpleBoundaryScanner">
          <lst name="defaults">
            <str name="hl.bs.maxScan">10</str>
            <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
          </lst>
        </boundaryScanner>

        <boundaryScanner name="breakIterator"
                         class="solr.highlight.BreakIteratorBoundaryScanner">
          <lst name="defaults">
            <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
            <str name="hl.bs.type">WORD</str>
            <!-- language and country are used when constructing Locale object.  -->
            <!-- And the Locale object will be used when getting instance of BreakIterator -->
            <str name="hl.bs.language">en</str>
            <str name="hl.bs.country">US</str>
          </lst>
        </boundaryScanner>
      </highlighting>
    </searchComponent>

  
  <!-- queryResponseWriter plugins... query responses will be written using the
    writer specified by the 'wt' request parameter matching the name of a registered
    writer.
    The "default" writer is the default and will be used if 'wt' is not specified 
    in the request. XMLResponseWriter will be used if nothing is specified here.
    The json, python, and ruby writers are also available by default.

    <queryResponseWriter name="xml" class="solr.XMLResponseWriter" default="true"/>
    <queryResponseWriter name="json" class="solr.JSONResponseWriter"/>
    <queryResponseWriter name="python" class="solr.PythonResponseWriter"/>
    <queryResponseWriter name="ruby" class="solr.RubyResponseWriter"/>
    <queryResponseWriter name="php" class="solr.PHPResponseWriter"/>
    <queryResponseWriter name="phps" class="solr.PHPSerializedResponseWriter"/>

    <queryResponseWriter name="custom" class="com.example.MyResponseWriter"/>
  -->

  <!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.  
   -->
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter> 
    
  <!-- config for the admin interface --> 
  <admin>
    <defaultQuery>*:*</defaultQuery>
  </admin>

</config>

