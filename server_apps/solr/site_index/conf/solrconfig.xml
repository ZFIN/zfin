<?xml version="1.0" encoding="UTF-8" ?>

<config>

  <schemaFactory class="ClassicIndexSchemaFactory"/>
  <luceneMatchVersion>8.6.3</luceneMatchVersion>

  <lib dir="${solr.install.dir:../../../..}/dist/" regex="solr-dataimporthandler-.*\.jar" />

  <dataDir>${solr.data.dir:}</dataDir>

  <directoryFactory name="DirectoryFactory"
                    class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>

  <codecFactory class="solr.SchemaCodecFactory"/>

  <indexConfig>
    <lockType>${solr.lock.type:native}</lockType>


     <infoStream>true</infoStream>
  </indexConfig>

  <jmx />

  <updateHandler class="solr.DirectUpdateHandler2">

    <updateLog>
      <str name="dir">${solr.ulog.dir:}</str>
    </updateLog>

    <!-- AutoCommit

         Perform a hard commit automatically under certain conditions.
         Instead of enabling autoCommit, consider using "commitWithin"
         when adding documents.

         http://wiki.apache.org/solr/UpdateXmlMessages

         maxDocs - Maximum number of documents to add since the last
                   commit before automatically triggering a new commit.

         maxTime - Maximum amount of time in ms that is allowed to pass
                   since a document was added before automatically
                   triggering a new commit.
         openSearcher - if false, the commit causes recent index changes
           to be flushed to stable storage, but does not cause a new
           searcher to be opened to make those changes visible.

         If the updateLog is enabled, then it's highly recommended to
         have some sort of hard autoCommit to limit the log size.
      -->
     <autoCommit>
       <maxTime>${solr.autoCommit.maxTime:15000}</maxTime>
       <openSearcher>false</openSearcher>
     </autoCommit>

    <!-- softAutoCommit is like autoCommit except it causes a
         'soft' commit which only ensures that changes are visible
         but does not ensure that data is synced to disk.  This is
         faster and more near-realtime friendly than a hard commit.
      -->

     <autoSoftCommit>
       <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
     </autoSoftCommit>

    <!-- Update Related Event Listeners

         Various IndexWriter related events can trigger Listeners to
         take actions.

         postCommit - fired after every commit or optimize command
         postOptimize - fired after every optimize command
      -->

  </updateHandler>

  <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       Query section - these settings control query time things like caches
       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
  <query>

    <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>


    <!-- Solr Internal Query Caches

         There are four implementations of cache available for Solr:
         LRUCache, based on a synchronized LinkedHashMap, 
         LFUCache and FastLRUCache, based on a ConcurrentHashMap, and CaffeineCache -
         a modern and robust cache implementation. Note that in Solr 9.0
         only CaffeineCache will be available, other implementations are now
         deprecated.

         FastLRUCache has faster gets and slower puts in single
         threaded operation and thus is generally faster than LRUCache
         when the hit ratio of the cache is high (> 75%), and may be
         faster under other scenarios on multi-cpu systems.
    -->

    <!-- Filter Cache

         Cache used by SolrIndexSearcher for filters (DocSets),
         unordered sets of *all* documents that match a query.  When a
         new searcher is opened, its caches may be prepopulated or
         "autowarmed" using data from caches in the old searcher.
         autowarmCount is the number of items to prepopulate.  For
         LRUCache, the autowarmed items will be the most recently
         accessed items.

         Parameters:
           class - the SolrCache implementation LRUCache or
               (LRUCache or FastLRUCache)
           size - the maximum number of entries in the cache
           initialSize - the initial capacity (number of entries) of
               the cache.  (see java.util.HashMap)
           autowarmCount - the number of entries to prepopulate from
               and old cache.
      -->
    <filterCache class="solr.FastLRUCache"
                 size="512"
                 initialSize="512"
                 autowarmCount="0"/>

    <!-- Query Result Cache

         Caches results of searches - ordered lists of document ids
         (DocList) based on a query, a sort, and the range of documents requested.
      -->
    <queryResultCache class="solr.LRUCache"
                     size="512"
                     initialSize="512"
                     autowarmCount="0"/>

    <!-- Document Cache

         Caches Lucene Document objects (the stored fields for each
         document).  Since Lucene internal document ids are transient,
         this cache will not be autowarmed.
      -->
    <documentCache class="solr.LRUCache"
                   size="512"
                   initialSize="512"
                   autowarmCount="0"/>

    <!-- custom cache currently used by block join -->
    <cache name="perSegFilter"
      class="solr.search.LRUCache"
      size="10"
      initialSize="0"
      autowarmCount="10"
      regenerator="solr.NoOpRegenerator" />

    <!-- Field Value Cache

         Cache used to hold field values that are quickly accessible
         by document id.  The fieldValueCache is created by default
         even if not configured here.
      -->
    <!--
       <fieldValueCache class="solr.FastLRUCache"
                        size="512"
                        autowarmCount="128"
                        showItems="32" />
      -->

    <!-- Custom Cache

         Example of a generic cache.  These caches may be accessed by
         name through SolrIndexSearcher.getCache(),cacheLookup(), and
         cacheInsert().  The purpose is to enable easy caching of
         user/application level data.  The regenerator argument should
         be specified as an implementation of solr.CacheRegenerator
         if autowarming is desired.
      -->
    <!--
       <cache name="myUserCache"
              class="solr.LRUCache"
              size="4096"
              initialSize="1024"
              autowarmCount="1024"
              regenerator="com.mycompany.MyRegenerator"
              />
      -->


    <!-- Lazy Field Loading

         If true, stored fields that are not requested will be loaded
         lazily.  This can result in a significant speed improvement
         if the usual case is to not load all stored fields,
         especially if the skipped fields are large compressed text
         fields.
    -->
    <enableLazyFieldLoading>true</enableLazyFieldLoading>

   <!-- Use Filter For Sorted Query

        A possible optimization that attempts to use a filter to
        satisfy a search.  If the requested sort does not include
        score, then the filterCache will be checked for a filter
        matching the query. If found, the filter will be used as the
        source of document ids, and then the sort will be applied to
        that.

        For most situations, this will not be useful unless you
        frequently get the same search repeatedly with different sort
        options, and none of them ever use "score"
     -->
   <!--
      <useFilterForSortedQuery>true</useFilterForSortedQuery>
     -->

   <!-- Result Window Size

        An optimization for use with the queryResultCache.  When a search
        is requested, a superset of the requested number of document ids
        are collected.  For example, if a search for a particular query
        requests matching documents 10 through 19, and queryWindowSize is 50,
        then documents 0 through 49 will be collected and cached.  Any further
        requests in that range can be satisfied via the cache.
     -->
   <queryResultWindowSize>50</queryResultWindowSize>

   <!-- Maximum number of documents to cache for any entry in the
        queryResultCache.
     -->
   <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

   <!-- Query Related Event Listeners

        Various IndexSearcher related events can trigger Listeners to
        take actions.

        newSearcher - fired whenever a new searcher is being prepared
        and there is a current searcher handling requests (aka
        registered).  It can be used to prime certain caches to
        prevent long request times for certain requests.

        firstSearcher - fired whenever a new searcher is being
        prepared but there is no current registered searcher to handle
        requests or to gain autowarming data from.


     -->
    <!-- QuerySenderListener takes an array of NamedList and executes a
         local query request for each NamedList in sequence.
      -->
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst> <str name="q">fgf</str> <str name="start">0</str> <str name="rows">10</str> </lst>
        <lst> <str name="q">brain</str> <str name="start">0</str> <str name="rows">10</str> </lst>
        <lst><str name="q">Westerfield</str></lst>
      </arr>
    </listener>
    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst>
          <lst><str name="q">Westerfield</str></lst>
        </lst>
      </arr>
    </listener>

    <!-- Use Cold Searcher

         If a search request comes in and there is no current
         registered searcher, then immediately register the still
         warming searcher and use it.  If "false" then all requests
         will block until the first searcher is done warming.
      -->
    <useColdSearcher>false</useColdSearcher>

  </query>


  <!-- Request Dispatcher

       This section contains instructions for how the SolrDispatchFilter
       should behave when processing requests for this SolrCore.
    -->
  <requestDispatcher>
    <!-- Request Parsing

         These settings indicate how Solr Requests may be parsed, and
         what restrictions may be placed on the ContentStreams from
         those requests

         enableRemoteStreaming - enables use of the stream.file
         and stream.url parameters for specifying remote streams.

         multipartUploadLimitInKB - specifies the max size (in KiB) of
         Multipart File Uploads that Solr will allow in a Request.

         formdataUploadLimitInKB - specifies the max size (in KiB) of
         form data (application/x-www-form-urlencoded) sent via
         POST. You can use POST to pass request parameters not
         fitting into the URL.

         addHttpRequestToContext - if set to true, it will instruct
         the requestParsers to include the original HttpServletRequest
         object in the context map of the SolrQueryRequest under the
         key "httpRequest". It will not be used by any of the existing
         Solr components, but may be useful when developing custom
         plugins.

         *** WARNING ***
         Before enabling remote streaming, you should make sure your
         system has authentication enabled.

    <requestParsers enableRemoteStreaming="false"
                    multipartUploadLimitInKB="-1"
                    formdataUploadLimitInKB="-1"
                    addHttpRequestToContext="false"/>
      -->

    <!-- HTTP Caching

         Set HTTP caching related parameters (for proxy caches and clients).

         The options below instruct Solr not to output any HTTP Caching
         related headers
      -->
    <httpCaching never304="true" />
    <!-- If you include a <cacheControl> directive, it will be used to
         generate a Cache-Control header (as well as an Expires header
         if the value contains "max-age=")

         By default, no Cache-Control header is generated.

         You can use the <cacheControl> option even if you have set
         never304="true"
      -->
    <!--
       <httpCaching never304="true" >
         <cacheControl>max-age=30, public</cacheControl>
       </httpCaching>
      -->
    <!-- To enable Solr to respond with automatically generated HTTP
         Caching headers, and to response to Cache Validation requests
         correctly, set the value of never304="false"

         This will cause Solr to generate Last-Modified and ETag
         headers based on the properties of the Index.

         The following options can also be specified to affect the
         values of these headers...

         lastModFrom - the default value is "openTime" which means the
         Last-Modified value (and validation against If-Modified-Since
         requests) will all be relative to when the current Searcher
         was opened.  You can change it to lastModFrom="dirLastMod" if
         you want the value to exactly correspond to when the physical
         index was last modified.

         etagSeed="..." is an option you can change to force the ETag
         header (and validation against If-None-Match requests) to be
         different even if the index has not changed (ie: when making
         significant changes to your config file)

         (lastModifiedFrom and etagSeed are both ignored if you use
         the never304="true" option)
      -->
    <!--
       <httpCaching lastModifiedFrom="openTime"
                    etagSeed="Solr">
         <cacheControl>max-age=30, public</cacheControl>
       </httpCaching>
      -->
  </requestDispatcher>

  <!-- Request Handlers

       http://wiki.apache.org/solr/SolrRequestHandler

       Incoming queries will be dispatched to a specific handler by name
       based on the path specified in the request.

       If a Request Handler is declared with startup="lazy", then it will
       not be initialized until the first request that uses it.

    -->

  <requestHandler name="/dataimport" class="solr.DataImportHandler">
    <lst name="defaults">
      <str name="config">db-data-config.xml</str>
    </lst>
  </requestHandler>

  <requestHandler name="/select" class="solr.StandardRequestHandler" default="true">

    <!-- Always append these -->
    <lst name="appends">
      <!-- Some categories should always be excluded from search results -->
      <str name="fq">-category:Autocomplete -category:"STR Relationship" -category:"GO Annotation" -category:"Expression Result" -category:"Phenotype Observation"</str>
    </lst>

    <!-- default values for query parameters -->

    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="sort">score desc, name_sort asc</str>

      <str name="facet">true</str>
      <str name="facet.sort">count</str>
      <str name="facet.limit">5</str>
      <str name="facet.mincount">1</str>

      <!-- initial settings for special case facets -->
      <str name="f.category.facet.sort">index</str>
      <str name="f.category.facet.limit">50</str>
      <str name="f.curator.facet.limit">50</str>
      <str name="f.stage.facet.limit">50</str>
      <str name="f.type.facet.limit">50</str>
      <str name="f.chromosome.facet.limit">50</str>
      <str name="f.related_accession.facet.limit">50</str>
      <!-- This is essentially the page size of the gallery mode pages-->
      <str name="f.img_zdb_id.facet.limit">50</str>
      <str name="f.type_0.facet.sort">index</str>
      <str name="f.type_0.facet.limit">100</str>
      <str name="f.type_1.facet.limit">100</str>
      <str name="f.type_2.facet.limit">100</str>


      <str name="q.alt">*:*</str>
      <str name="q.op">AND</str>
      <str name="defType">edismax</str>
      <!-- there is an override in SearchPrototypeController that mirrors this list but includes an extra, so they should be updated in tandem -->
      <!--screen used to be here, removed as a result of case 11323-->
      <str name="fl">name, type, id, category, full_name, url, thumbnail, image, img_zdb_id, profile_image, date, attribution_count, has_orthology, xpat_zdb_id, fig_zdb_id, score, pgcmid, is_curatable</str>

      <!-- fast vector highlighter config -->
      <str name="hl.tag.pre"><![CDATA[<span class="search-result-highlight">]]></str>
      <str name="hl.tag.post"><![CDATA[</span>]]></str>

      <!-- standard highlighter config -->
      <str name="hl.simple.pre"><![CDATA[<span class="search-result-highlight">]]></str>
      <str name="hl.simple.post"><![CDATA[</span>]]></str>

      <str name="hl">true</str>
      <str name="hl.method">unified</str>
      <str name="hl.snippets">2</str>

      <str name="hl.fragsize">80</str>
      <str name="f.abstract.hl.fragsize">400</str>
      <str name="f.abstract.hl.snippets">1</str>
      <str name="hl.phraseLimit">10</str>

      <!-- Specifies the maximum number of entries in a multi-valued field to examine before stopping. -->
      <!--         <str name="hl.maxMultiValuedToExamine">1000</str>-->
      <!-- Specifies the maximum number of matches in a multi-valued field that are found before stopping -->
      <!--         <str name="hl.maxMultiValuedToMatch">1</str>-->


      <!-- Solr seems to prefer that these all be on a single line. -->
      <str name="hl.fl"> abstract affected_gene affected_gene_full_name affected_gene_previous_name affected_gene_t affected_anatomy_hl affected_biological_process_hl affected_cellular_component_hl affected_molecular_function_hl alias_t feature_alias_t allele allele_t anatomy_hl antigen_gene antigen_gene_full_name antigen_gene_previous_name attributed_publication author_string author_year background background_t biography biological_process_hl caption category_t cellular_component_hl chromosome clone coding_sequence coding_sequence_full_name construct_name construct_t definition disease_model_t disease_t email_address engineered_region_full_name expressed_gene expressed_gene_full_name expressed_gene_previous_name expressed_in_hl expression_anatomy_hl expression_observation full_mesh_term_t full_name_t gene gene_full_name gene_previous_name genotype_full_name id_t inserted_in_gene inserted_in_gene_full_name inserted_in_gene_previous_name institution_t journal journal_t lab_member_name lab_of_origin labeled_anatomy_hl labeled_anatomy_parent_hl labeled_cellular_component_hl marker_abbrev misexpressed_gene molecular_function_hl mutagen name note omim_id ortholog_organism ortholog_organism_t ortholog_other_species_name_t ortholog_other_species_symbol phenotype_quality_hl phenotype_statement_t postal_address prefix probe promoter_full_name registered_author_t regulatory_region related_accession_t related_gene_symbol related_marker related_marker reporter_gene reporter_gene_full_name reporter_gene_previous_name rna_consequence sequence_alteration sequence_targeting_reagent_t synonym_phenotype_statement_t target target_full_name target_previous_name type_t zebrafish_gene zebrafish_gene_full_name zebrafish_gene_previous_name</str>

      <!-- boost function, rord is reverse ordinal value, so the lowest complexity is 0, next is 1, etc, I think,
           there are some memory warnings about rord, so it's possible that we don't actually want it.. -->
      <!--   <str name="bf">rord(complexity)^1.0 </str> -->
      <!-- sqrt(map(attribution_count,1000,99999999,0))^0.2 -->

      <str name="bf">
        sum($complexity_boost,$popularity_boost,$images_boost,$jtype_boost)
      </str>


      <str name="complexity_boost">mul(recip(complexity,1,1,1),1000000)</str>
      <str name="popularity_boost">mul(sqrt(popularity),0.001)</str>
      <!-- not currently in use now that most records have 'date' as their creation date, rather than last updated date,
           but I want to keep it around in case we want to use it for just pubs and figures -->
      <!-- <str name="recency_boost">mul(recip(ms(NOW/HOUR,tdate),3.16e-11,1,1),0.001) </str>-->
      <str name="images_boost">mul(exists(has_image),0.1)</str>
      <str name="jtype_boost">mul(exists(query({!v='publication_type:Journal'})),0.001)</str>
      <!-- since you can't negatively boost, this pattern boosts everything BUT the records that match these queries-->
      <str name="bq">(*:* -is_wildtype:false)^1000 (*:* -name_t:unspecified)^10000 </str>

      <str name="qf">
        proper_name_k^50.0
        proper_name_ka^30.0
        proper_name^10.0
        name
        category_t
        type_t
        name_t

        full_name^2.0

        id_t
        alias^4.0
        alias_t^4.0

        ortholog_other_species_symbol^2.0
        ortholog_other_species_symbol_t^2.0
        construct_name^2.0
        construct_alias

        feature_alias
        feature_alias_t

        construct
        construct_t
        construct_name

        full_name_ac^0.1
        alias_ac^0.1

        marker_abbrev^4.0

        ortholog_other_species_name
        ortholog_organism
        ortholog_other_species_name_t
        ortholog_organism_t
        disease_model
        disease_model_t
        disease
        disease_t
        omim_id

        phenotype_statement_t
        phenotype_statement
        synonym_phenotype_statement_t
        synonym_phenotype_statement

        journal
        journal_t
        journal_name_t
        registered_author_t^0.5
        registered_author^0.5
        author_string
        author_year
        full_mesh_term
        full_mesh_term_t

        conditions_t

        related_accession_t
        related_marker
        affected_gene_t

        labeled_anatomy_direct^1.1
        labeled_anatomy_parent^1.0
        labeled_anatomy_t
        labeled_cellular_component_direct^1.1
        labeled_cellular_component_parent^1.0
        expression_anatomy_direct^1.1
        expression_anatomy_parent^1.0
        expression_anatomy_t
        expressed_in_direct^1.0
        expressed_in_parent^1.0
        expressed_in_t^1.0
        affected_anatomy_direct^1.1
        affected_anatomy_parent^1.0
        affected_anatomy_t
        anatomy_direct^1.1
        anatomy_parent^1.0
        anatomy_t
        phenotype_quality_direct^1.1
        phenotype_quality_parent^1.0
        phenotype_quality_t
        molecular_function_direct^1.1
        molecular_function_direct^1.0
        molecular_function_t
        biological_process_direct^1.1
        biological_process_parent^1.0
        biological_process_t
        cellular_component_direct^1.1
        cellular_component_parent^1.0
        cellular_component_t

        affected_molecular_function_direct^1.1
        affected_molecular_function_direct^1.0
        affected_molecular_t
        affected_biological_process_direct^1.1
        affected_biological_process_parent^1.0
        affected_biological_t
        affected_cellular_component_direct^1.1
        affected_cellular_component_parent^1.0
        affected_cellular_t

        sequence_targeting_reagent
        sequence_targeting_reagent_t

        genotype_full_name

        antigen_gene
        antigen_gene_full_name^0.8
        antigen_gene_previous_name^0.7

        gene
        gene_full_name^0.8
        gene_previous_name^0.7

        zebrafish_gene
        zebrafish_gene_full_name^0.8
        zebrafish_gene_previous_name^0.7

        reporter_gene
        reporter_gene_full_name^0.8
        reporter_gene_previous_name^0.7

        affected_gene_full_name^0.8
        affected_gene_previous_name^0.7
        affected_gene
        expressed_gene_t
        expressed_gene_full_name^0.8
        expressed_gene_previous_name^0.7
        expressed_gene
        misexpressed_gene
        inserted_in_gene_full_name^0.8
        inserted_in_gene_previous_name^0.7
        inserted_in_gene_t
        inserted_in_gene
        regulatory_region_t
        regulatory_region
        coding_sequence_t
        coding_sequence
        promoter_full_name
        coding_sequence_full_name
        engineered_region_full_name
        target
        target_full_name
        target_previous_name

        clone
        probe
        related_gene_symbol

        prefix
        institution
        institution_t
        lab_of_origin
        rna_consequence
        related_accession_t
        related_marker
        allele_t
        background background_t
        sequence_alteration sequence_alteration_t
        probe
        mutagen
        allele
        expression_observation
        chromosome

        person_name
        lab_member_name
        email_address
        postal_address
        note^0.5
        caption^0.5
        abstract^0.5
        biography^0.5
        definition^0.5
        attributed_publication^.01
      </str>


    </lst>
  </requestHandler>





  <requestHandler name="/name-autocomplete" class="solr.StandardRequestHandler">
    <!-- default values for query parameters -->
    <lst name="defaults">
      <str name="defType">edismax</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
      <str name="q.alt">*:*</str>
      <str name="q.op">AND</str>
      <str name="qf">
        name_ac^10
        full_name_ac^5
        alias_ac^7
        ortholog_other_species_symbol_ac^4
        ortholog_other_species_name_ac^3
        name_t
        alias_t
        full_name_t
        id
      </str>
      <str name="bf">recip(complexity,1,1,1)^10 sqrt(popularity)^20</str>
      <str name="fq">-category:Publication -category:Figure</str>
      <str name="hl">true</str>
      <str name="hl.snippets">1</str>
      <str name="hl.fl">
        name_ac
        full_name_ac
        alias_ac
        ortholog_other_species_symbol_ac
        ortholog_other_species_name_ac
        name_t
        alias_t
        full_name_t
        id
      </str>
      <str name="hl.simple.pre"><![CDATA[<span class="search-result-highlight">]]></str>
      <str name="hl.simple.post"><![CDATA[</span>]]></str>
      <str name="fl">id,name,category,type,full_name,url</str>
    </lst>
  </requestHandler>

  <requestHandler name="/expression-annotation" class="solr.StandardRequestHandler">
    <lst name="appends">
      <str name="fq">category:"Expression Result"</str>
      <str name="q">*:*</str>
    </lst>
    <lst name="defaults">
      <str name="defType">edismax</str>
      <str name="q.op">AND</str>
      <str name="df">id</str>
      <str name="wt">json</str>
      <str name="pretty">true</str>
      <str name="facet">true</str>
      <str name="facet.mincount">1</str>
      <str name="rows">0</str>
    </lst>
  </requestHandler>

  <requestHandler name="/phenotype-annotation" class="solr.StandardRequestHandler">
    <lst name="appends">
      <str name="fq">category:"Phenotype Observation" AND is_monogenic:true AND phenotype_statement_tag:abnormal</str>
      <str name="q">*:*</str>
    </lst>
    <lst name="defaults">
      <str name="defType">edismax</str>
      <str name="df">id</str>
      <str name="wt">json</str>
      <str name="pretty">true</str>
      <str name="facet">true</str>
      <str name="facet.mincount">1</str>
      <str name="rows">0</str>
    </lst>
  </requestHandler>

  <requestHandler name="/go-annotation" class="solr.StandardRequestHandler">
    <lst name="appends">
      <str name="fq">category:"GO Annotation"</str>
      <str name="q">*:*</str>
    </lst>
    <lst name="defaults">
      <str name="defType">edismax</str>
      <str name="q.op">AND</str>
      <str name="df">id</str>
      <str name="wt">json</str>
      <str name="pretty">true</str>
      <str name="facet">true</str>
      <str name="facet.mincount">1</str>
      <str name="rows">0</str>
    </lst>
  </requestHandler>

  <requestHandler name="/mlt" class="solr.MoreLikeThisHandler">
    <lst name="defaults">
      <int name="mlt.mindf">1</int>
    </lst>
  </requestHandler>

  <requestHandler name="/pub-mlt" class="solr.MoreLikeThisHandler">
    <lst name="defaults">
      <str name="fq">category:Publication</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
      <str name="mlt.fl">full_name,gene,sequence_alteration,abstract,registered_author,author_string,author_year</str>
      <str name="fl">score,id,name,full_name,abstract,gene,sequence_alteration</str>
      <int name="mlt.mindf">1</int>
      <str name="mlt.interestingTerms">details</str>
      <str name="mlt.boost">true</str>
      <str name="mlt.maxqt">5000</str>
      <str name="mlt.mintf">1</str>
      <str name="mlt.mindf">2</str>
    </lst>
  </requestHandler>

  <requestHandler name="/gene-mlt" class="solr.MoreLikeThisHandler">
    <lst name="defaults">
      <str name="fq">category:Gene</str>
      <str name="wt">csv</str>
      <str name="indent">true</str>
      <str name="mlt.fl">expressed_in,affected_anatomy</str>
      <str name="fl">score,id,name,full_name</str>
      <int name="mlt.mindf">1</int>
      <!--
              <str name="mlt.interestingTerms">details</str>
      -->
      <str name="mlt.boost">false</str>
      <str name="mlt.maxqt">5000</str>
      <str name="mlt.mintf">1</str>
      <str name="mlt.mindf">2</str>
    </lst>
  </requestHandler>

  <requestHandler name="/fish-search" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="appends">
      <str name="fq">(category:Fish) OR (category:"Mutation / Tg")</str>
    </lst>
    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="sort">score desc, name_sort asc</str>

      <str name="q.alt">*:*</str>
      <str name="q.op">AND</str>
      <str name="defType">edismax</str>
      <!-- This list needs to match the fl for the primary requesthandler, or, more importantly, it needs to match the annotations in SearchResult.java  -->
      <str name="fl">name, type, id, category, full_name, url, thumbnail, image, profile_image, date, attribution_count, has_orthology, xpat_zdb_id, fig_zdb_id, score, pgcmid, is_curatable</str>
      <str name="qf">
        proper_name_k^100.0
        proper_name^10.0
        name
        category_t
        type_t
        name_t

        full_name^2.0

        id_t
        alias^4.0
        alias_t^4.0

        construct
        construct_t

        feature_alias
        feature_alias_t

        sequence_targeting_reagent
        sequence_targeting_reagent_t

        affected_gene_full_name^0.8
        affected_gene_previous_name^0.7
        affected_gene

        allele_t
        background background_t
        sequence_alteration sequence_alteration_t

        related_gene_symbol
      </str>

      <str name="boost">
        $complexity_boost
      </str>

      <str name="complexity_boost">sub(10,scale(complexity,1,10))</str>
    </lst>
  </requestHandler>

  <requestHandler name="/marker-search" class="org.apache.solr.handler.component.SearchHandler">

    <lst name="appends">
      <!--todo: only include construct for root users, so probably this whole fq happens in the controller -->
      <str name="fq">
        category:"Gene / Transcript"
        OR category:"Marker / Clone"
        OR category:"Construct"
        OR category:"STR Relationship"
        OR category:"Antibody"
      </str>
    </lst>

    <lst name="defaults">
      <str name="echoParams">explicit</str>
      <str name="wt">json</str>
      <str name="indent">true</str>
      <str name="df">id</str>
      <str name="q.op">AND</str>
      <str name="rows">20</str>

      <!-- name searching gets fancy sorting in the controller -->

      <str name="sort">name_sort asc</str>

      <str name="hl">true</str>
      <str name="hl.requireFieldMatch">true</str>


      <!-- fast vector highlighter config -->
      <str name="hl.tag.pre"><![CDATA[<span class="search-result-highlight">]]></str>
      <str name="hl.tag.post"><![CDATA[</span>]]></str>

      <!-- standard highlighter config -->
      <str name="hl.simple.pre"><![CDATA[<span class="search-result-highlight">]]></str>
      <str name="hl.simple.post"><![CDATA[</span>]]></str>

      <str name="hl">true</str>
      <str name="hl.useFastVectorHighligter">true</str>
      <str name="hl.snippets">1</str>
      <str name="hl.fragsize">80</str>

      <!-- Specifies the maximum number of entries in a multi-valued field to examine before stopping. -->
      <str name="hl.maxMultiValuedToExamine">20000</str>
      <!-- Specifies the maximum number of matches in a multi-valued field that are found before stopping -->
      <str name="hl.maxMultiValuedToMatch">1</str>




      <str name="facet">true</str>
      <str name="facet.mincount">1</str>
      <str name="facet.sort">index</str>
      <str name="facet.field">typegroup</str>
      <str name="facet.field">chromosome</str>

      <str name="defType">edismax</str>
      <str name="q.alt">*:*</str>

    </lst>

  </requestHandler>

  <requestHandler name="/search" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <!--
    By default, this will register the following components:

    <arr name="components">
      <str>query</str>
      <str>facet</str>
      <str>mlt</str>
      <str>highlight</str>
      <str>debug</str>
    </arr>

    To insert handlers before or after the 'standard' components, use:

    <arr name="first-components">
      <str>first</str>
    </arr>

    <arr name="last-components">
      <str>last</str>
    </arr>

    -->
  </requestHandler>

  <requestHandler name="/update" class="solr.UpdateRequestHandler"  />


  <requestHandler name="/analysis/field" class="solr.FieldAnalysisRequestHandler" />

  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    <lst name="defaults">
      <str name="echoParams">explicit</str> <!-- for all params (including the default etc) use: 'all' -->
      <str name="echoHandler">true</str>
    </lst>
  </requestHandler>


  <!-- Highlighting Component

       http://wiki.apache.org/solr/HighlightingParameters
    -->
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap"
                  default="true"
                  class="solr.highlight.GapFragmenter">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter
           (for sentence extraction)
        -->
      <fragmenter name="regex"
                  class="solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html"
                 default="true"
                 class="solr.highlight.HtmlFormatter">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html"
               class="solr.highlight.HtmlEncoder" />

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple"
                       class="solr.highlight.SimpleFragListBuilder"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single"
                       class="solr.highlight.SingleFragListBuilder"/>

      <!-- Configure the weighted fragListBuilder -->
      <fragListBuilder name="weighted"
                       default="true"
                       class="solr.highlight.WeightedFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default"
                        default="true"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <!--
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored"
                        class="solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>

      <boundaryScanner name="default"
                       default="true"
                       class="solr.highlight.SimpleBoundaryScanner">
        <lst name="defaults">
          <str name="hl.bs.maxScan">10</str>
          <str name="hl.bs.chars">.,!? &#9;&#10;&#13;</str>
        </lst>
      </boundaryScanner>

      <boundaryScanner name="breakIterator"
                       class="solr.highlight.BreakIteratorBoundaryScanner">
        <lst name="defaults">
          <!-- type should be one of CHARACTER, WORD(default), LINE and SENTENCE -->
          <str name="hl.bs.type">WORD</str>
          <!-- language and country are used when constructing Locale object.  -->
          <!-- And the Locale object will be used when getting instance of BreakIterator -->
          <str name="hl.bs.language">en</str>
          <str name="hl.bs.country">US</str>
        </lst>
      </boundaryScanner>
    </highlighting>
  </searchComponent>

  <!-- Update Processors

       Chains of Update Processor Factories for dealing with Update
       Requests can be declared, and then used by name in Update
       Request Processors

       http://wiki.apache.org/solr/UpdateRequestProcessor

    -->
  <!-- Deduplication

       An example dedup update processor that creates the "id" field
       on the fly based on the hash code of some other fields.  This
       example has overwriteDupes set to false since we are using the
       id field as the signatureField and Solr will maintain
       uniqueness based on that anyway.

    -->
  <!--
     <updateRequestProcessorChain name="dedupe">
       <processor class="solr.processor.SignatureUpdateProcessorFactory">
         <bool name="enabled">true</bool>
         <str name="signatureField">id</str>
         <bool name="overwriteDupes">false</bool>
         <str name="fields">name,features,cat</str>
         <str name="signatureClass">solr.processor.Lookup3Signature</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->

  <!-- Language identification

       This example update chain identifies the language of the incoming
       documents using the langid contrib. The detected language is
       written to field language_s. No field name mapping is done.
       The fields used for detection are text, title, subject and description,
       making this example suitable for detecting languages form full-text
       rich documents injected via ExtractingRequestHandler.
       See more about langId at http://wiki.apache.org/solr/LanguageDetection
    -->
    <!--
     <updateRequestProcessorChain name="langid">
       <processor class="org.apache.solr.update.processor.TikaLanguageIdentifierUpdateProcessorFactory">
         <str name="langid.fl">text,title,subject,description</str>
         <str name="langid.langField">language_s</str>
         <str name="langid.fallback">en</str>
       </processor>
       <processor class="solr.LogUpdateProcessorFactory" />
       <processor class="solr.RunUpdateProcessorFactory" />
     </updateRequestProcessorChain>
    -->

  <!-- Script update processor

    This example hooks in an update processor implemented using JavaScript.

    See more about the script update processor at http://wiki.apache.org/solr/ScriptUpdateProcessor
  -->
  <!--
    <updateRequestProcessorChain name="script">
      <processor class="solr.StatelessScriptUpdateProcessorFactory">
        <str name="script">update-script.js</str>
        <lst name="params">
          <str name="config_param">example config parameter</str>
        </lst>
      </processor>
      <processor class="solr.RunUpdateProcessorFactory" />
    </updateRequestProcessorChain>
  -->

  <!-- Response Writers

       http://wiki.apache.org/solr/QueryResponseWriter

       Request responses will be written using the writer specified by
       the 'wt' request parameter matching the name of a registered
       writer.

       The "default" writer is the default and will be used if 'wt' is
       not specified in the request.
    -->
  <!-- The following response writers are implicitly configured unless
       overridden...
    -->
  <!--
     <queryResponseWriter name="xml"
                          default="true"
                          class="solr.XMLResponseWriter" />
     <queryResponseWriter name="json" class="solr.JSONResponseWriter"/>
     <queryResponseWriter name="python" class="solr.PythonResponseWriter"/>
     <queryResponseWriter name="ruby" class="solr.RubyResponseWriter"/>
     <queryResponseWriter name="php" class="solr.PHPResponseWriter"/>
     <queryResponseWriter name="phps" class="solr.PHPSerializedResponseWriter"/>
     <queryResponseWriter name="csv" class="solr.CSVResponseWriter"/>
     <queryResponseWriter name="schema.xml" class="solr.SchemaXmlResponseWriter"/>
    -->

  <queryResponseWriter name="json" class="solr.JSONResponseWriter">
     <!-- For the purposes of the tutorial, JSON responses are written as
      plain text so that they are easy to read in *any* browser.
      If you expect a MIME type of "application/json" just remove this override.
     -->
    <str name="content-type">text/plain; charset=UTF-8</str>
  </queryResponseWriter>

  <!--
     Custom response writers can be declared as needed...
    -->
  <queryResponseWriter name="velocity" class="solr.VelocityResponseWriter" startup="lazy">
    <str name="template.base.dir">${velocity.template.base.dir:}</str>
  </queryResponseWriter>

  <!-- XSLT response writer transforms the XML output by any xslt file found
       in Solr's conf/xslt directory.  Changes to xslt files are checked for
       every xsltCacheLifetimeSeconds.
    -->
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>

  <!-- Query Parsers

       https://lucene.apache.org/solr/guide/query-syntax-and-parsing.html

       Multiple QParserPlugins can be registered by name, and then
       used in either the "defType" param for the QueryComponent (used
       by SearchHandler) or in LocalParams
    -->
  <!-- example of registering a query parser -->
  <!--
     <queryParser name="myparser" class="com.mycompany.MyQParserPlugin"/>
    -->

  <!-- Function Parsers

       http://wiki.apache.org/solr/FunctionQuery

       Multiple ValueSourceParsers can be registered by name, and then
       used as function names when using the "func" QParser.
    -->
  <!-- example of registering a custom function parser  -->
  <!--
     <valueSourceParser name="myfunc"
                        class="com.mycompany.MyValueSourceParser" />
    -->


  <!-- Document Transformers
       http://wiki.apache.org/solr/DocTransformers
    -->
  <!--
     Could be something like:
     <transformer name="db" class="com.mycompany.LoadFromDatabaseTransformer" >
       <int name="connection">jdbc://....</int>
     </transformer>

     To add a constant value to all docs, use:
     <transformer name="mytrans2" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <int name="value">5</int>
     </transformer>

     If you want the user to still be able to change it with _value:something_ use this:
     <transformer name="mytrans3" class="org.apache.solr.response.transform.ValueAugmenterFactory" >
       <double name="defaultValue">5</double>
     </transformer>

      If you are using the QueryElevationComponent, you may wish to mark documents that get boosted.  The
      EditorialMarkerFactory will do exactly that:
     <transformer name="qecBooster" class="org.apache.solr.response.transform.EditorialMarkerFactory" />
    -->

</config>
