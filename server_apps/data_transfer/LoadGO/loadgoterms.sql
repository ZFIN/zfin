begin work;

-- FILE: loadgoterms.sql
-- PREFIX: lgotrms_ (none added as of Feb. 2005)

-- DESCRIPTION:
-- This sql script loads updates to the go_term table from the ontology.unl 
-- file (which is generated by test.pl).  
-- The ontology.unl file is generated from 3 txt files
-- which are downloaded from the GO website, parsed by test.pl and 
-- stored in 2 .unl files.
-- The ontology.unl file contains primary GOterms that should exist at ZFIN.  
-- Those that do not currently exist at ZFIN will be added with this script.   
-- make a temp table that will contain records currently in the 
-- go_term table at ZFIN.
-- It als takes input from the OBO parsed file, generated by
-- parse_defs.r

-- INPUT VARS: parsed ontology and OBO files
-- OUTPUT VARS: 

-- OUTPUT: unload files for secondary, obsolete, terms, and 
--         reinstated go terms

create temp table exist_record (
                extrecd_zdb_id  varchar(50),
                new_zdb_id      varchar(50)
                );

create temp table sec_dups 
  (
    sec_id varchar(50),
    prim_id varchar(50),
    term_name varchar(255),
    onto varchar(30)
  );

--load the secondary table with all secondary terms, regardless
--of duplication

load from ontsecgoid.unl insert into sec_dups ;

create temp table sec_oks 
  (
    sec_id varchar(50),
    prim_id varchar(50),
    term_name varchar(255),
    onto varchar(30)
  );

--insert only the distinct secondary terms

insert into sec_oks
  select distinct * from sec_dups ;

create temp table sec_unload 
  (
    sec_id varchar(50),
    prim_id varchar(50),
    term_name varchar(255),
    onto varchar(30)
  );

--update the secondary terms in ZFIN

update go_term
  set goterm_is_secondary = 't'
  where goterm_go_id in (select sec_id from sec_oks) ;

--create a table for unload to report 

insert into sec_unload
  select sec_id, prim_id, term_name, onto
    from sec_oks
    where sec_id in (select goterm_go_id from go_Term) ;

create temp table sec_unload_report 
  (
    sec_id varchar(70),
    prim_id varchar(70),
    term_name varchar(255),
    onto varchar(50),
    go_marker	varchar(70),
    mrkrgo_pub_zdb_id varchar(70)
  );

insert into sec_unload_report
  select 'Now Secondary: GO:'||sec_id, 
	'Now Primary: GO:'||prim_id, 
	'Name: '||term_name, 
	'Ontology: '||onto,
 	'Gene: '||mrkrgoev_mrkr_zdb_id, 
	'Pub: '||mrkrgoev_source_zdb_id
    from sec_unload, go_term, marker_go_term_Evidence
    where sec_id = goterm_go_id
    and mrkrgoev_go_term_zdb_id = goterm_zdb_id ;

--these two unload files will be picked up by loadgo.pl, the script
--these two unload files will be picked up by loadgo.pl, the script
--running this sql script and sent to Doug H. and informix

unload to 'newannotsecterms.unl' select * from sec_unload_report ;
unload to 'newsecterms.unl' select * from sec_unload ;

--make a temp table that will contain records from ontology.unl 
--(this table will contain
--records that are already in zfindb.go_term at first load).

create temp table goterm_onto_with_dups (
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30)
	)with no log;

--load the ontology file

load from ontology.unl insert into goterm_onto_with_dups;

--secondary id is first column in this file.

--create table that will weed out any duplications in primary terms 
--from the ontology.pl file (which is currently loaded into goterm_with_dups).

create temp table goterm_onto (		
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30)
	)with no log;

create index goterm_onto_index 
  on goterm_onto (goterm_id)
  using btree
  in idxdbs1 ;

create index goterm_name_index 
  on goterm_onto (goterm_name,goterm_onto)
  using btree 
  in idxdbs1 ;

insert into goterm_onto
  select distinct * 
    from goterm_onto_with_dups;

--make a copy of goterm_onto (unique ontology.unl records) in gotermonto.unl
unload to 'gotermonto.unl' select * from goterm_onto;

--make a temp table that will eventually hold distinctly new (to ZFIN) 
--go_Term ids from
--the goterm_onto table. 

create temp table new_goterm (		
                goterm_zdb_id   varchar(50),
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
                goterm_is_obsolete boolean,
		goterm_is_secondary boolean
        )with no log;

create index new_goterm_index 
  on new_goterm (goterm_name,goterm_onto)
  using btree 
  in idxdbs2 ;

create index goterm_id_index 
  on new_goterm (goterm_id)
  using btree 
  in idxdbs2 ;

insert into new_goterm (goterm_id,
			goterm_name,
			goterm_onto,
			goterm_is_obsolete, goterm_is_secondary) 
  select distinct goterm_id,
		  trim(goterm_name),
		  goterm_onto,
		  'f', 'f' 
  from goterm_onto 
  where goterm_id not in (select goterm_go_id 
 	    		    from go_term);

--give new goterms new zdb_ids.

update new_goterm 
  set goterm_zdb_id = get_id("GOTERM");

--make double sure we only get new records, by making a table of
--go term ids that exist in zfindb.go_term and in new_goterm
--and deleting records from exist_Record where this match occurs.

!echo exist record 

insert into exist_record
                select g.goterm_zdb_id, p.goterm_zdb_id
                  from go_term g, new_goterm p
                 where g.goterm_go_id = p.goterm_id;

delete from new_goterm
  where goterm_zdb_id in
      (select new_zdb_id from exist_record)
         and goterm_name in (select goterm_name from go_term);

!echo 'Insert GOTERM into zdb_active_data'

--insert into zdb_active_data select goterm_zdb_id from new_goterm;

select goterm_name 
  from new_goterm 
  group by goterm_name 
    having count(*) > 1 ;

select goterm_id 
  from new_goterm 
  group by goterm_id 
  having count(*) > 1 ;

select goterm_name, goterm_onto 
  from new_goterm 
  group by goterm_name, goterm_onto 
    having count(*) > 1 ;

unload to 'updatedterms.unl'
  select n.goterm_name, g.goterm_name, g.goterm_go_id 
    from new_goterm n, go_term g 
    where n.goterm_id = g.goterm_go_id 
    and n.goterm_name not like g.goterm_name;

update statistics high for table goterm_onto ;
update statistics high for table go_Term ;

update go_term 
  set goterm_name= (select goterm_name 
		      from goterm_onto 
                      where goterm_id = goterm_go_id)
  where goterm_go_id in (select goterm_id 
		       from goterm_onto) ;

insert into zdb_active_data 
	select goterm_zdb_id 
	  from new_goterm 
	  where goterm_id not in (select goterm_go_id 
				    from go_term);

unload to 'newterms.unl' 
  select * 
    from new_goterm 
    where goterm_id not in (select goterm_go_id 
			      from go_term)  ;

!echo 'Insert into go_term'

	create temp table goterm (		
                go_zdb_id   varchar(50),
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
                goterm_is_obsolete boolean
        )with no log;

load from newterms.unl insert into go_term ;

---------------------------------------------
--check obsoleteness and update
---------------------------------------------

create temp table tmp_obs (id	varchar(30),
			name	varchar(255),
			namespace varchar(40),
			def lvarchar,
			is_a varchar(255),
			exact_synonym varchar(255),
			alt_id varchar(30),
			xref_analog varchar(100),
			relationship varchar(20),
			comment lvarchar,
			is_obsolete varchar(10),
			xref_unknown varchar(100),
			subset varchar(100),
			synonym varchar(255),
			related_synonym varchar(255),
			narrow_synonym varchar(255),
			broad_synonym varchar(255),
			use_term varchar(255)	
			  
) with no log ;

load from godefs_parsed.unl insert into tmp_obs ;

create temp table tmp_obs_GO (
			   name	    varchar(255),
			   id	    varchar(30),
			   def	lvarchar,
			   is_obsolete varchar(10),
			   comment lvarchar
) with no log ;


insert into tmp_obs_GO (name, id, def, is_obsolete, comment)
  select name, substr(id, -7), def, 't', comment
    from tmp_obs 
    where def like '%OBSOLETE%' or 
          def like '%obsolete%' or
	  is_obsolete = 'true' ;

create temp table tmp_obs_no_dups (
			   name	    varchar(255),
			   id	    varchar(30),
			   def	lvarchar,
			   is_obsolete varchar(10),
			   comment lvarchar
) with no log ;


---------------------------------------------
--check for terms that have been reinstated and update
---------------------------------------------

create temp table tmp_reinstate (
			   name	    varchar(255),
			   id	    varchar(30),
			   def	lvarchar,
			   is_obsolete boolean,
			   comment lvarchar
) with no log ;


insert into tmp_reinstate (name, id, def, is_obsolete, comment)
  select name, substr(id, -7), def, 'f', comment
    from tmp_obs
    where def not like '%OBSOLETE%' and 
          def not like '%obsolete%' and
	  is_obsolete = 'false' ;

create temp table tmp_reinstate_no_dups (
			   name	    varchar(255),
			   id	    varchar(30),
			   def	lvarchar,
			   is_obsolete boolean,
			   comment lvarchar
) with no log ;


insert into tmp_obs_no_dups 
  select distinct * from tmp_obs_GO ;

insert into tmp_reinstate_no_dups
  select distinct * from tmp_reinstate ;


create temp table tmp_new_obsoletes (counter integer,
				     mrkr_name varchar(255), 
			             goterm_name varchar(255), 
				     comment lvarchar
) with no log ;


create temp table tmp_new_reinstates (counter integer,
				     mrkr_name varchar(255), 
			             goterm_name varchar(255), 
				     comment lvarchar
) with no log ;

insert into tmp_new_reinstates (counter,
				mrkr_name,
				goterm_name,
				comment)
  select count(*), 
		mrkr_name, 
		goterm_name, 
		comment
  from go_term, marker_go_term_evidence, marker, tmp_reinstate_no_dups
  where goterm_go_id = id
  and goterm_zdb_id = mrkrgoev_go_term_zdb_id
  and mrkr_zdb_id = mrkrgoev_mrkr_zdb_id 
   group by mrkr_name, goterm_name, comment ;


insert into tmp_new_obsoletes (counter,
				mrkr_name,
				goterm_name,
				comment)
  select count(*), 
		mrkr_name, 
		goterm_name, 
		comment
  from go_term, marker_go_term_evidence, marker, tmp_obs_no_dups
  where goterm_go_id = id
  and goterm_zdb_id = mrkrgoev_go_term_zdb_id
  and mrkr_zdb_id = mrkrgoev_mrkr_zdb_id 
   group by mrkr_name, goterm_name, comment ;



unload to new_obsolete_terms.unl 
  select "Number annotations: "||counter,
	 "Gene: "||mrkr_name,
	 "Go Term: "||goterm_name,
	 "Use Term Comments: "||comment
	from tmp_new_obsoletes ;

unload to new_reinstated_terms.unl 
  select "Number annotations: "||counter,
	 "Gene: "||mrkr_name,
	 "Go Term: "||goterm_name,
	 "Use Term Comments: "||comment
	from tmp_new_reinstates ;

--set goterms to obsolete, and not-obsolete for reinstated

update go_term
  set goterm_is_obsolete = 'f'
  where goterm_go_id in (select id 
			  from tmp_reinstate_no_dups) 
  and goterm_is_obsolete = 't' ;


update go_term
  set goterm_is_obsolete = 't'
  where goterm_go_id in (select id 
			  from tmp_obs_no_dups) 
  and goterm_is_obsolete = 'f' ;

---This final check is to see if any obsolete or secondary GO terms
---have been added to the "with" field

create temp table obssec_with (
                go_id  varchar(80),
                mrkr_name      varchar(80),
                is_what    varchar(3)
                );

insert into obssec_with
      select distinct infgrmem_inferred_from, mrkr_name, 'obs' 
      from inference_group_member, go_term, marker, marker_go_term_evidence
      where substr(infgrmem_inferred_from, -7) = goterm_go_id
      and goterm_is_obsolete='t'
      and infgrmem_mrkrgoev_zdb_id=mrkrgoev_zdb_id
      and mrkrgoev_mrkr_zdb_id=mrkr_zdb_id;

insert into obssec_with
      select distinct infgrmem_inferred_from, mrkr_name, 'sec' 
      from inference_group_member, go_term, marker, marker_go_term_evidence
      where substr(infgrmem_inferred_from, -7) = goterm_go_id
      and goterm_is_secondary='t'
      and infgrmem_mrkrgoev_zdb_id=mrkrgoev_zdb_id
      and mrkrgoev_mrkr_zdb_id=mrkr_zdb_id;


unload to obso_sec_with.unl 
	 select distinct "Gene: "||mrkr_name,
	 "Go Term: "||go_id,
	 "Flag : "||is_what
	from obssec_with ;
--rollback work;
commit work;

