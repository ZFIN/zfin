begin work;

-- FILE: loadgoterms.sql

-- DESCRIPTION:
-- This sql script loads updates to the go_term table from the ontology.unl 
-- file (which is generated by test.pl).  
-- The ontology.unl file is generated from 3 txt files
-- which are downloaded from the GO website, parsed by test.pl and 
-- stored in 2 .unl files.
-- The ontology.unl file contains primary GOterms that should exist at ZFIN.  
-- Those that do not currently exist at ZFIN will be added with this script.   
-- make a temp table that will contain records currently in the 
-- go_term table at ZFIN.
-- It als takes input from the OBO parsed file, generated by
-- parse_defs.r

-- INPUT VARS: parsed ontology and OBO files
-- OUTPUT VARS: 

-- OUTPUT: unload files for secondary, obsolete, terms, and 
--         reinstated go terms

create temp table goterm_onto_with_dups (
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
		goterm_definition	lvarchar,
		goterm_comment		lvarchar,
		goterm_is_obsolete	varchar(10)
	)with no log;

--load the ontology file

load from goterm_parsed.unl insert into goterm_onto_with_dups;

select count(*) from goterm_onto_with_dups
  where goterm_is_obsolete = 'true' ;

update goterm_onto_with_dups
  set goterm_onto = 'Molecular Function'
  where goterm_onto = 'molecular_function' ;

update goterm_onto_with_dups
  set goterm_onto = 'Cellular Component'
  where goterm_onto = 'cellular_component' ;

update goterm_onto_with_dups
  set goterm_onto = 'Biological Process'
  where goterm_onto = 'biological_process' ;

select distinct goterm_onto 
  from goterm_onto_with_dups
  where not exists (select 'x'
			from go_ontology
			where gont_ontology_name = goterm_onto);

--create table that will weed out any duplications in primary terms.

create temp table goterm_onto (		
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
	        goterm_definition	lvarchar,
		goterm_comment		lvarchar,
		goterm_is_obsolete	varchar(10)
	)with no log;

create index goterm_onto_index 
  on goterm_onto (goterm_id)
  using btree
  in idxdbs1 ;

create index goterm_name_index 
  on goterm_onto (goterm_name,goterm_onto)
  using btree 
  in idxdbs1 ;

--update statistics high for table goterm_onto ;

insert into goterm_onto (goterm_id, goterm_name, goterm_onto, goterm_definition,
	goterm_comment, goterm_is_obsolete)
  select distinct goterm_id, goterm_name, goterm_onto, goterm_definition,
	goterm_comment, goterm_is_obsolete 
    from goterm_onto_with_dups;

select count(*)
  from goterm_onto
  where goterm_is_obsolete = 'true' ;

--make a temp table that will eventually hold distinctly new (to ZFIN) 
--go_Term ids from
--the goterm_onto table. 

create temp table new_goterm (		
                goterm_zdb_id   varchar(50),
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
                goterm_is_obsolete boolean,
		goterm_is_secondary boolean
        )with no log;

create index new_goterm_index 
  on new_goterm (goterm_name,goterm_onto)
  using btree 
  in idxdbs2 ;

create index goterm_id_index 
  on new_goterm (goterm_id)
  using btree 
  in idxdbs2 ;

update goterm_onto
  set goterm_id = substr(goterm_id, -7) ;

--update statistics high for table goterm_onto ;

insert into new_goterm (goterm_id,
			goterm_name,
			goterm_onto,
			goterm_is_obsolete, 
			goterm_is_secondary) 
  select distinct goterm_id,
		  trim(goterm_name),
		  goterm_onto,
		  'f', 
		  'f' 
  from goterm_onto 
  where not exists (select 'x'
 	    		    from go_term
			    where goterm_go_id = goterm_id);

update new_goterm 
  set goterm_zdb_id = get_id("GOTERM");


!echo 'Insert GOTERM into zdb_active_data'

--insert into zdb_active_data select goterm_zdb_id from new_goterm;

unload to 'updatedterms.unl'
  select n.goterm_name, g.goterm_name, g.goterm_go_id 
    from new_goterm n, go_term g 
    where n.goterm_id = g.goterm_go_id 
    and n.goterm_name not like g.goterm_name;

--update statistics high for table goterm_onto ;
--update statistics high for table go_Term ;

--update statistics high for table goterm_onto ;

!echo "here is the update of name" ;

update go_term 
  set goterm_name= (select goterm_name 
		      from goterm_onto 
                      where goterm_id = goterm_go_id)
  where exists (select 'x'
		       from goterm_onto
			where goterm_go_id = goterm_id) ;

insert into zdb_active_data 
	select goterm_zdb_id 
	  from new_goterm 
	  where goterm_id not in (select goterm_go_id 
				    from go_term);

unload to 'newterms.unl' 
  select * 
    from new_goterm 
    where goterm_id not in (select goterm_go_id 
			      from go_term)  ;

!echo 'Insert into go_term'

	create temp table goterm (		
                go_zdb_id   varchar(50),
		goterm_id	varchar(10),
		goterm_name	varchar(255),
		goterm_onto	varchar(30),
                goterm_is_obsolete boolean
        )with no log;

load from newterms.unl insert into go_term ;

---------------------------------------------
--check obsoleteness and update
---------------------------------------------

create temp table tmp_obs_no_dups (goterm_id varchar(30), 
			 		goterm_name varchar(255), 
			 		goterm_comment lvarchar)
with no log ;

!echo "here are the obsolete terms" ;

insert into tmp_obs_no_dups (goterm_id, goterm_name, goterm_comment)
  select distinct goterm_id, goterm_name, goterm_comment
    from goterm_onto
    where goterm_is_obsolete = 'true';



--figure out the new ones 

create temp table tmp_new_obsoletes (counter integer,
				     mrkr_name varchar(255), 
			             goterm_name varchar(255), 
				     comment lvarchar
) with no log ;

--update statistics high for table go_term;
--update statistics high for table marker_go_term_evidence;


create index id_index 
 on tmp_obs_no_dups (goterm_id) 
 using btree in idxdbs3 ;

--update statistics high for table tmp_obs_no_dups;
--update statistics high for table marker ;

insert into tmp_new_obsoletes (counter,
				mrkr_name,
				goterm_name,
				comment)
  select count(*), 
		mrkr_name, 
		go_term.goterm_name, 
		goterm_comment
  from go_term, 
	marker_go_term_evidence, 
	marker, 
	tmp_obs_no_dups
  where goterm_go_id = tmp_obs_no_dups.goterm_id
  and goterm_zdb_id = mrkrgoev_term_zdb_id
  and mrkr_zdb_id = mrkrgoev_mrkr_zdb_id 
  and goterm_is_obsolete = 'f'
   group by mrkr_name, go_term.goterm_name, goterm_comment ;


unload to new_obsolete_terms.unl 
  select "Number annotations: "||counter,
	 "Gene: "||mrkr_name,
	 "Go Term: "||goterm_name,
	 "Use Term Comments: "||comment
	from tmp_new_obsoletes ;

---------------------------------------------
--check for terms that have been reinstated and update
---------------------------------------------

create temp table tmp_reinstate (id  varchar(30),
			   name	    varchar(255),
			   def	lvarchar,
			   comment lvarchar
) with no log ;


--update statistics high for table go_term ;

--update statistics high for table goterm_onto ;

!echo "this is how many are being reinstated" ;


insert into tmp_reinstate (name, id, def, comment)
  select distinct go_term.goterm_name, 
			goterm_go_id, 
			goterm_definition, 
			goterm_comment 
    from go_term, goterm_onto
    where go_term.goterm_is_obsolete = 't' 
    and go_term.goterm_go_id = goterm_onto.goterm_id
    and goterm_onto.goterm_is_obsolete is null;

create index tmpreinstate_index 
  on tmp_reinstate(id)
  using btree in idxdbs3 ;

--update statistics high for table tmp_reinstate ;

create temp table tmp_reinstate_no_dups (
			   id    varchar(30),
			   name	    varchar(255),
			   def	lvarchar,
			   comment lvarchar
) with no log ;

insert into tmp_reinstate_no_dups
  select distinct * from tmp_reinstate ;

unload to reinstated_go_terms.txt
  select goterm_is_obsolete, goterm_name, goterm_go_id
  from go_term
  where exists (select 'x'
			  from tmp_reinstate_no_dups
			  where "GO:"||goterm_go_id = id) 
  and goterm_is_obsolete = 't' ;

--update the goterms and the reinstates

update go_term
  set goterm_is_obsolete = 'f'
  where goterm_go_id in (select id 
			  from tmp_reinstate_no_dups) 
  and goterm_is_obsolete = 't' ;

update go_term
  set goterm_is_obsolete = 't'
  where goterm_go_id in (select goterm_id 
			  from tmp_obs_no_dups) 
  and goterm_is_obsolete = 'f' ;


--secondary terms.


create temp table sec_dups 
  (
    prim_id varchar(50),
    sec_id varchar(50)
  );

load from goterm_secondary.unl
  insert into sec_dups;

create temp table sec_oks 
  (
    prim_id varchar(50),
    sec_id varchar(50)
  );

--insert only the distinct secondary terms
!echo "start of the non-dup secondary terms" ;

insert into sec_oks (sec_id, prim_id)
  select distinct sec_id, prim_id
    from sec_dups ;

create temp table sec_unload 
  (
    prim_id varchar(50),
    sec_id varchar(50)
  );

--update the secondary terms in ZFIN

!echo "here is the secondary update for zfin" ;

update go_term
  set goterm_is_secondary = 't'
  where "GO:"||goterm_go_id in (select sec_id from sec_oks) ;

update go_term
  set goterm_is_obsolete = 'f'
  where goterm_is_obsolete = 't'
  and goterm_is_secondary = 't'
  and "GO:"||goterm_go_id in (select sec_id from sec_oks) 
  and not exists (select 'x'
		    from goterm_onto 
		    where goterm_onto.goterm_id = goterm_go_id);

select count(*) from 
  goterm_onto, go_term
  where goterm_onto.goterm_id = goterm_go_id ;

select count(*) 
  from goterm_onto
  where not exists (select 'x'
			from go_Term
			where goterm_onto.goterm_id = goterm_go_id) ;

unload to goterm_secondary_and_obsolete.txt
  select goterm_zdb_id, goterm_name, goterm_go_id
    from go_term
    where goterm_is_secondary = 't' 
	and goterm_is_obsolete = 't' ;

--create a table for unload to report 

insert into sec_unload (sec_id, prim_id)
  select sec_id, prim_id
    from sec_oks
    where sec_id in (select "GO:"||goterm_go_id from go_Term) ;

create temp table sec_unload_report 
  (
    sec_id varchar(70),
    prim_id varchar(70),
    term_name varchar(255),
    onto varchar(50),
    go_marker	varchar(70),
    mrkrgo_pub_zdb_id varchar(70)
  );

insert into sec_unload_report
  select 'Now Secondary: GO:'||sec_id, 
	'Now Primary: GO:'||prim_id, 
	'Name: '||goterm_name, 
	'Ontology: '||goterm_ontology,
 	'Gene: '||mrkrgoev_mrkr_zdb_id, 
	'Pub: '||mrkrgoev_source_zdb_id
    from sec_unload, go_term, marker_go_term_Evidence
    where sec_id = "GO:"||goterm_go_id
    and mrkrgoev_term_zdb_id = goterm_zdb_id ;

!echo "count the number of records in sec_unload_report" ;

select count(*) 
  from sec_unload_report;

--deal with reinstated secondary terms

create temp table tmp_not_secondary_any_more (nsec_id varchar(50),
		nsec_goterm_zdb_id varchar(50),
		nsec_goterm_name varchar(255))
with no log ;

insert into tmp_not_secondary_any_more
  select goterm_go_id, goterm_zdb_id, goterm_name
    from go_term
    where not exists (Select 'x'
			from sec_oks
			where sec_id = "GO:"||goterm_go_id)
    and goterm_is_Secondary = 't';

unload to report_not_secondary_any_more.unl
  select * from tmp_not_Secondary_any_more ;

--do the update automatically, then tell doug with an email from loadgo.pl.
update go_term
 set goterm_is_secondary = 'f'
 where exists (select 'x'
		 from tmp_not_secondary_any_more
		 where nsec_goterm_zdb_id = goterm_zdb_id)
 and goterm_is_secondary = 't';

--these two unload files will be picked up by loadgo.pl, the script
--these two unload files will be picked up by loadgo.pl, the script
--running this sql script and sent to Doug H. and informix

unload to 'newannotsecterms.unl' select * from sec_unload_report ;
unload to 'newsecterms.unl' select * from sec_unload ;

--make a temp table that will contain records from ontology.unl 
--(this table will contain
--records that are already in zfindb.go_term at first load).


---This final check is to see if any obsolete or secondary GO terms
---have been added to the "with" field

create temp table obssec_with (
                go_id  varchar(80),
                mrkr_name      varchar(80),
                is_what    varchar(3)
                );

!echo "with obs terms" ;

insert into obssec_with
      select distinct infgrmem_inferred_from, mrkr_name, 'obs' 
      from inference_group_member, go_term, marker, marker_go_term_evidence
      where substr(infgrmem_inferred_from, -7) = goterm_go_id
      and goterm_is_obsolete='t'
      and infgrmem_mrkrgoev_zdb_id=mrkrgoev_zdb_id
      and mrkrgoev_mrkr_zdb_id=mrkr_zdb_id;



insert into obssec_with
      select distinct infgrmem_inferred_from, mrkr_name, 'sec' 
      from inference_group_member, go_term, marker, marker_go_term_evidence
      where substr(infgrmem_inferred_from, -7) = goterm_go_id
      and goterm_is_secondary='t'
      and infgrmem_mrkrgoev_zdb_id=mrkrgoev_zdb_id
      and mrkrgoev_mrkr_zdb_id=mrkr_zdb_id;


unload to obso_sec_with.unl 
	 select distinct "Marker Name: "||mrkr_name,
	 "Go Term: "||go_id,
	 "Flag : "||is_what
	from obssec_with ;

create temp table obssec_phenoentity (
                go_id_a  varchar(80),
                go_id_b  varchar(80),
                geno_id      varchar(80),
                fig_zdb_id      varchar(80),
                is_what    varchar(3)
                );

insert into obssec_phenoentity
      select distinct apato_subterm_zdb_id,apato_superterm_zdb_id, genox_geno_zdb_id,apatofig_fig_zdb_id, 'obs' 
      from atomic_phenotype, go_term, apato_figure, genotype_experiment
      where (apato_subterm_zdb_id = goterm_go_id or apato_superterm_zdb_id=goterm_go_id)
      and apato_genox_zdb_id=genox_zdb_id
      and goterm_is_obsolete='t'
      and apato_zdb_id=apatofig_apato_zdb_id;


insert into obssec_phenoentity
      select distinct apato_subterm_zdb_id,apato_superterm_zdb_id, genox_geno_zdb_id,apatofig_fig_zdb_id, 'sec' 
      from atomic_phenotype, go_term, apato_figure, genotype_experiment
      where (apato_subterm_zdb_id = goterm_go_id or apato_superterm_zdb_id=goterm_go_id)
      and goterm_is_secondary='t'
      and apato_genox_zdb_id=genox_zdb_id
      and apato_zdb_id=apatofig_apato_zdb_id;


unload to obso_sec_phenoentity.unl 
	 select distinct "Genotype ID: "||geno_id,
	 "Figure: "||fig_zdb_id,
	 "Go Term: "||go_id_a,
	 "Go Term: "||go_id_b,
	 "Flag : "||is_what
	from obssec_phenoentity ;

update obo_file
  set (obofile_text, obofile_load_date, obofile_load_process) = (filetoblob("<!--|ROOT_PATH|-->/server_apps/data_transfer/LoadGO/gene_ontology.obo","server"),CURRENT YEAR TO SECOND, "Automated GO Term Load")
  where obofile_name = "gene_ontology.obo" ;

--rollback work;
commit work;

