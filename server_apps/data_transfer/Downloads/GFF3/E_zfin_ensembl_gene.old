-- E_zfin_genes.sql
-- get the set of zfin genes which may be associated with a location on Ensembl
-- via association with Vega transcripts mapped to Ensembl transcripts OR
-- via 1 to 1 mappings of ensdarGs to ZDB-GENE by Ensembl

-- zfin_ensembl_gene table is created by the "create_gff3.sql" script

! echo "Begin ensembl gff3 gene related unloads"
! echo "Requires the Vega assembly to be present"

-- zero it out just in case
truncate table zfin_ensembl_gene;

begin work;

! echo "Isolate ZFIN genes on Ensembl assembly"

select distinct ----------------------- ottdarT <--> ensdarT----------------------
	et.gff_seqname,
	"ZFIN" source,
	case gene.mrkr_type when 'GENEP' then 'pseudogene' else  'gene' end feature,
	min(et.gff_start) gstart,
	max(et.gff_end)   gend,
	"." score ,
	et.gff_strand,
	"." frame,
	'gene_id=' || gene.mrkr_zdb_id ||';Name=' || gene.mrkr_abbrev id_name,
	gene.mrkr_zdb_id alias
 from  marker gene, marker_relationship, gff3 vt, gff3 et, db_link vTdbl, db_link eTdbl
 where gene.mrkr_type[1,4] == 'GENE'
   and mrel_mrkr_1_zdb_id == gene.mrkr_zdb_id
   and vTdbl.dblink_linked_recid == mrel_mrkr_2_zdb_id
   and vTdbl.dblink_acc_num == vt.gff_id
   and vt.gff_source  == 'vega'
   and vt.gff_feature == 'transcript'
   and eTdbl.dblink_fdbcont_zdb_id == 'ZDB-FDBCONT-110301-1' -- Ensembl_Trans
   and eTdbl.dblink_linked_recid == vTdbl.dblink_linked_recid -- ensdarT -> ottdarT
   and eTdbl.dblink_acc_num == et.gff_id
   and et.gff_source[1,8] == 'Ensembl_'
   and et.gff_feature in ('mRNA','transcript')
 group by 1,3,7,9,10

into temp tmp_vega_zeg with no log
;
select ----------------------- ensdarG 1:1---------------------------------
	gff_seqname,
	"ZFIN" source,
	case gene.mrkr_type when 'GENEP' then 'pseudogene' else  'gene' end feature,
	min(gff_start) gstart,
	max(gff_end)  gend,
	"." score,
	gff_strand,
	"." frame,
	'gene_id=' || gene.mrkr_zdb_id || ';Name=' || gene.mrkr_abbrev id_name,
	gene.mrkr_zdb_id alias
 from  marker gene, db_link eGdbl, gff3
 where gene.mrkr_type[1,4] == 'GENE'
   and gene.mrkr_zdb_id == eGdbl.dblink_linked_recid
   and eGdbl.dblink_fdbcont_zdb_id == 'ZDB-FDBCONT-061018-1' -- Ensembl(ZvN) Gene
   and eGdbl.dblink_acc_num == gff_parent
   and gff_source[1,8] == 'Ensembl_'
   and gff_feature in ('mRNA','transcript')
 group by 1,3,7,9,10
 into temp tmp_ensembl_zeg with no log
;

-- the two methods of placing genes
-- can have different (overlapping?) locations
-- some are on different chromosomes
-- keep vegas version

-- first take care of strandedness
--------------------------------------------------------------
! echo "remove strandedness when vega dissagrees with vega (regardless of extents)"
select a.Alias
from  tmp_vega_zeg a, tmp_vega_zeg b
	 where b.gff_seqname ==  a.gff_seqname
	   --and b.gstart      ==  a.gstart
	   --and b.gend        ==  a.gend
	   and b.gff_strand  !=  a.gff_strand
	   and b.Alias       ==  a.Alias
 into temp tmp_strand with no log
;

! echo "Potentially on different strands by ottdarT<->ensdarT"
select distinct * from  tmp_strand order by 1;


update tmp_vega_zeg set gff_strand = '.' where exists (
	select 't' from tmp_strand
	 where  tmp_strand.alias ==  tmp_vega_zeg.alias
);

drop table tmp_strand;

! echo "remove strandedness when ensembl dissagrees with ensembl(regardless of extents)"
select a.Alias[1,25]
 from  tmp_ensembl_zeg a, tmp_ensembl_zeg b
 where b.gff_seqname ==  a.gff_seqname
   --and b.gstart      ==  a.gstart
   --and b.gend        ==  a.gend
   and b.gff_strand  !=  a.gff_strand
   and b.Alias       ==  a.Alias
 into temp tmp_strand with no log
;

update tmp_vega_zeg set gff_strand = '.' where exists (
	select 't' from tmp_strand
	 where  tmp_strand.alias ==  tmp_vega_zeg.alias
);

! echo "Potentially on different strands by 1:1"
select distinct * from  tmp_strand order by 1;

drop table tmp_strand;

! echo "remove strandedness from genes where differ between Vega & ensembl"
update tmp_vega_zeg set gff_strand = '.' where exists (
select 't' from tmp_ensembl_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   --and tmp_ensembl_zeg.gstart      ==  tmp_vega_zeg.gstart
	   --and tmp_ensembl_zeg.gend        ==  tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.gff_strand  !=  tmp_vega_zeg.gff_strand
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);
update tmp_ensembl_zeg set gff_strand = '.' where exists (
select 't' from tmp_vega_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   --and tmp_ensembl_zeg.gstart      ==  tmp_vega_zeg.gstart
	   --and tmp_ensembl_zeg.gend        ==  tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.gff_strand  !=  tmp_vega_zeg.gff_strand
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);
---------------------------------------------------------------
! echo "if vega and ensembl disagree on linkage group go with vega"
delete from tmp_ensembl_zeg where exists(
	select 't' from tmp_vega_zeg
	where tmp_ensembl_zeg.gff_seqname !=  tmp_vega_zeg.gff_seqname
	  and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

---------------------------------------------------------------
! echo "delete what ensembl has in common with vega"
delete from tmp_ensembl_zeg where exists(
	select 't' from tmp_vega_zeg
	where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	  and tmp_ensembl_zeg.gstart      ==  tmp_vega_zeg.gstart
	  and tmp_ensembl_zeg.gend        ==  tmp_vega_zeg.gend
	  and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

! echo "if vega extents for a gene overlap, them megre them"
select * from tmp_vega_zeg into temp tmp_vz with no log;

select tmp_vega_zeg.Alias  from tmp_vz,tmp_vega_zeg
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <=  tmp_vega_zeg.gstart
	   and tmp_vz.gend        >   tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
;

! echo "extend Vegas max to Vegas max when their extents overlap"
update tmp_vega_zeg set gend = (
	select tmp_vz.gend from tmp_vz
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <=  tmp_vega_zeg.gstart
	   and tmp_vz.gend        >   tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
)where exists (
select 't' from tmp_vz
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <=  tmp_vega_zeg.gstart
	   and tmp_vz.gend        >   tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
);

! echo "extend Vegas min to Vegas min when their extents overlap"
select tmp_vz.Alias from tmp_vz, tmp_vega_zeg
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <   tmp_vega_zeg.gstart
	   and tmp_vz.gend        >=  tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
;
update tmp_vega_zeg set gend = (
	select tmp_vz.gend from tmp_vz
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <  tmp_vega_zeg.gstart
	   and tmp_vz.gend        >=   tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
)where exists (
select 't' from tmp_vz
	 where tmp_vz.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_vz.gstart      <   tmp_vega_zeg.gstart
	   and tmp_vz.gend        >=  tmp_vega_zeg.gend
	   and tmp_vz.Alias       ==  tmp_vega_zeg.Alias
);

! echo "what is the least distance between the gene extents on the same chr?"
select distinct  a.Alias,
	(case when abs(a.gstart - b.gend) <= abs(a.gend - b.gstart)
	then abs(a.gstart - b.gend) else abs(a.gend - b.gstart) end) dst

	from tmp_vega_zeg a, tmp_vz b
	 where b.gff_seqname ==  a.gff_seqname
	 and b.Alias       ==  a.Alias
	 and (b.gstart != a.gstart or b.gend != a.gend)
	 order by 2
;

! echo "what gene extents are on different chr?"
select distinct  a.Alias[1,25],a.gff_seqname[1,5] lga ,b.gff_seqname[1,5] lgb
	from tmp_vega_zeg a, tmp_vz b
	 where b.gff_seqname >  a.gff_seqname
	 and b.Alias       ==  a.Alias
	 order by 1,2,3
;

! echo "extend Vega's max to Ensembl's max when their extents overlap"
update tmp_vega_zeg set gend = (
	select tmp_ensembl_zeg.gend from tmp_ensembl_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_ensembl_zeg.gstart      <=  tmp_vega_zeg.gstart
	   and tmp_ensembl_zeg.gend        >   tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
)where exists (
select 't' from tmp_ensembl_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_ensembl_zeg.gstart      <=  tmp_vega_zeg.gstart
	   and tmp_ensembl_zeg.gend        >   tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

! echo "extend Vegas min to Ensembls min when their extents overlap"
update tmp_vega_zeg set gstart = (
	select tmp_ensembl_zeg.gstart from tmp_ensembl_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_ensembl_zeg.gstart      <   tmp_vega_zeg.gstart
	   and tmp_ensembl_zeg.gend        >=  tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
)where exists (
select 't' from tmp_ensembl_zeg
	 where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and tmp_ensembl_zeg.gstart      <   tmp_vega_zeg.gstart
	   and tmp_ensembl_zeg.gend        >=  tmp_vega_zeg.gend
	   and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

! echo "delete those ensembl which overlapped vega"
delete from tmp_ensembl_zeg where exists(
	select 't' from tmp_vega_zeg
	where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	  and tmp_ensembl_zeg.gstart      ==  tmp_vega_zeg.gstart
	  and tmp_ensembl_zeg.gend        ==  tmp_vega_zeg.gend
	  and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

! echo "are there any vega extents outside Ensembl extents? (do not expect many)"
-- but they can occure, at least where we merge adjecent genes
! echo "delete those ensembl contained within vega"
delete from tmp_ensembl_zeg where exists(
	select 't' from tmp_vega_zeg
	where tmp_ensembl_zeg.gff_seqname ==  tmp_vega_zeg.gff_seqname
	   and( tmp_ensembl_zeg.gstart      >  tmp_vega_zeg.gstart
	     or tmp_ensembl_zeg.gend        <  tmp_vega_zeg.gend)
	  and tmp_ensembl_zeg.Alias       ==  tmp_vega_zeg.Alias
);

-------------------------------------------------------------------------------
select distinct * from tmp_vega_zeg into temp tmp_vega_zeg2 with no log;
drop table tmp_vega_zeg;

! echo "does vega have multiple rows for gene?"
select alias talias, count(*) howmany from tmp_vega_zeg2 group by 1 having count(*) >1
into temp tmp_disjoint_vega with no log
;
select * from tmp_disjoint_vega order by 1;

delete from tmp_vega_zeg2 where exists (
	select 't' from tmp_disjoint_vega where alias == talias
);

drop table tmp_disjoint_vega;

! echo "does ensembl have multiple rows for ZFIN genes?"
select alias talias, count(*) howmany from tmp_ensembl_zeg
 group by 1 having count(*) >1
into temp tmp_disjoint_ensembl with no log;

select * from tmp_disjoint_ensembl order by 1;

delete from tmp_ensembl_zeg where exists (
	select 't' from tmp_disjoint_ensembl where alias == talias
);

drop table tmp_disjoint_ensembl;


! echo "Do vega and ensembl have any zfin genes in common?"
select count(*) howmany
 from tmp_ensembl_zeg, tmp_vega_zeg2
 where tmp_ensembl_zeg.alias == tmp_vega_zeg2.alias
;

! echo "howmany from Vega transcript mapping?"
select count(*) vega_mapping from tmp_vega_zeg2;

! echo "howmany from Ensembl 1:1?"
select count(*) Ens_1to1 from tmp_ensembl_zeg;

! echo "Save both zfin gene placement collections"
insert into zfin_ensembl_gene (
    zeg_seqname,
    zeg_source,
    zeg_feature,
    zeg_start,
    zeg_end,
    zeg_score,
    zeg_strand,
    zeg_frame,
    zeg_ID_Name,
    zeg_Alias
)
select
    gff_seqname,
    source,
    trim(feature),
    min(gstart) gstart,
    max(gend) gend,
    score,
    gff_strand,
    frame,
    ID_Name,
    Alias
 from tmp_vega_zeg2
 group by
    gff_seqname,
    source,
    feature,
    score,
    gff_strand,
    frame,
    ID_Name,
    Alias
;

insert into zfin_ensembl_gene (
    zeg_seqname,
    zeg_source,
    zeg_feature,
    zeg_start,
    zeg_end,
    zeg_score,
    zeg_strand,
    zeg_frame,
    zeg_ID_Name,
    zeg_Alias
)
select
    gff_seqname,
    source,
    trim(feature),
    min(gstart) gstart,
    max(gend) gend,
    score,
    gff_strand,
    frame,
    ID_Name,
    Alias
 from tmp_ensembl_zeg
 group by
    gff_seqname,
    source,
    feature,
    score,
    gff_strand,
    frame,
    ID_Name,
    Alias
;

-- what do the extents look like
! echo " ------------------- EXTENT in kb  ------------------------------"
{
select dbsname, tabname, round (sum (pe_size ) * 4 )ext_size
 from sysmaster:systabnames, sysmaster:sysptnext
 where partnum == pe_partnum
   and dbsname == 'xraydb'
   and tabname == 'zfin_ensembl_gene'
group by 1, 2
;
}

! echo " ----------------------------------------------------------------"

drop table tmp_vega_zeg2;
drop table tmp_ensembl_zeg;

update statistics high for table zfin_ensembl_gene;



-- unload genes,alias,antibody,pheno,xpat,...

