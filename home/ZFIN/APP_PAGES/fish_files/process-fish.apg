<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>

<TITLE>-</TITLE>

  </head>


<?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpageheader.apg';">$1<?/MISQL>



<!-- This script handles the all actions that arise from processing a new fish
  -- entry. Specifically, two things can happen:
  -- 1) User can ask to specify some parameter like "discoverer" or "mother". 
  --    This should bring up a browser/selector for that particular data type. 
  --    After browsing, it should  lead back to the submission form so user can
  --    continue submitting.
  -- 2) User can hit the "final" submit button, indicating he is done 
  --    specifying new entry. This should result in creating a new FISH 
  --    record (and possible CHROMOSOOME and ALTERATION records) to hold the 
  --    new mutant data.
  -->


<!-- First thing to ALWAYS do is to store all available values in the 
  -- temp_oid record in the TEMP_FISH table. This is how we maintain state.
  -->
<?MISQL SQL="
  select WebExplode(object,'') 
    from webPages 
    where ID='aa-update-fish.apg';">
<?/MISQL>

<!-- OK, NOW DECIDE WHICH SUBMIT BUTTON WAS PUSHED FROM NEW-FISH -->



<!-- FIRST, if they did a "final" submit, do a bunch of processing to create 
  -- the correct permanent records from the TEMP-FISH info, and then 
  -- report success 
  -->

<?MIBLOCK COND=$(XST,$s_done)>

  <?MIVAR COND="$(NXST,$line_type)" NAME=$line_type>mutant<?/MIVAR>
  <?MIVAR COND="$(NXST,$flag)" NAME=$flag>NULL<?/MIVAR>

  <!-- To create ID for new fish, just modify TEMP_OID, replacing 'TEMP' 
    -- with 'FISH'. 
    -->
  <?MIVAR NAME=$fish_id>$(REPLACE,$temp_oid,TEMP,FISH)<?/MIVAR>
  <?MISQL SQL="
    insert into zdb_active_data
      values ('$fish_id');">
  <?/MISQL>

  <!-- First deal with mutants; wild type submission comes later -->
  <?MIBLOCK COND="$(EC,$line_type,mutant)">

    <!-- First handle the "new  mutant by mutagenesis case". Will need to 
      -- build a new FISH, CHROMOSOME, and ALTERATION record and fill with 
      -- right data, then adjust all intersection tables appropriately. 
      -->
    <?MIBLOCK COND="$(=,$(POSITION,$flag,by_breeding),0)">

      <?MISQL SQL="execute function get_id('CHROMO');"><?/MISQL>
      <?MIVAR NAME=$chromo_id>$1<?/MIVAR>
      <?MISQL SQL="execute function get_id('ALT');"><?/MISQL>
      <?MIVAR NAME=$alt_id>$1<?/MIVAR>

      <?MISQL SQL="
        insert into fish 
           (zdb_id, name, abbrev, line_type, mother, father, 
            discoverer, lab, phenotype, orig_crossnum, segregation,
            submitter_id, owner, comments, entry_time, allele, locus,
	    fish_extinct) 
          select '$fish_id', name, abbrev, line_type, mother, father, 
                 discoverer, lab, phenotype, orig_crossnum, segregation,
                 '$submitter_id', '$submitter_id', comments, current,
                 allele, locus, fish_extinct 
            from temp_fish 
            where zdb_id='$temp_oid';">
      <?/MISQL>

      <?MISQL SQL="
        insert into chromosome 
           (zdb_id, name, abbrev, chrom_num, lab) 
          select '$chromo_id', name, abbrev, chrom_num, lab 
            from temp_fish 
            where zdb_id='$temp_oid';">
      <?/MISQL>
      <!-- Build/Insert a printable name,ie,abbrev plus allele in superscript.
        -->
      <?MISQL COND="$(AND,$(XST,$allele),$(XST,$abbrev))" SQL="
        update chromosome 
          set print_name='$abbrev<sup>$allele</sup>' 
          where zdb_id='$chromo_id';">
      <?/MISQL>

      <?MIVAR COND="$(NXST,$chrom_num)" NAME=$chrom_num>NULL<?/MIVAR>
      <?MISQL SQL="
        insert into int_fish_chromo 
           (source_id, target_id, info,status) 
          values ('$fish_id','$chromo_id','$chrom_num','original');">
      <?/MISQL>

      <?MISQL SQL="
        insert into zdb_active_data
            ( zactvd_zdb_id )
          values 
	    ( '$alt_id' );">
      <?/MISQL>
      <?MISQL SQL="
        insert into alteration 
           (zdb_id, allele, mutagen, protocol, chrom_change, locus, chrom_id )
          select '$alt_id', allele, mutagen, protocol, chrom_change, locus,
		 '$chromo_id'
            from temp_fish 
            where zdb_id='$temp_oid';">
      <?/MISQL>

      <!-- Associate all of temp_oid's pubs with new chromos and alts. 
        -- The new fish is similarly dealt with below. 
	-->
      <?MISQL SQL="
	insert into record_attribution
            (recattrib_data_zdb_id, recattrib_source_zdb_id)
          select '$chromo_id', recattrib_source_zdb_id
	    from record_attribution
	    where recattrib_data_zdb_id = '$temp_oid';">
      <?/MISQL>
      <?MISQL SQL="
	insert into record_attribution
	    (recattrib_data_zdb_id, recattrib_source_zdb_id)
	  select '$alt_id', recattrib_source_zdb_id
	    from record_attribution
	    where recattrib_data_zdb_id = '$temp_oid';">
      <?/MISQL>
    <?/MIBLOCK>  <!-- ends the mutagenesis case -->



    <!-- NOW HANDLE the case where mutant generated by cross-breeding mutant 
      -- lines. Here, you just get the CHROMO records from the parents and 
      -- attach them to the new FISH record. All the alterations in the 
      -- parents are thus automatically brought along. 
      -->
    <?MIBLOCK COND="$(>,$(POSITION,$flag,by_breeding),0)">

      <!-- Make the new FISH -->
      <?MISQL SQL="
        insert into fish 
           (zdb_id, name, abbrev, line_type, mother, father, 
            discoverer, lab, phenotype, orig_crossnum, segregation,
            submitter_id, owner, comments, fish_extinct)
          select '$fish_id', name, abbrev, line_type, mother, father, 
                 discoverer, lab, phenotype, orig_crossnum, segregation,
                 '$submitter_id', '$submitter_id', comments, fish_extinct
            from temp_fish 
            where zdb_id='$temp_oid';">
      <?/MISQL>

    <?/MIBLOCK>  <!-- ends by_breeding -->



    <!-- NOW do some maintainance applicable to both mutagenizing and 
      -- by-breeding cases
      -->

    <!-- First, link all chromo recs inherited from parents to new FISH. -->
    <?MISQL SQL="
      select mother, father 
        from temp_fish 
        where zdb_id='$temp_oid';">
    <?/MISQL>
    <?MIVAR NAME=$mother>$1<?/MIVAR>
    <?MIVAR NAME=$father>$2<?/MIVAR>
    <?MISQL SQL="
      insert into int_fish_chromo 
          (source_id, target_id, info, status) 
        select  distinct '$fish_id', target_id, info, 'inherited'
          from int_fish_chromo
          where source_id = '$mother' 
	     or source_id='$father';"> 
    <?/MISQL>

    <!-- build an abbrev for the new fish by concatting the abbrevs from all
      -- chromos it is associated with 
      -->
    <?MIVAR NAME=$print_name><?/MIVAR>
    <?MISQL SQL="
      select b.print_name 
        from int_fish_chromo a, chromosome b 
        where source_id='$fish_id' 
          and b.zdb_id=target_id;">
      $(SETVAR,$print_name,$1" "$print_name)
    <?/MISQL>
    <?MIVAR NAME=$print_name>$(REPLACE,$(TRIM,$print_name)," ",";")<?/MIVAR>
    <?MISQL SQL="
      update fish 
        set abbrev='$print_name' 
        where zdb_id='$fish_id';">
    <?/MISQL>

    <!-- NOW deal with the weird case where you have two mutant alleles that 
      -- fall on the same chromo --- in which case you now have TWO chromo 
      -- records for same chromo (one describing each allele) associated with 
      -- the new FISH. Essentially need to merge two chromos into a new one. 
      -- We call outside function; see func. docs for details. 
      -->

    <!-- However, this hasn't worked since 2000/03, and maybe not even before
      -- that.  Comment it out now (2001/04) and fix it later when we clean up 
      -- the mutant tables.

      < MISQL SQL="
        execute function sysexec('ChromoUpdate', '$fish_id');">
      < /MISQL>
      < MIVAR NAME=$ChromoUpdate>$1< /MIVAR>

      -->

  <?/MIBLOCK>  <!-- ends if it's a mutant -->



  <!-- If it was a wild_type, do a much more limited insert, where you 
    -- just insewrt the  few relevant fields from the temp_fish record. 
    -->
  <?MIBLOCK COND="$(NC,$line_type,mutant)">

    <!-- Make the new FISH -->
    <?MISQL SQL="
      insert into fish 
         (zdb_id, name, abbrev, line_type, discoverer, lab, phenotype,
          submitter_id, owner, comments, orig_crossnum, fish_extinct) 
        select '$fish_id', name, abbrev, line_type, discoverer, lab, phenotype,
	       '$submitter_id', '$submitter_id', comments, orig_crossnum, 
	       fish_extinct
          from temp_fish 
          where zdb_id='$temp_oid';">
    <?/MISQL>

  <?/MIBLOCK>  <!-- ends if wild_type -->


  <!-- Now a few things that apply to about any fish. Change all references 
    -- to the temp_fish record to point to the new fish_id. 
    -->

  <?MISQL SQL="
    update record_attribution
      set recattrib_data_zdb_id = '$fish_id'
      where recattrib_data_zdb_id = '$temp_oid';">
  <?/MISQL>
  <?MISQL COND="$(EC,$line_type,mutant)" SQL="
    update fish_image 
      set fimg_fish_zdb_id = '$fish_id'
      where fimg_fish_zdb_id = '$temp_oid';">
  <?/MISQL>
  <?MISQL SQL="
    update int_data_supplier
      set idsup_data_zdb_id = '$fish_id'
      where idsup_data_zdb_id ='$temp_oid';">
  <?/MISQL>
  <?MICOMMENT>
    Would like to call regen_names_fish() here, but can't because that results
    in a -675 error.
  <?/MICOMMENT>

  <!-- OKAY! Now we're done processing submission, and just need to continue 
    -- on.  Grab the return record (might be NULL) so we can know where to 
    -- go back to 
    -->

  <?MISQL SQL="
    select return_rec 
      from temp_fish 
        where zdb_id='$temp_oid';">
  <?/MISQL>
  <?MIVAR NAME=$return_rec>$1<?/MIVAR>

  <!-- NOW just report success, and allow user to continue -->
  <HTML>
  <h1 align=center>Notification</h1>
  <center>
    <big>Your submission was successful, the new record you submitted 
    has been added to the database. </big>
  </center>
  <p>

  <!-- NOW IF the new FISH was initiated from some other page,ie, has a 
    -- non-NULL return_rec field, give the user the option of returning to 
    -- that process now. Basically, we just return the return record and 
    -- the OID of the newly created record to do-select for processing. 
    -- It's up to do-select to read the return_rec and do the right thing. 
    -->

  <?MIVAR COND=$(NC,$return_rec,NULL)>
    <BIG><FONT COLOR="#ff0000">PLEASE RECALL</FONT></BIG> that you were 
    in the middle of creating or modifying some other record when you 
    took time out to enter this new FISH record.<br>
    Click <A HREF="/cgi-bin/webdriver?MIval=aa-do-select.apg&return_rec=$return_rec&new_oid=$fish_id">here</A> 
    to return to your work in progress!
    <p>
  <?/MIVAR>

  <?MIVAR>
    Click <A HREF="/cgi-bin/webdriver?MIval=aa-fishview.apg&OID=$fish_id">here</A> 
    to view the new FISH record.
  <?/MIVAR>
  <p>
  Click <A HREF="/cgi-bin/webdriver?MIval=aa-ZDB_home.apg">here</A> 
  to return to the ZDB home page.

  </HTML>

  <!-- FINALLY, delete the temp_fish record -->
  <?MISQL SQL="
    delete from zdb_active_data
      where zactvd_zdb_id = '$temp_oid';">
  <?/MISQL>


<?/MIBLOCK> <!-- ends the cond s_done -->






<!-- OKAY, now handle the cases where user wants to specify some value -->
<?MIBLOCK COND="$(NXST,$s_done)">

  <?MIVAR NAME=$file_name>/ZFIN/misc_html/error.html<?/MIVAR>


  <!-- ALL the work of setting up the return_rec for transfer of control 
    -- to a record selector or new record creator is handled by 
    -- PROCESS-FISH-AUX.html
    -->
  <?MISQL SQL="
    select WebExplode(object,'') 
      from webPages
      where ID='aa-process-fish-aux.apg';">
    $1
  <?/MISQL>


  <!-- YOU ARE SELECTING a record, fire off the appropriate browser 
    -- frameset 
    --
    -- LAUNCHES THE FRAMES FOR THE ANY SELECTION BROWSER.
    -->
  <?MISQL SQL="
    select WebExplode(object,'') 
      from webPages 
      where ID='aa-start_select.apg';">
    $1
  <?/MISQL>

  <!-- NEW CODE FOR ONE FRAME ENVIRONMENT.  OPEN THE SELECT PAGE. -->





<?/MIBLOCK> <!-- end "other variables" submission handler" -->




<?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpagefooter.apg';">$1<?/MISQL>


