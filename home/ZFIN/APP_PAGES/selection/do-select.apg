<?MIERROR>
  <?MIVAR COND=$(XST,$MI_SQL)>
    SQL: $MI_SQL<br><br>
  <?/MIVAR>

  Code:    $MI_ERRORCODE <br>
  State:   $MI_ERRORSTATE <br>
  Message: $MI_ERRORMSG <br>
<?/MIERROR>
<?MICOMMENT>
FILE: DO-SELECT.  
This file processes a record that was either SELECTED or CREATED 
by the user. That is, user was processing some other record, and 
bailed out of that to select or created some other new record.  
At this point,it doesn't matter which is the case. 

What we do care about is what to do with the selected/created record. 
There are four possibilities:
1) Do nothing. Just go back to previous page specified in return_rec.
2) Stick the created/selected record into a field in the calling record.
3) Stick the id of the calling parent record into a field in the newly 
   created record.
4) Associate calling record and newly created record in an intersection table.

To decide what to do, DO-SELECT looks at the ACTION field of the 
return_rec passed in with the newly selected/created record (stored 
in $new_oid). Specifically:

-- IF ACTION="nothing". Do nothing, Just jump back to calling form.

-- If ACTION="return_id". It should store the id of the new record 
   ($new_oid) in the FILL_FIELD of FILL_TABLE (where FILL_TABLE 
   presumbly corresponds to the calling class).

-- IF ACTION="index_me". It should store the calling records id 
   (from $return_rec) in the FILL_FIELD of FILL_TABLE (where fill table 
   will presumably corresponds to the class of the created/selected record). 
   So new record gets indexed by calling record's id.

-- ACTION="intersect". Means we want to associated new_oid with the 
   previous record (RETURN_RECID) in an intersection table which is 
   named in FILL_TABLE. We also stick the INFO variable into the info 
   column of the intersection table. There is also a 'r_intersect' 
   option, where we just reverse the source/target id values as we 
   stick in the intersection record. 

-- ACTION="r_intersect". Just like intersect, except reverse source_id, 
   target_id 

-- ACTION="special-<something>" -- Do something unique with the selected 
   record. Used for special cases. See comments on each for details.


FINALLY, if this selection was made while updating an existing record, 
we will want to write it to the update log 
<?/MICOMMENT>

<!-- Extract the goodies from the return rec -->
<?MISQL SQL="
  select return_form, return_recid, fill_field, fill_table, info, action, 
         jump_to, rec_update
    from return_recs 
    where zdb_id='$return_rec';">
<?/MISQL>
<?MIVAR NAME=$return_form>$1<?/MIVAR>
<?MIVAR NAME=$return_recid>$2<?/MIVAR>
<?MIVAR NAME=$fill_field>$3<?/MIVAR>
<?MIVAR NAME=$fill_table>$4<?/MIVAR>
<?MIVAR NAME=$jump_to>$7<?/MIVAR>
<?MIVAR NAME=$action>$6<?/MIVAR>
<?MIVAR NAME=$info>$5<?/MIVAR>
<?MIVAR NAME=$rec_update>$8<?/MIVAR>

<!-- First call secure_navigate. Only reason is to set ZDB_ident and 
     ZDB_name to use in recording updates, so only call it if updating! -->
<?MISQL COND="$(EC,$rec_update,t)" SQL="
  select WebExplode(object,'')
    from webPages
    where ID='aa-secure_navigation.apg';">
$1
<?/MISQL>

<?MICOMMENT>
  For most tables, the owner and ZDB_ID columns are "owner" and "zdb_id".
  However, there are exceptions.  Handle them.
<?/MICOMMENT>
<?MIVAR NAME=$ownerColumn>owner<?/MIVAR>
<?MIVAR NAME=$zdbIdColumn>zdb_id<?/MIVAR>
<?MIBLOCK COND="$(EC,$fill_table,marker)">
  <?MIVAR NAME=$ownerColumn>mrkr_owner<?/MIVAR>
  <?MIVAR NAME=$zdbIdColumn>mrkr_zdb_id<?/MIVAR>
<?MIELSE COND="$(EC,$fill_table,image)">
  <?MIVAR NAME=$ownerColumn>img_owner_zdb_id<?/MIVAR>
  <?MIVAR NAME=$zdbIdColumn>img_zdb_id<?/MIVAR>
<?/MIBLOCK>

<?MICOMMENT>===================================================================
        ===        ACTION=intersect 
        === fill_table is intersection table. So put 
        === new record into table with the recid passed in through return_recid. 
        ========================================================================
<?/MICOMMENT>

<?MIBLOCK COND="$(EQ,$action,intersect)">
  <?MIBLOCK COND="$(EC,$fill_table,record_attribution)">
    <!-- Doing a record level attribution. First, delete duplicates -->
    <?MISQL SQL="
      delete from record_attribution
	where recattrib_data_zdb_id = '$return_recid'
	  and recattrib_source_zdb_id = '$new_oid';">
    <?/MISQL>

    <!-- Now guard against conflicting "primary" publications for 
         single data record. -->
    <?MISQL COND="$(EC,$info,primary)" SQL="
      delete from record_attribution
        where recattrib_data_zdb_id = '$return_recid'
         ;">
    <?/MISQL>

    <!-- Insert new attribution record. -->
    <?MISQL SQL="
      insert into record_attribution
	  ( recattrib_data_zdb_id, recattrib_source_zdb_id 
	   )
	values
	  ( '$return_recid', '$new_oid');">
    <?/MISQL>
  <?MIELSE COND="$(EC,$fill_table,int_data_supplier)">
    <?MISQL SQL="
      insert into int_data_supplier
	  ( idsup_data_zdb_id, idsup_supplier_zdb_id )
	values
	  ( '$return_recid', '$new_oid' );">
    <?/MISQL>
  <?MIELSE>
    <!-- creating an intersection record. -->
    <!-- FIRST delete duplicates. -->
    <?MISQL SQL="
      delete from $fill_table
        where source_id = '$return_recid'
	  and target_id = '$new_oid';">
    <?/MISQL>

    <!-- create new intersection entry -->
    <?MISQL SQL="
      insert into $fill_table 
          ( source_id, target_id, info ) 
        values 
          ( '$return_recid', '$new_oid', '$info');">
    <?/MISQL>
  <?/MIBLOCK>

  <!-- Record update is the rec_update flag is set -->
  <?MISQL COND="$(EC,$rec_update,t)" SQL="
    insert into updates 
        ( submitter_name, submitter_id, when, rec_id, field_name, old_value,
	  new_value, comments )
      values 
	( '$ZDB_name', '$ZDB_ident', current, '$return_recid', '$fill_table',
	  'Not available', '$new_oid', 
	  'Added $new_oid to list of records associated with data record $return_recid');">
  <?/MISQL>
<?/MIBLOCK><?MICOMMENT> ======== end ACTION = intersect ======<?/MICOMMENT>




<?MICOMMENT>===================================================================
        ===        ACTION=r_intersect 
        === fill_table is intersection table. 
        === However, the entries should be reversed, with the selected record 
        === (new_oid) going into the 'source' field rather than the 'target' 
        === field of the new intersection record. At this time, this only 
        === happens when adding people to int_person_lab from the new_lab form.
        ========================================================================
<?/MICOMMENT>

<?MIBLOCK COND="$(EC,$action,r_intersect)">
 
  <?MIBLOCK COND="$(EC,$fill_table,int_data_source)">

  <!-- FIRST delete duplicates. Don't want redundant links -->
  <?MISQL SQL="
    delete from $fill_table 
      where ids_data_zdb_id = '$return_recid'
        and ids_source_zdb_id = '$new_oid';">
  <?/MISQL>

  <!-- Then just jam in new intersection entry -->
  <?MISQL SQL="
    insert into $fill_table
	( ids_source_zdb_id, ids_data_zdb_id) 
      values 
	( '$new_oid', '$return_recid');">
  <?/MISQL>

  <?MIELSE>
  <!-- FIRST delete duplicates. Don't want redundant links -->
  <?MISQL SQL="
    delete from $fill_table 
      where target_id = '$return_recid'
        and source_id = '$new_oid';">
  <?/MISQL>

  <!-- Then just jam in new intersection entry -->
  <?MISQL SQL="
    insert into $fill_table
	( source_id, target_id, position) 
      values 
	( '$new_oid', '$return_recid', '$info');">
  <?/MISQL>

  <!-- Record update is the rec_update flag is set -->
  <?MISQL COND="$(EC,$rec_update,t)" SQL="
    insert into updates 
	( submitter_name, submitter_id, when, rec_id, field_name, old_value,
	  new_value, comments) 
      values 
	( '$ZDB_name', '$ZDB_ident', current, '$return_recid', '$fill_table',
	  'Not available', '$new_oid', 
	  'Added $return_recid to list of records associated with data record $new_oid');">
  <?/MISQL>
  <?/MIBLOCK> <!-- end if fill_table int_data_source -->

<?/MIBLOCK><?MICOMMENT> ======== end ACTION = r_intersect ======<?/MICOMMENT>




<!-- If ACTION=return_id, then we want to stick the oid of the new 
     object directly into the field specified by fill_field of 
     fill_table (which presumbly represents calling class). So OID 
     of created/selected record stored in calling class.
-->
<?MIBLOCK COND="$(EQ,$action,return_id)">
  <?MISQL SQL="
    update $fill_table 
      set $fill_field = '$new_oid' 
      where $zdbIdColumn ='$return_recid';">
  <?/MISQL>

  <!-- if a contact_person for a lab or company is specified - owner must 
    -- be set to the same value -->
  <?MIBLOCK COND="$(AND,$(EQ,$action,return_id),$(EQ,$fill_field,contact_person))">
    <?MISQL SQL="
      update $fill_table 
        set $ownerColumn = '$new_oid' 
        where $zdbIdColumn = '$return_recid';">
    <?/MISQL>
  <?/MIBLOCK>

  <!-- Record update if the rec_update flag is set. -->
  <?MISQL COND="$(EC,$rec_update,t)" SQL="
    insert into updates 
        (submitter_name, submitter_id, when, rec_id, field_name, old_value,
	 new_value, comments) 
      values 
	('$ZDB_name', '$ZDB_ident', current, '$return_recid', '$fill_field',
	 'Not available', '$new_oid', 'Selected replacement value');">
  <?/MISQL>

<?/MIBLOCK>



<!-- If ACTION=index_me, then we want to stick the oid of the calling 
     object into the newly created record. That way the new object is 
     indexed by the calling bject. So we stick $return_recid into the 
     fill_field of the fill_table under the entry for new_oid. -->
<?MIBLOCK COND="$(EQ,$action,index_me)">
  <?MISQL SQL="
    update $fill_table 
      set $fill_field = '$return_recid' 
      where $zdbIdColumn = '$new_oid';">
  <?/MISQL>

  <!-- Record update is the rec_update flag is set -->
  <?MISQL COND="$(EC,$rec_update,t)" SQL="
    insert into updates 
        (submitter_name, submitter_id, when, rec_id, field_name, old_value, 
	 new_value, comments) 
      values 
        ('$ZDB_name', '$ZDB_ident', current, '$new_oid', '$fill_field',
	 'Not available', '$return_recid', 'Selected indexing');">
  <?/MISQL>
<?/MIBLOCK>


<!-- OKAY, NOW DEAL WITH SPECIAL PURPOSE ACTIONS ASSOCIATED ONLY WITH FISH UPDATES -->


<!-- If ACTION=special_parent, then user has asked to update/change 
     one of the parents of a mutant strain. This is trivial if 
     previous value was "UNKNOWN" (NULL) or was a wild-type line since 
     there are no inherited mutations to deal with. On other hand, if 
     it was a mutant, we have to 
     (1) delete old inherited chromos from int_fish_chromo, 
     (2) re-install newly inherited chromos and 
     (3) run Ted's chromo overlap checking routine. 
     The installation steps can mirror what happened in process-chromo 
     during new fish creation. FINALLY, need to write an update record.
     Note that the opening conditional also ensures that you don't 
     specify a fish as its own parental line! 
-->
<?MIBLOCK COND="$(AND,$(EC,$action,special_parent),$(NC,$return_recid,$new_oid))">
  <!-- first get previous parent, and check if was mutant -->
  <?MISQL SQL="
    select $fill_field 
      from fish 
      where zdb_id = '$return_recid';">
  <?/MISQL>
  <?MIVAR NAME=$old_parent>$1<?/MIVAR>
  <?MISQL SQL="
    select count(*)::integer
      from fish 
      where zdb_id = '$old_parent'
        and line_type='mutant';">
  <?/MISQL>
  <?MIVAR NAME=$dosel_old_parent_count>$1<?/MIVAR>

  <?MICOMMENT>Prepare for temp table creation or use<?/MICOMMENT>
  <?MISQL SQL="
    select dbinfo('sessionid') 
      from single;">
    <?MIVAR NAME=$dosel_session_id>$1<?/MIVAR>
    <?MIVAR NAME=$do_select_temp_delete>$(CONCAT,do_select_temp_delete_,$dosel_session_id)<?/MIVAR>
    <?MIVAR NAME=$do_select_temp_insert>$(CONCAT,do_select_temp_insert_,$dosel_session_id)<?/MIVAR>
  <?/MISQL>

  <?MICOMMENT>
       okay, if you got any hits, the  parent is non-null and mutant. 
       So do special stuff to wipe out previous  inherited info: delete 
       chromo intersection
  <?/MICOMMENT>
  <?MISQL SQL="
    execute function table_exists('$do_select_temp_delete')">
    <?MISQL COND=$(EC,$1,f) SQL="
      create temp table $do_select_temp_delete (
	  doseldel_zdb_id   varchar(50)
      ) with NO LOG;">
    <?/MISQL>
  <?/MISQL>
  <?MIBLOCK COND="$(>,$dosel_old_parent_count,0)">
    <?MISQL SQL="
      insert into $do_select_temp_delete
        select target_id 
	  from int_fish_chromo 
	  where source_id = '$old_parent';">
    <?/MISQL>
    <?MISQL SQL="
      delete from int_fish_chromo 
        where source_id = '$return_recid'
	  and target_id in 
	        ( select doseldel_zdb_id
		    from $do_select_temp_delete);">
    <?/MISQL>
    <?MISQL SQL="
      delete from $do_select_temp_delete;">
    <?/MISQL>
  <?/MIBLOCK> <!-- ends if old parent was mutant -->

  <?MICOMMENT>
    Guard against duplications,ie, if other parent is same line.
    Create or empty temp table.
  <?/MICOMMENT>
  <?MISQL SQL="
    insert into $do_select_temp_delete
      select target_id 
        from int_fish_chromo 
        where source_id = '$new_oid';">
  <?/MISQL>
  <?MISQL SQL="
    delete from int_fish_chromo 
      where source_id = '$return_recid'
	and target_id in 
	      ( select doseldel_zdb_id
		  from $do_select_temp_delete);">
  <?/MISQL>
  <?MISQL SQL="
    delete from $do_select_temp_delete;">
  <?/MISQL>

  <?MICOMMENT>Now install new parent. This is stolen from process-fish<?/MICOMMENT>
  <?MISQL SQL="
    execute function table_exists('$do_select_temp_insert')">
    <?MISQL COND=$(EC,$1,f) SQL="
      create temp table $do_select_temp_insert (
	  doselins_source_zdb_id   varchar(50),
	  doselins_target_zdb_id   varchar(50),
	  doselins_info            varchar(50),
	  doselins_status          varchar(20)
      ) with NO LOG;">
    <?/MISQL>
  <?/MISQL>
  <?MISQL SQL="
    insert into $do_select_temp_insert
      select  '$return_recid', target_id, info, 'inherited'
        from int_fish_chromo
        where source_id = '$new_oid';">
  <?/MISQL>
  <?MISQL SQL="
    insert into int_fish_chromo 
	(source_id, target_id, info, status) 
      select * 
	from $do_select_temp_insert;">
  <?/MISQL>
  <?MISQL SQL="
    delete from $do_select_temp_insert;">
  <?/MISQL>

  <!-- Now just change the fish record and write update record -->
  <?MISQL SQL="
    update fish 
      set $fill_field = '$new_oid' 
      where zdb_id = '$return_recid';">
  <?/MISQL>
  <?MISQL COND="$(EC,$rec_update,t)" SQL="
    insert into updates 
	(submitter_name, submitter_id, when, rec_id, field_name, old_value,
	 new_value, comments) 
      values 
	('$ZDB_name', '$ZDB_ident', current, '$return_recid', '$fill_field',
	 '$old_parent', '$new_oid', 'Changed parental lineage');">
  <?/MISQL>
<?/MIBLOCK>  <!-- ends action=special parent-->

<!-- If ACTION=insert_marker, then user has asked to add a missing/present 
     marker for a deletion mutant.  A 't' in the info field indicates that 
     a marker is present, an 'f' that a marker is missing.  Records are 
     inserted into the mapped_deletion table. -->
<?MIBLOCK COND="$(EC,$action,insert_marker)">

  <!-- first get the allele and linkage group  -->
  <?MISQL SQL="
    select feature_name, lnkg_or_lg
      from linkage_member, linkage, feature
     where lnkgmem_member_zdb_id = '$return_recid'
       and lnkgmem_linkage_zdb_id = lnkg_zdb_id
       and lnkgmem_member_zdb_id = feature_zdb_id;"> 

    <?MIVAR name=$allele_name>$1<?/MIVAR>
    <?MIVAR name=$lg>$2<?/MIVAR>
  <?/MISQL>

  <?MISQL SQL="
    execute function get_id('MAPDEL');">
  <?/MISQL>
  <?MIVAR NAME=$doselect_mapdel_zdb_id>$1<?/MIVAR>
  <?MISQL SQL="
    insert into zdb_active_data (zactvd_zdb_id)
      values
        ('$doselect_mapdel_zdb_id');">
    <?/MISQL>
  <?MISQL SQL="
    insert into mapped_deletion 
	(marker_id, present_t, submitter,  OR_lg, allele, mapdel_zdb_id)
      values 
	('$new_oid', '$info', '$ZDB_ident', '$lg', '$allele_name',
	 '$doselect_mapdel_zdb_id');">
  <?/MISQL>

<?/MIBLOCK>  


<!-- Check for errors and report -->
<?MIBLOCK COND="$(OR,$(EQ,$action,NULL),$(EQ,$action,NoValue))">
  <h1>Bad return rec! Error reported at do-select</h1>
<?/MIBLOCK>

<!-- Now just blast the used up return_rec and send control back to 
     the previous form in progress. Note the use of Javascript to 
     replace current page with a new one; should avoid weird holes 
     in the history list. Cool!!-->
<?MISQL SQL="
  delete from return_recs 
    where zdb_id = '$return_rec';">
<?/MISQL>

<?MIVAR>
  <SCRIPT>
    location.replace('/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=$return_form&temp_oid=$return_recid#$jump_to')
  </SCRIPT>
<?/MIVAR>







