<?MICOMMENT>
FILE:   msegselect.apg
PREFIX: msegsel_

<?/MICOMMENT>

<?MIERROR>
  <?MIVAR COND=$(XST,$MI_SQL)>
    SQL: $MI_SQL<br><br>
  <?/MIVAR>

  Code:    $MI_ERRORCODE <br>
  State:   $MI_ERRORSTATE <br>
  Message: $MI_ERRORMSG <br>
<?/MIERROR>	

 
<?MIBLOCK COND="$(NXST,$accession)">
 <HTML>
 <HEAD>
  <?MIVAR Name=page_name>$(IF,$(XST,$query_results),ZFIN Molecular Segment Search Results,ZFIN Search Molecular Segments)<?/MIVAR>
  <?MIVAR><TITLE>$page_name</TITLE><?/MIVAR>


  <SCRIPT>

    function call_reset() {

	document.critform.input_name.value = "";
	document.critform.input_acc.value = "";
	document.critform.START.value = "";
	document.critform.lg.selectedIndex = 0;
	document.critform.compare.selectedIndex = 0;
	document.critform.marker_type.selectedIndex = 0;
        document.critform.sequence_type.selectedIndex = 0;
	document.critform.vector_type.selectedIndex = 0;
	document.critform.WINSIZE.value = 20;

     }
   </SCRIPT>


 <?MIVAR NAME=$OID COND="$(NXST,$OID)">NULL<?/MIVAR>

 <?MISQL SQL="
  select object 
    from webPages 
    where ID = 'aa-chromoscripts.apg';">
  $1
 <?/MISQL>

 </HEAD>
 
 <BODY>
	
  <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpageheader.apg';">$1<?/MISQL>


<?/MIBLOCK><!-- end XST accession which means it is called by Accession Search --> 

 <?MIVAR name=$highlight><!--|HIGHLIGHT_COLOR|--><?/MIVAR>
 <?MIVAR name=$MI_NOVALUE><?/MIVAR>
 <?MIVAR name=$MI_NULL><?/MIVAR>

 <?MIBLOCK COND="$(AND,$(XST,$accession),$(XST,$input_acc))">
  <?MICOMMENT>*** when called by accession search and the input is an dblink accession, need to unset $constraint to avoid trouble when webexplode both markerselect and msegselect<?/MICOMMENT>
  <?MIVAR>	
    $(UNSETVAR,$constraint)
    $(UNSETVAR,$marker_type)
  <?/MIVAR>
 <?/MIBLOCK> 


 <!------------------ Results ----------------->
 <!-- data link from pub pages will also use this code 
	$pubId indicates this.-->
 <?MIBLOCK COND="$(OR,$(XST,$query_results),$(XST,$pubId))">  
 
  <?MIBLOCK COND="$(AND,$(XST,$input_acc),$(XST,$input_name))">
   <script>
     window.alert("Please modify your search for either name search or accession search.");
   </script>

  <?MIELSE>
   <!-- THIS NEXT PART IS EXECUTED AFTER THE PERSON ENTERS SOME CRITERIA -->

   <!-- First note that they have searched persons-->
   <?MISQL SQL="
     select WebExplode(object,'') 
      from webPages 
      where ID = 'aa-identify.apg';">
      $1
   <?/MISQL>

   <!-- set userid to ZDB_ID of user or GUEST to be used by the map viewer -->
   <?MIVAR NAME=$userid>GUEST<?/MIVAR>

   <!-- This next part builds up a query piece by piece, based on which criteria were passed in -->

   <?MIVAR NAME=$lg COND="$(NXST,$lg)">0<?/MIVAR>
   <?MIVAR COND="$(NXST,$sequence_type)" NAME=$sequence_type>any<?/MIVAR>
   <?MIVAR COND="$(NXST,$vector_type)" NAME=$vector_type>any<?/MIVAR>
   <?MIVAR COND="$(NXST,$compare)" NAME=$compare>contains<?/MIVAR>

   <?MIVAR NAME=$wild_card><?/MIVAR>
   <?MIVAR COND="$(NC,$compare,starts)" NAME=$wild_card>%<?/MIVAR>

   <!-- NOW BUILD UP THE CONSTRAINT CLAUSE -->

   <?MIVAR NAME=$constraintList COND="$(NXST,$constraintList)"><?/MIVAR>	
  
   <?MIVAR COND="$(XST,$constraint)">
 	$(VECAPPEND, $constraintList,$constraint)
   <?/MIVAR>

   <?MIBLOCK COND="$(XST,$marker_type)">
     <?MIVAR NAME=$typeConstraint>mrkr_type = '$marker_type' <?/MIVAR>
   <?MIELSE>
     <?MIVAR NAME=$typeConstraint>mrkr_type in (select mtgrpmem_mrkr_type from marker_type_group_member where mtgrpmem_mrkr_type_group ='SEARCH_SEG') <?/MIVAR>	
   <?/MIBLOCK>	
   <?MIVAR>
 	$(VECAPPEND,$constraintList,$typeConstraint)
   <?/MIVAR>

   <?MICOMMENT>
     We would like to order the return list with the significance of
     the matched name.  We use app page specific tables to hold the zdb id, 
     matched name, and significance.
   <?/MICOMMENT>
  
   <?MIVAR NAME=msegsel_optional_match_table><?/MIVAR>
   <?MIVAR NAME=msegsel_optional_match_cols><?/MIVAR>
   <?MIVAR NAME=msegsel_optional_marker_cols><?/MIVAR>
   <?MIVAR NAME=$name_constraint><?/MIVAR>
 
   <?MISQL SQL="
     select dbinfo('sessionid') 
       from single;">
     <?MIVAR NAME=$msegsel_session_id>$1<?/MIVAR>
     <?MIVAR NAME=$msegselect_temp_match>$(CONCAT,msegselect_temp_match_,$msegsel_session_id)<?/MIVAR>
     <?MIVAR NAME=$msegselect_temp_on_lg>$(CONCAT,msegselect_temp_on_lg_,$msegsel_session_id)<?/MIVAR>
     <?MIVAR NAME=$msegselect_temp_marker>$(CONCAT,msegselect_temp_marker_,$msegsel_session_id)<?/MIVAR>
   <?/MISQL>

   <?MISQL SQL="
     execute function table_exists('$msegselect_temp_match')">
     <?MISQL COND=$(EC,$1,f) SQL="
       create temp table $msegselect_temp_match (
	 msegmatch_zdb_id varchar(50),
	 msegmatch_name varchar(255),
	 msegmatch_significance integer,
	 msegmatch_precedence varchar(80)
       ) with NO LOG;">
     <?/MISQL>
   <?/MISQL>

   <?MIBLOCK COND="$(XST,$input_name)">

     <?MIVAR NAME=$input_name DELIMIT="'" REPLACE="''">$input_name<?/MIVAR>
     <?MIVAR NAME=$input_name DELIMIT="_" REPLACE="\_">$input_name<?/MIVAR>
     <?MIVAR NAME=mrkrMchIdLast><?/MIVAR>
     <?MIVAR NAME=mchGeneIdLast><?/MIVAR>

     <?MIBLOCK COND="$(EC,$compare,starts)">
       <?MIVAR NAME=$msegsel_nameTable><?/MIVAR>
       <?MIVAR NAME=$msegsel_nameTest>
         and allmapnm_name_lower like '$(LOWER,$input_name)%'
       <?/MIVAR>
     <?MIELSE>
       <?MIVAR NAME=$msegsel_nameTable>, all_name_ends<?/MIVAR>
       <?MIVAR NAME=$msegsel_nameTest>
         and allmapnm_serial_id = allnmend_allmapnm_serial_id
         and allnmend_name_end_lower like '$(LOWER,$input_name)%' 
       <?/MIVAR>
     <?/MIBLOCK>

     <?MICOMMENT>*** 08/26 name search will not search for accession number<?/MICOMMENT>

     <?MISQL SQL="
	select allmapnm_zdb_id, allmapnm_name, allmapnm_significance, allmapnm_precedence
          from all_map_names $msegsel_nameTable
	 where allmapnm_zdb_id like 'ZDB-$marker_type%'
           and allmapnm_precedence <> 'Accession number'
           $msegsel_nameTest
        order by allmapnm_zdb_id,allmapnm_significance, allmapnm_name; ">
	<?MIVAR NAME=mrkrMchId>$1<?/MIVAR>
	<?MISQL COND="$(NC,$mrkrMchId,$mrkrMchIdLast)" SQL="
	  insert into $msegselect_temp_match 
	      ( msegmatch_zdb_id, msegmatch_name,
	        msegmatch_significance, msegmatch_precedence )
	    values
	      ( '$1', '$(URLENCODE,$2)', '$3', '$4');">
 	  $(SETVAR,$mrkrMchIdLast,$mrkrMchId)          	
        <?/MISQL>
     <?/MISQL>

     <?MICOMMENT>
      when containing gene matches the entered name, use "Marker relations"
      significance.
     <?/MICOMMENT>
     <?MIVAR NAME=$msegsel_mrelPrecedence>Marker relations<?/MIVAR>
     <?MISQL SQL="
       select nmprec_significance
         from name_precedence
         where nmprec_precedence = '$msegsel_mrelPrecedence'">
       <?MIVAR NAME=$msegsel_mrelSignificance>$1<?/MIVAR>
     <?/MISQL>
     <?MIVAR NAME=mrkrMchIdLast><?/MIVAR>
     <?MIVAR NAME=mchGeneIdLast><?/MIVAR>
     <?MIVAR NAME=$contained_genes><?/MIVAR>	  
     <?MISQL SQL="
	select mrel_mrkr_1_zdb_id, mrel_mrkr_2_zdb_id, allmapnm_name, 
	       allmapnm_significance
	  from marker_relationship, all_map_names $msegsel_nameTable
	 where mrel_mrkr_2_zdb_id = allmapnm_zdb_id 
	   and mrel_type = 'clone contains gene'
           $msegsel_nameTest
           and mrel_mrkr_1_zdb_id like 'ZDB-$marker_type%'
	   and allmapnm_precedence <> 'Accession number'
           and not exists
		( select 'x' 
		    from $msegselect_temp_match
                    where msegmatch_zdb_id = mrel_mrkr_1_zdb_id )
	 order by mrel_mrkr_1_zdb_id, mrel_mrkr_2_zdb_id, allmapnm_significance; ">

        <?MIVAR NAME=mrkrMchId>$1<?/MIVAR>
	<?MIVAR NAME=mchGeneId>$2<?/MIVAR>
 	<?MIVAR NAME=mchName>$3<?/MIVAR>
	<?MIBLOCK COND="$(NC,$mrkrMchIdLast,$mrkrMchId)">

 	     <?MISQL COND="$(NC,$mrkrMchIdLast,)" SQL="
	        insert into $msegselect_temp_match 
		    ( msegmatch_zdb_id, msegmatch_name,
		      msegmatch_significance, msegmatch_precedence )
		  values
		    ( '$mrkrMchIdLast', 
		      '$(URLENCODE,$contained_genes)', 
                      $msegsel_mrelSignificance, '$msegsel_mrelPrecedence');">
             <?/MISQL> 	
	     <?MIVAR>
	       $(SETVAR,$contained_genes,$mchName)
	       $(SETVAR,$mchGeneIdLast,$mchGeneId)
 	       $(SETVAR,$mrkrMchIdLast,$mrkrMchId)
	     <?/MIVAR>
	<?MIELSE COND="$(AND,$(EC,$mrkrMchId,$mrkrMchIdLast),$(NC,$mchGeneIdLast,$mchGeneId))">
	   <?MIVAR>
		$(SETVAR,$contained_genes,$contained_genes", "$mchName)
	 	$(SETVAR,$mchGeneIdLast,$mchGeneId)
	   <?/MIVAR>
        <?/MIBLOCK>

     <?/MISQL>
     <?MISQL COND="$(NE,$mrkrMchIdLast,)" SQL="
        insert into $msegselect_temp_match 
	    ( msegmatch_zdb_id, msegmatch_name,
	      msegmatch_significance, msegmatch_precedence )
	   values
	    ( '$mrkrMchIdLast', 
	      '$(URLENCODE,$contained_genes)', 
              $msegsel_mrelSignificance, '$msegsel_mrelPrecedence'); ">
     <?/MISQL> 

    <?MIVAR NAME=$msegsel_optional_match_table>, $msegselect_temp_match<?/MIVAR>
    <?MIVAR>
        $(SETVAR,$msegsel_optional_match_cols,", msegmatch_name, msegmatch_significance, msegmatch_precedence")
        $(SETVAR,$msegsel_optional_marker_cols,", msegtmrkr_match_name, msegtmrkr_significance, msegtmrkr_precedence")
        $(SETVAR,$name_constraint," mrkr_zdb_id = msegmatch_zdb_id ")
	$(VECAPPEND, $constraintList,$name_constraint)
    <?/MIVAR>
    <?MIVAR COND="$(XST,$input_name)" NAME=input_name DELIMIT="''" REPLACE="'">$input_name<?/MIVAR>
    <?MIVAR COND="$(XST,$input_name)" NAME=input_name DELIMIT="\_" REPLACE="_">$input_name<?/MIVAR>
  <?/MIBLOCK><!-- end name is provided -->

   
  <?MIBLOCK COND="$(XST,$input_acc)">
    <?MISQL SQL="
      insert into $msegselect_temp_match 
	      ( msegmatch_zdb_id, msegmatch_name,
	        msegmatch_significance, msegmatch_precedence )
	select allmapnm_zdb_id, allmapnm_name, 
	       allmapnm_significance, allmapnm_precedence
          from all_map_names
	 where allmapnm_name_lower like '$wild_card$(LOWER,$input_acc)%'
           and allmapnm_precedence = 'Accession number';">
    <?/MISQL>
    <?MISQL SQL="
      insert into $msegselect_temp_match 
	      ( msegmatch_zdb_id, msegmatch_name,
	        msegmatch_significance, msegmatch_precedence )
	select mrel_mrkr_1_zdb_id, allmapnm_name, 
	       allmapnm_significance, allmapnm_precedence
          from all_map_names, marker_relationship
	 where allmapnm_name_lower like '$wild_card$(LOWER,$input_acc)%'
           and allmapnm_precedence = 'Accession number'
	   and mrel_mrkr_2_zdb_id = allmapnm_zdb_id
	   and mrel_type = 'clone contains small segment';">
    <?/MISQL>
    <?MIVAR NAME=$msegsel_optional_match_table>, $msegselect_temp_match<?/MIVAR>
    <?MIVAR>
        $(SETVAR,$msegsel_optional_match_cols,", msegmatch_name, msegmatch_significance, msegmatch_precedence")
        $(SETVAR,$msegsel_optional_marker_cols,", msegtmrkr_match_name, msegtmrkr_significance, msegtmrkr_precedence")
        $(SETVAR,$name_constraint," mrkr_zdb_id = msegmatch_zdb_id ")
	$(VECAPPEND, $constraintList,$name_constraint)
    <?/MIVAR>
  <?/MIBLOCK>


  <!------------------ if LG is selected ---------->
  <?MIBLOCK COND="$(NC,$lg,0)">
    <?MICOMMENT>*** 08/22 we are not pulling gene/markers mapping info to related segment. So here only need to check the segmentself's map info. *** things changed later, we should do pullover mapping.  <?/MICOMMENT>
    <?MISQL SQL="
      execute function table_exists('$msegselect_temp_on_lg')">
      <?MISQL COND=$(EC,$1,f) SQL="
	create temp table $msegselect_temp_on_lg (
	  msegtlg_mrkr_zdb_id varchar(50)
	) with NO LOG;">
      <?/MISQL>
    <?/MISQL>

    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
	select marker_id 
          from mapped_marker
	 where or_lg = '$lg';">
    <?/MISQL>
    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
	select mrel_mrkr_2_zdb_id
	  from mapped_marker, marker_relationship
	 where mrel_mrkr_1_zdb_id = marker_id
	   and or_lg = '$lg'
	   and mrel_type = 'clone contains small segment';">
    <?/MISQL>
    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
	select mrel_mrkr_1_zdb_id
	  from mapped_marker, marker_relationship
	 where mrel_mrkr_2_zdb_id = marker_id
	   and or_lg = '$lg'
	   and mrel_type in ('clone contains gene',
			     'clone contains small segment');">
    <?/MISQL>
    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
        select lnkgmem_member_zdb_id
	  from linkage, linkage_member
	 where lnkg_or_lg = '$lg'
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id ;">
    <?/MISQL>
    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
	select mrel_mrkr_2_zdb_id
	  from marker_relationship, linkage, linkage_member
	 where mrel_mrkr_1_zdb_id = lnkgmem_member_zdb_id
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id 
	   and lnkg_or_lg = '$lg'
	   and mrel_type = 'clone contains small segment';">
    <?/MISQL>
    <?MISQL  SQL="
      insert into $msegselect_temp_on_lg
	  ( msegtlg_mrkr_zdb_id )
	select mrel_mrkr_1_zdb_id
	  from marker_relationship, linkage, linkage_member
	 where mrel_mrkr_2_zdb_id = lnkgmem_member_zdb_id
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id 
	   and lnkg_or_lg = '$lg'
	   and mrel_type in ('clone contains gene',
			     'clone contains small segment');">
     <?/MISQL> 
    
     <?MIVAR NAME=$lgConstraint> mrkr_zdb_id in (select distinct msegtlg_mrkr_zdb_id from $msegselect_temp_on_lg)<?/MIVAR>
     <?MIVAR>
       $(VECAPPEND, $constraintList, $lgConstraint)
     <?/MIVAR>	
  <?/MIBLOCK>
  <!-------------------- end LG ----------------->


  <?MIVAR>     
	$(VECAPPEND, $constraintList," mrkr_zdb_id = clone_mrkr_zdb_id ")
	$(VECAPPEND, $constraintList," clone_vector_name = vector_name ")
  <?/MIVAR>
  <!---- sequence type --->
  <?MIVAR COND="$(NC,$sequence_type,any)">
     <?MIVAR NAME=$clnConstraint>clone_sequence_type = '$sequence_type'<?/MIVAR>
     $(VECAPPEND, $constraintList, $clnConstraint )
  <?/MIVAR>

   <!--- end sequence type --->


   <!--- vector type -->
  <?MIVAR COND="$(NC,$vector_type,any)">
     <?MIVAR NAME=$vecConstraint>vector_type_name = '$vector_type'<?/MIVAR>
     $(VECAPPEND, $constraintList, $vecConstraint )
  <?/MIVAR>
   <!--- end vector type -->

  <?MICOMMENT>clone_mrkr_zdb_id has foreign key on marker.mrkr_zdb_id, clone_vector_name has foreign key on vector.vector_type_name. <?/MICOMMENT>
    
    <!-- vector and sequence --><!-- vector and not sequence -->

    <?MIVAR NAME=$clone_and_vector>, clone, vector<?/MIVAR> 

    <!-- sequence and not vector -->
    <?MIVAR NAME=$clone_and_vector COND="$(AND,$(EC,$vector_type,any),$(NC,$sequence_type,any))">, clone, outer vector<?/MIVAR>

    <!-- not vector and not sequence -->
    <?MIVAR NAME=$clone_and_vector COND="$(AND,$(EC,$vector_type,any),$(EC,$sequence_type,any))">, outer (clone, vector)<?/MIVAR>

 <!-- split the constraints that not related to mapping info -->
    <?MIVAR NAME=$constraint>
	$(SUBSTR,$(SEPARATE,$constraintList, AND ),5)
    <?/MIVAR>

<!--** for data reverse link from publication table-->

<?MISQL SQL="
  execute function table_exists('$msegselect_temp_marker')">
  <?MISQL COND=$(EC,$1,f) SQL="
    create temp table $msegselect_temp_marker (
      msegtmrkr_abbrev varchar(150),
      msegtmrkr_type varchar(10),
      msegtmrkr_zdb_id varchar(50),
      msegtmrkr_clone_sequence_type varchar(20),
      msegtmrkr_vector_type_name varchar(20),
      msegtmrkr_abbrev_order varchar(255),
      msegtmrkr_match_name varchar(255),
      msegtmrkr_significance integer,
      msegtmrkr_precedence varchar(80)
    ) with NO LOG;">
  <?/MISQL>
<?/MISQL>

<?MIBLOCK COND="$(XST,$pubId)">
  <?MISQL SQL="
    insert into $msegselect_temp_marker
	( msegtmrkr_abbrev, msegtmrkr_type, 
	  msegtmrkr_zdb_id, msegtmrkr_clone_sequence_type, 
	  msegtmrkr_vector_type_name, msegtmrkr_abbrev_order )
	select mrkr_abbrev, mrkr_type, mrkr_zdb_id, 
	       clone_sequence_type, vector_type_name, mrkr_abbrev_order
	 from marker, record_attribution $clone_and_vector 
	where recattrib_source_zdb_id = '$pubId'
	  and recattrib_data_zdb_id = mrkr_zdb_id
	  and mrkr_zdb_id = clone_mrkr_zdb_id
 	  and clone_vector_name = vector_name
	  and mrkr_type in  (select mtgrpmem_mrkr_type from marker_type_group_member
                    	      where mtgrpmem_mrkr_type_group = 'SEARCH_SEG');">
   <?/MISQL>

<?MIELSE>

   <?MISQL SQL="
     insert into $msegselect_temp_marker
	( msegtmrkr_abbrev, msegtmrkr_type, 
	  msegtmrkr_zdb_id, msegtmrkr_clone_sequence_type, 
	  msegtmrkr_vector_type_name, msegtmrkr_abbrev_order $msegsel_optional_marker_cols )
	select distinct mrkr_abbrev, mrkr_type, 
			mrkr_zdb_id, clone_sequence_type, vector_type_name, 
			mrkr_abbrev_order $msegsel_optional_match_cols
	 from marker $msegsel_optional_match_table $clone_and_vector 
	where $constraint;">
   <?/MISQL>

<?/MIBLOCK>

 <?MICOMMENT>
   Delete can be expensive, only do it if you actually inserted records
 <?/MICOMMENT>
 <?MISQL COND="$(NC,$lg,0)" SQL="
   delete from $msegselect_temp_on_lg;">
 <?/MISQL>
 <?MISQL COND="$(OR,$(XST,$input_name),$(XST,$input_acc))" SQL="
    delete from $msegselect_temp_match;">
 <?/MISQL>

 <!--  Count the number of marker names that will be returned. -->
 <!--  query count(*) -->
 <?MISQL SQL="
   select distinct msegtmrkr_zdb_id, msegtmrkr_abbrev
     from $msegselect_temp_marker;">
   <?MIVAR NAME=$the_marker>$1<?/MIVAR>
 <?/MISQL>
 <?MIVAR NAME=$num_recs>$MI_ROWCOUNT<?/MIVAR>

 <?MIBLOCK COND="$(AND,$(NXST,$return_rec),$(NXST,$accession),$(=,$num_recs,1))">
    <?MISQL SQL="select get_mrkr_url('$the_marker') from single;">
      <SCRIPT>location.replace("$1")</SCRIPT>
    <?/MISQL>
 <?MIELSE>

   <!-- NOW JUST RETRIEVE AND DISPLAY ALL MATCHING ENTRIES. -->

   <table width=100%>
    <tr>
    <td width=90%>	
      <font size="+1"><center>
	<?MIBLOCK COND="$(OR,$(XST,$pubId),$(XST,$accession))">
	  Clones and Probes List
	  <?MIVAR>(<b>$num_recs</b> records)<?/MIVAR>
        <?MIELSE>
	  <?MIVAR>$marker_type Search Results (<b>$num_recs</b> records)<?/MIVAR>
        <?/MIBLOCK></center>
      </font>
    </td>
    <?MIBLOCK COND="$(NXST,$accession)">
     <td width=10%>
      <!-- Insert a form with one button. Label button Your Input Welcome -->
      <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-input_button_generic.apg';">$1<?/MISQL>
     </td>
    <?/MIBLOCK>
  </tr>
  </table>
<?/MIBLOCK><!-- end of whether one return or more -->

<!-- Stuff to control retrieval volume -->
<form method=post 
      name=mseglister 
      action="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->">
  <?MIVAR>
    <input type=hidden name=MIval value=aa-msegselect.apg>    
    <input type=hidden name=userid value="$userid">
    <input type=hidden name=compare value="$compare">

  <?/MIVAR>
</FORM>

<?MIBLOCK COND="$(>,$num_recs,0)">
 
  <TABLE width=100% border=0 cellspacing=0 cellpadding=3 >
    <TR>
      <TH>&nbsp;</TH>
      <TH align=left>Name</TH> 
      <TH align=left>Sequence Type</TH> 
      <TH align=left>Vector Type</TH>
      <TH align=left>Map</TH> 
      <?MIBLOCK COND="$(XST,$input_name)">
        <TH align=left>Matching Text</TH> 
      <?/MIBLOCK>
    </TR>

    <?MIVAR NAME=$ok_view_map>0<?/MIVAR>


    <!--- WALKING WINDOW --->
    <!--- Initialization --->
    <?MIVAR NAME=WINSIZE DEFAULT=20>$WINSIZE<?/MIVAR>
    <?MIVAR NAME=BEGIN DEFAULT=1>$START<?/MIVAR>


    <!--- DEFINITION OF RANGES --->
    <?MIVAR NAME=BEGIN>$(IF,$(<,$BEGIN,1),1,$BEGIN)<?/MIVAR> 
    <?MIVAR NAME=END>$(+,$BEGIN,$WINSIZE)<?/MIVAR>


    <!--- EXECUTION --->
    <!--  Set outer loop variables, row_color and ok_view_map -->
    <?MIVAR name=$row_color>$highlight<?/MIVAR>
    <?MIVAR NAME=$ok_view_map>0<?/MIVAR>
    <?MIVAR name=$first_row>1<?/MIVAR>
    <?MIVAR NAME=$rowNUM>$BEGIN<?/MIVAR>

    <!--- Query Database --->
    <?MISQL WINSTART=$BEGIN WINSIZE=$WINSIZE SQL="
	  select distinct msegtmrkr_abbrev, msegtmrkr_type, msegtmrkr_zdb_id,
		          msegtmrkr_abbrev_order, msegtmrkr_clone_sequence_type,
			  msegtmrkr_vector_type_name, msegtmrkr_match_name, 
			  msegtmrkr_significance, msegtmrkr_precedence, 
			  mrkrtype_type_display
	    from $msegselect_temp_marker, marker_types
           where msegtmrkr_type = marker_type
	   order by msegtmrkr_significance, msegtmrkr_abbrev_order ;">
	  <?MIVAR NAME=$abbrev>$1<?/MIVAR>
	  <?MIVAR NAME=$mtype>$2<?/MIVAR>
	  <?MIVAR NAME=$OID>$3<?/MIVAR>
	  <?MIVAR NAME=$clone_sequence_type>$5<?/MIVAR>
	  <?MIVAR NAME=$vector_type_name>$6<?/MIVAR>
          <?MIVAR NAME=$match_name>$(URLDECODE,$7)<?/MIVAR>
	  <?MIVAR NAME=$match_text>$9<?/MIVAR>
	  <?MIVAR NAME=$mtype_display>$10<?/MIVAR>

          <?MICOMMENT> ** call the link code in it's own query so that it's run only 
                          for the few records that are actually displayed ** <?/MICOMMENT>
          <?MISQL SQL="select get_mrkr_abbrev_html_link('$OID') from single;">
            <?MIVAR NAME="$msegsel_mrkr_link">$1<?/MIVAR>
          <?/MISQL>
 

      <?MIVAR NAME=$viewer>/action/marker/view/<?/MIVAR>
     <!-- create form for each marker  -->
      <!-- get rid of dashes to avoid javascript error -->

      <?MIVAR NAME=$form_name DELIMIT="-" REPLACE="">$OID<?/MIVAR>

      <form method=post  
	    action="/<!--|CGI_BIN_DIR_NAME|-->/view_mapplet.cgi"
	    name="$form_name">

	<?MIVAR name=$first_row>1<?/MIVAR>

	  <?MIBLOCK COND="$(EC,$first_row,1)">
	    <!-- start new row and column -->
	    <TR bgcolor="<?MIVAR>$row_color<?/MIVAR>">
	      <TD valign=top>&nbsp;</TD>

		<?MIVAR name=$rowNUM>$(+,$rowNUM,1)<?/MIVAR>

	      <TD valign=top> 
              <?MIVAR> 
                <font size=2>
                  $(IF,$(XST,$return_rec),<A HREF=/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-do-select.apg&return_rec=$return_rec&new_oid=$OID>SELECT</A>)
                </font>

		$(IF,$(OR,$(XST,$accession),$(XST,$pubId)),$mtype_display:)
              $msegsel_mrkr_link
              <?/MIVAR>
	      </TD>
	  <?/MIBLOCK>


	  <?MIBLOCK COND="$(EC,$first_row,0)">
	    <!--   start new row and column   -->
	    <TR bgcolor="<?MIVAR>$row_color<?/MIVAR>">
	      <TD><font size=1> &nbsp;</font></TD>
	      <TD>&nbsp;</TD>
	  <?/MIBLOCK>

	<TD valign="top"> 
	 <?MIVAR>$clone_sequence_type<?/MIVAR>
        </TD> 

	<TD valign="top"> 
	 <?MIVAR>$vector_type_name<?/MIVAR>
        </TD> 

	<TD>
          <?MISQL SQL="select WebExplode(object,'&mapdetails_mode=mini&split=break&hide_empty=t&oID=$OID') from webPages where ID='aa-mappingdetail.apg';">$1<?/MISQL>
	</TD> 
       
        <?MIBLOCK COND="$(XST,$input_name)">   
        <TD>
	    <?MICOMMENT>$match_text: $(REPLACE,$match_name,$input_name,<b>$input_name</b>)<?/MICOMMENT>
	    <?MIVAR NAME=start_pos>$(POSITION,$(LOWER,$match_name),$(LOWER,$input_name))<?/MIVAR>
	    <?MIVAR NAME=str_length>$(STRLEN,$input_name)<?/MIVAR>
	    <?MIVAR>$match_text: $(SUBSTR,$match_name,1,$(-,$start_pos,1))<b>$(SUBSTR,$match_name,$start_pos,$str_length)</b>$(SUBSTR,$match_name,$(+,$start_pos,$str_length))		
	    <?/MIVAR>
        </TD>
        <?/MIBLOCK>
     </TR>

	  <?MIVAR name=$first_row>0<?/MIVAR>

	<!--    change row_color    -->
	<?MIBLOCK>
	  <?MIBLOCK COND="$(EC,$row_color,$highlight)">     
	    <?MIVAR name=$row_color>#FFFFFF<?/MIVAR>
	  <?MIELSE COND="$(EC,$row_color,#FFFFFF)">      
	    <?MIVAR name=$row_color>$highlight<?/MIVAR>
	  <?/MIBLOCK>
	<?/MIBLOCK>

	<!-- end form for map_marker -->         
      </FORM>

      <!-- end outer SQL -->  
     <?/MISQL>
  </TABLE>

  <BR>
  <Center>
  <Table width="70%" border="0">
    <tr>
      <td width="45%" align=right valign=top>&nbsp;

	<!-- to be used by walking windows -->
        <!-- want GET string as short as possible - append only when variable exists, buffer overflow may cause segmentation fault -->
        <?MIVAR name=comment>  Build array of user data  <?/MIVAR>
	<?MIVAR name=selector>MIval=aa-msegselect.apg&WINSIZE=$WINSIZE<?/MIVAR>
        <?MIVAR name=UserInput><?/MIVAR>
	<!--***-->
	<?MIBLOCK COND="$(NXST,$pubId)">
	<?MIVAR name=UserInput COND=$(XST,$lg)>$UserInput&lg=$lg<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$compare)>$UserInput&compare=$compare<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$return_rec)>$UserInput&return_rec=$return_rec<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$input_name)>$UserInput&input_name=$(URLENCODE,$input_name)<?/MIVAR>  
	<?MIVAR name=UserInput COND=$(XST,$sequence_type)>$UserInput&sequence_type=$sequence_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$vector_type)>$UserInput&vector_type=$vector_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$marker_type)>$UserInput&marker_type=$marker_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$input_acc)>$UserInput&input_acc=$(URLENCODE,$input_acc)<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$query_results)>$UserInput&query_results=$(URLENCODE,$query_results)<?/MIVAR>  
	
	<?MIELSE>
         <?MIVAR name=$UserInput>$UserInput&pubId=$pubId<?/MIVAR>
        <?/MIBLOCK>


       <?MIVAR>
	<div id="pagination"></div>
	<script type="text/javascript">
	    jQuery('#pagination').load('/action/pagination?maxDisplayRecords=$WINSIZE&actionUrl=$(URLENCODE,$selector)$(URLENCODE,$UserInput)&firstPageRecord=$BEGIN&totalRecords=$num_recs');
	</script>
 	<?/MIVAR>
	<div id="pagination"></div>
       <p/>
      </td>
    </tr>
    <tr>
    <td>&nbsp;      </td>
    </tr>
  </Table>
  </Center>
  <?/MIBLOCK> <!-- end # rows > 0 -->


 <?MISQL SQL="
   delete from $msegselect_temp_marker;">
 <?/MISQL>


 <?/MIBLOCK> <!-- no simultanious name and acc search -->
<?/MIBLOCK><!-- xst query_result or xst pubId -->



<!----------------  Query Form -------------------------------------->
<?MIBLOCK COND="$(AND,$(NXST,$accession),$(NXST,$pubId))">   
  
  <?MISQL SQL="select WebExplode(object,'page=msegselect') from webPages where ID='aa-searchform.apg';">$1<?/MISQL>

<?/MIBLOCK> 



<?MIBLOCK COND="$(NXST,$accession)">
    <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpagefooter.apg';">$1<?/MISQL>
<?/MIBLOCK>

