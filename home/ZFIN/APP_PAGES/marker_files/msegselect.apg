	
<!--
 
-->

<?MIBLOCK COND="$(NXST,$accession)">
 <HTML>
 <HEAD>
  <?MIVAR Name=page_name>$(IF,$(XST,$query_results),ZFIN Molecular Segment Search Results,ZFIN Search Molecular Segments)<?/MIVAR>
  <?MIVAR><TITLE>$page_name</TITLE><?/MIVAR>


  <SCRIPT>

    function call_reset() {

	document.critform.input_name.value = "";
	document.critform.input_acc.value = "";
	document.critform.START.value = "";
	document.critform.lg.selectedIndex = 0;
	document.critform.compare.selectedIndex = 0;
	document.critform.marker_type.selectedIndex = 0;
        document.critform.sequence_type.selectedIndex = 0;
	document.critform.vector_type.selectedIndex = 0;
	document.critform.WINSIZE.value = 20;

     }
   </SCRIPT>


 <?MIVAR NAME=$OID COND="$(NXST,$OID)">NULL<?/MIVAR>

 <?MISQL SQL="
  select object 
    from webPages 
    where ID = 'aa-chromoscripts.apg';">
  $1
 <?/MISQL>

 </HEAD>
 
 <BODY>
	
  <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpageheader.apg';">$1<?/MISQL>


<?/MIBLOCK><!-- end XST accession which means it is called by Accession Search --> 

 <?MIVAR name=$highlight><!--|HIGHLIGHT_COLOR|--><?/MIVAR>
 <?MIVAR name=$MI_NOVALUE><?/MIVAR>
 <?MIVAR name=$MI_NULL><?/MIVAR>

 <?MIBLOCK COND="$(AND,$(XST,$accession),$(XST,$input_acc))">
  <?MICOMMENT>*** when called by accession search and the input is an dblink accession, need to unset $constraint to avoid trouble when webexplode both markerselect and msegselect<?/MICOMMENT>
  <?MIVAR>	
    $(UNSETVAR,$constraint)
    $(UNSETVAR,$marker_type)
  <?/MIVAR>
 <?/MIBLOCK> 


 <!------------------ Results ----------------->
 <!-- data link from pub pages will also use this code 
	$pubId indicates this.-->
 <?MIBLOCK COND="$(OR,$(XST,$query_results),$(XST,$pubId))">  
 
  <?MIBLOCK COND="$(AND,$(XST,$input_acc),$(XST,$input_name))">
   <script>
     window.alert("Please modify your search for either name search or accession search.");
   </script>

  <?MIELSE>
   <!-- THIS NEXT PART IS EXECUTED AFTER THE PERSON ENTERS SOME CRITERIA -->

   <!-- First note that they have searched persons-->
   <?MISQL SQL="
     select WebExplode(object,'') 
      from webPages 
      where ID = 'aa-identify.apg';">
      $1
   <?/MISQL>

   <!-- set userid to ZDB_ID of user or GUEST to be used by the map viewer -->
   <?MIVAR NAME=$userid>GUEST<?/MIVAR>

   <!-- This next part builds up a query piece by piece, based on which criteria were passed in -->

   <?MIVAR NAME=$lg COND="$(NXST,$lg)">0<?/MIVAR>
   <?MIVAR COND="$(NXST,$sequence_type)" NAME=$sequence_type>any<?/MIVAR>
   <?MIVAR COND="$(NXST,$vector_type)" NAME=$vector_type>any<?/MIVAR>
   <?MIVAR COND="$(NXST,$compare)" NAME=$compare>contains<?/MIVAR>

   <!-- First filter name for apostrophes! -->
   <?MIVAR COND="$(XST,$input_name)" NAME=$input_name DELIMIT="'" REPLACE="''">$input_name<?/MIVAR>

   <?MIVAR NAME=$wild_card><?/MIVAR>
   <?MIVAR COND="$(NC,$compare,starts)" NAME=$wild_card>%<?/MIVAR>


   <!-- NOW BUILD UP THE CONSTRAINT CLAUSE -->

   <?MIVAR NAME=$constraintList COND="$(NXST,$constraintList)"><?/MIVAR>	
  
   <?MIVAR COND="$(XST,$constraint)">
 	$(VECAPPEND, $constraintList,$constraint)
   <?/MIVAR>

   <?MIBLOCK COND="$(XST,$marker_type)">
     <?MIVAR NAME=$typeConstraint>mrkr_type = '$marker_type' <?/MIVAR>
   <?MIELSE>
     <?MIVAR NAME=$typeConstraint>mrkr_type in (select mtgrpmem_mrkr_type from marker_type_group_member where mtgrpmem_mrkr_type_group ='SEARCH_SEG') <?/MIVAR>	
   <?/MIBLOCK>	
   <?MIVAR>
 	$(VECAPPEND,$constraintList,$typeConstraint)
   <?/MIVAR>

   <?MICOMMENT>** 08/14/03 We would like to order the return list with the significance of the matched name. We create temp tables to hold the zdb id, matched name, and significance.<?/MICOMMENT>
  
   <?MIVAR NAME=$name_sig_col><?/MIVAR>
   <?MIVAR NAME=$name_match_table><?/MIVAR>
   <?MIVAR NAME=$sig_order><?/MIVAR>
   <?MIVAR NAME=$name_constraint><?/MIVAR>
 
   <?MIBLOCK COND="$(XST,$input_name)">
     <?MISQL SQL="
	  create temp table msegselect_name_match(
		msegmch_zdb_id	varchar(50),
		msegmch_name	varchar(200),
		msegmch_significance	int,
		msegmch_precedence	varchar(80) ); ">
     <?/MISQL> 
     <?MIVAR NAME=mrkrMchIdLast><?/MIVAR>
     <?MIVAR NAME=mchGeneIdLast><?/MIVAR>
     <?MICOMMENT>*** 08/26 name search will not search for accession number<?/MICOMMENT>

    <!-- when the containing gene matches the entered name, sig is 1--> 
     <?MIVAR NAME=$contained_genes><?/MIVAR>	  
     <?MISQL SQL="
	select mrel_mrkr_1_zdb_id, mrel_mrkr_2_zdb_id, allmapnm_name, 
		allmapnm_significance
	  from marker_relationship, all_map_names 
	 where mrel_mrkr_2_zdb_id = allmapnm_zdb_id 
	   and mrel_type = 'clone contains gene'
           and allmapnm_name_lower like '$wild_card$(LOWER,$input_name)%'
           and mrel_mrkr_1_zdb_id like 'ZDB-$marker_type%'
	   and allmapnm_precedence <> 'Accession number'
	  order by mrel_mrkr_1_zdb_id, mrel_mrkr_2_zdb_id, allmapnm_significance; ">

        <?MIVAR NAME=mrkrMchId>$1<?/MIVAR>
	<?MIVAR NAME=mchGeneId>$2<?/MIVAR>
 	<?MIVAR NAME=mchName>$3<?/MIVAR>
	<?MIBLOCK COND="$(NC,$mrkrMchIdLast,$mrkrMchId)">

 	     <?MISQL COND="$(NC,$mrkrMchIdLast,)" SQL="
	        insert into msegselect_name_match 
		  values('$mrkrMchIdLast', '$(URLENCODE,$contained_genes)', '1', 'Marker relations'); ">
             <?/MISQL> 	
	     <?MIVAR>
	       $(SETVAR,$contained_genes,$mchName)
	       $(SETVAR,$mchGeneIdLast,$mchGeneId)
 	       $(SETVAR,$mrkrMchIdLast,$mrkrMchId)
	     <?/MIVAR>
	<?MIELSE COND="$(AND,$(EC,$mrkrMchId,$mrkrMchIdLast),$(NC,$mchGeneIdLast,$mchGeneId))">
	   <?MIVAR>
		$(SETVAR,$contained_genes,$contained_genes", "$mchName)
	 	$(SETVAR,$mchGeneIdLast,$mchGeneId)
	   <?/MIVAR>
        <?/MIBLOCK>

     <?/MISQL>
     <?MISQL SQL="
	    insert into msegselect_name_match 
		 values('$mrkrMchIdLast', '$(URLENCODE,$contained_genes)', '1', 'Marker relations'); ">
     <?/MISQL> 


     <?MISQL SQL="
	select allmapnm_zdb_id, allmapnm_name, allmapnm_significance, allmapnm_precedence
          from all_map_names
	 where allmapnm_name_lower like '$wild_card$(LOWER,$input_name)%'
	   and allmapnm_zdb_id like 'ZDB-$marker_type%'
           and allmapnm_precedence <> 'Accession number'
	   and allmapnm_zdb_id not in (select msegmch_zdb_id from msegselect_name_match)
        order by allmapnm_zdb_id,allmapnm_significance, allmapnm_name; ">
	<?MIVAR NAME=mrkrMchId>$1<?/MIVAR>
	<?MISQL COND="$(NC,$mrkrMchId,$mrkrMchIdLast)" SQL="
           insert into msegselect_name_match 
	    values('$1', '$(URLENCODE,$2)', '$3', '$4');">
 		$(SETVAR,$mrkrMchIdLast,$mrkrMchId)          	
        <?/MISQL>
     <?/MISQL>

  
    <?MIVAR>
        $(SETVAR,$name_sig_col,",msegmch_name,msegmch_significance, msegmch_precedence")
        $(SETVAR,$name_match_table,",msegselect_name_match")
        $(SETVAR,$sig_order,"msegmch_significance, ")
        $(SETVAR,$name_constraint," mrkr_zdb_id = msegmch_zdb_id ")
	$(VECAPPEND, $constraintList,$name_constraint)
    <?/MIVAR>
 
  <?/MIBLOCK><!-- end name is provided -->

   
  <?MIBLOCK COND="$(XST,$input_acc)">
    <?MISQL SQL="
	select allmapnm_zdb_id, allmapnm_name, allmapnm_significance, allmapnm_precedence
          from all_map_names
	 where allmapnm_name_lower like '$wild_card$(LOWER,$input_acc)%'
           and allmapnm_precedence = 'Accession number'
        UNION
	select mrel_mrkr_1_zdb_id, allmapnm_name, allmapnm_significance, allmapnm_precedence
          from all_map_names, marker_relationship
	 where allmapnm_name_lower like '$wild_card$(LOWER,$input_acc)%'
           and allmapnm_precedence = 'Accession number'
	   and mrel_mrkr_2_zdb_id = allmapnm_zdb_id
	   and mrel_type = 'clone contains small segment'
	into temp msegselect_acc_match; ">
    <?/MISQL>
    <?MIVAR>
        $(SETVAR,$name_match_table,",msegselect_acc_match")
        $(SETVAR,$name_constraint," mrkr_zdb_id = allmapnm_zdb_id ")
	$(VECAPPEND, $constraintList,$name_constraint)
    <?/MIVAR>
  <?/MIBLOCK>


  <!------------------ if LG is selected ---------->
  <?MIBLOCK COND="$(NC,$lg,0)">
    <?MICOMMENT>*** 08/22 we are not pulling gene/markers mapping info to related segment. So here only need to check the segmentself's map info. *** things changed later, we should do pullover mapping.  <?/MICOMMENT>
    <?MISQL  SQL="
	select marker_id 
          from mapped_marker
	 where or_lg = '$lg'
      UNION 
	select mrel_mrkr_2_zdb_id as marker_id
	  from mapped_marker, marker_relationship
	 where mrel_mrkr_1_zdb_id = marker_id
	   and or_lg = '$lg'
	   and mrel_type = 'clone contains small segment'
       UNION 
	select mrel_mrkr_1_zdb_id as marker_id
	  from mapped_marker, marker_relationship
	 where mrel_mrkr_2_zdb_id = marker_id
	   and or_lg = '$lg'
	   and mrel_type in ('clone contains gene',
			     'clone contains small segment')
       UNION
        select lnkgmem_member_zdb_id as marker_id
	  from linkage, linkage_member
	 where lnkg_or_lg = '$lg'
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id 
       UNION	
	select mrel_mrkr_2_zdb_id as marker_id
	  from marker_relationship, linkage, linkage_member
	 where mrel_mrkr_1_zdb_id = lnkgmem_member_zdb_id
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id 
	   and lnkg_or_lg = '$lg'
	   and mrel_type = 'clone contains small segment'
       UNION 
	select mrel_mrkr_1_zdb_id as marker_id
	  from marker_relationship, linkage, linkage_member
	 where mrel_mrkr_2_zdb_id = lnkgmem_member_zdb_id
  	   and lnkgmem_linkage_zdb_id = lnkg_zdb_id 
	   and lnkg_or_lg = '$lg'
	   and mrel_type in ('clone contains gene',
			     'clone contains small segment')
	  into temp msegselect_tmp_on_lg with no log; ">
     <?/MISQL> 
    
     <?MIVAR NAME=$lgConstraint> mrkr_zdb_id in (select marker_id from msegselect_tmp_on_lg)<?/MIVAR>
     <?MIVAR>
       $(VECAPPEND, $constraintList, $lgConstraint)
     <?/MIVAR>	
  <?/MIBLOCK>
  <!-------------------- end LG ----------------->


  <?MIVAR>     
	$(VECAPPEND, $constraintList," mrkr_zdb_id = clone_mrkr_zdb_id ")
	$(VECAPPEND, $constraintList," clone_vector_name = vector_name ")
  <?/MIVAR>
  <!---- sequence type --->
  <?MIVAR COND="$(NC,$sequence_type,any)">
     <?MIVAR NAME=$clnConstraint>clone_sequence_type = '$sequence_type'<?/MIVAR>
     $(VECAPPEND, $constraintList, $clnConstraint )
  <?/MIVAR>

   <!--- end sequence type --->


   <!--- vector type -->
  <?MIVAR COND="$(NC,$vector_type,any)">
     <?MIVAR NAME=$vecConstraint>vector_type_name = '$vector_type'<?/MIVAR>
     $(VECAPPEND, $constraintList, $vecConstraint )
  <?/MIVAR>
   <!--- end vector type -->

  <?MICOMMENT>clone_mrkr_zdb_id has foreign key on marker.mrkr_zdb_id, clone_vector_name has foreign key on vector.vector_type_name. <?/MICOMMENT>
    
    <!-- vector and sequence --><!-- vector and not sequence -->

    <?MIVAR NAME=$clone_and_vector>, clone, vector<?/MIVAR> 

    <!-- sequence and not vector -->
    <?MIVAR NAME=$clone_and_vector COND="$(AND,$(EC,$vector_type,any),$(NC,$sequence_type,any))">, clone, outer vector<?/MIVAR>

    <!-- not vector and not sequence -->
    <?MIVAR NAME=$clone_and_vector COND="$(AND,$(EC,$vector_type,any),$(EC,$sequence_type,any))">, outer (clone, vector)<?/MIVAR>

 <!-- split the constraints that not related to mapping info -->
    <?MIVAR NAME=$constraint>
	$(SUBSTR,$(SEPARATE,$constraintList, AND ),5)
    <?/MIVAR>

<!--** for data reverse link from publication table-->

<?MIVAR NAME=$optional_table><?/MIVAR>

<?MIBLOCK COND="$(XST,$pubId)">
  <?MISQL SQL="
	select mrkr_abbrev, mrkr_type, mrkr_zdb_id, clone_sequence_type, vector_type_name, mrkr_abbrev_order $name_sig_col
	 from marker, record_attribution $clone_and_vector 
	where recattrib_source_zdb_id = '$pubId'
	  and recattrib_data_zdb_id = mrkr_zdb_id
	  and mrkr_zdb_id = clone_mrkr_zdb_id
 	  and clone_vector_name = vector_name
	  and mrkr_type in  (select mtgrpmem_mrkr_type from marker_type_group_member
                    	      where mtgrpmem_mrkr_type_group = 'SEARCH_SEG')
	into temp msegselect_tmp_markers with no log;">
   <?/MISQL>

<?MIELSE>

   <?MISQL SQL="
	select mrkr_abbrev, mrkr_type, mrkr_zdb_id, clone_sequence_type, vector_type_name, mrkr_abbrev_order $name_sig_col
	 from marker $clone_and_vector $name_match_table $optional_table
	where $constraint
	into temp msegselect_tmp_markers with no log;">
   <?/MISQL>

<?/MIBLOCK>

 <?MIVAR NAME=msegtable> msegselect_tmp_markers <?/MIVAR>

 <?MISQL COND="$(NC,$lg,0)" SQL="
	set explain off;
	drop table msegselect_tmp_on_lg; ">
 <?/MISQL>
 <?MISQL COND="$(XST,$input_name)" SQL="
	set explain off;
	drop table msegselect_name_match; ">
 <?/MISQL>

 <!--  Count the number of marker names that will be returned. -->
 <!--  query count(*) -->
 <?MISQL SQL="
  select distinct mrkr_zdb_id, mrkr_abbrev
    from $msegtable;">
  <?MIVAR NAME=$the_marker>$1<?/MIVAR>
 <?/MISQL>
 <?MIVAR NAME=$num_recs>$MI_ROWCOUNT<?/MIVAR>

 <?MIBLOCK COND="$(AND,$(NXST,$return_rec),$(NXST,$accession),$(=,$num_recs,1))">
    <?MIVAR>
      <SCRIPT>location.replace("/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-markerview.apg&OID=$the_marker")</SCRIPT>
    <?/MIVAR>
 <?MIELSE>

   <!-- NOW JUST RETRIEVE AND DISPLAY ALL MATCHING ENTRIES. -->

   <table width=100%>
    <tr>
    <td width=90%>	
      <font size="+1"><center>
	<?MIBLOCK COND="$(OR,$(XST,$pubId),$(XST,$accession))">
	  Clones and Probes List
	  <?MIVAR>(<b>$num_recs</b> records)<?/MIVAR>
        <?MIELSE>
	  <?MIVAR>$marker_type Search Results (<b>$num_recs</b> records)<?/MIVAR>
        <?/MIBLOCK></center>
      </font>
    </td>
    <?MIBLOCK COND="$(NXST,$accession)">
     <td width=10%>
      <!-- Insert a form with one button. Label button Your Input Welcome -->
      <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-input_button_generic.apg';">$1<?/MISQL>
     </td>
    <?/MIBLOCK>
  </tr>
  </table>
<?/MIBLOCK><!-- end of whether one return or more -->

<?MISQL COND="$(XST,$input_acc)" SQL="
	set explain off;
	drop table msegselect_acc_match; ">
<?/MISQL>


<!-- Stuff to control retrieval volume -->
<form method=post 
      name=mseglister 
      action="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->">
  <?MIVAR>
    <input type=hidden name=MIval value=aa-msegselect.apg>    
    <input type=hidden name=userid value="$userid">
    <input type=hidden name=compare value="$compare">

  <?/MIVAR>
</FORM>

<?MIBLOCK COND="$(>,$num_recs,0)">
 
  <TABLE width=100% border=0 cellspacing=0 cellpadding=3 >
    <TR>
      <TH>&nbsp;</TH>
      <TH align=left>Name</TH> 
      <TH align=left>Sequence Type</TH> 
      <TH align=left>Vector Type</TH>
      <TH align=left>Map</TH> 
      <?MIBLOCK COND="$(XST,$input_name)">
        <TH align=left>Matching Text</TH> 
      <?/MIBLOCK>
    </TR>

    <?MIVAR NAME=$ok_view_map>0<?/MIVAR>


    <!--- WALKING WINDOW --->
    <!--- Initialization --->
    <?MIVAR NAME=WINSIZE DEFAULT=20>$WINSIZE<?/MIVAR>
    <?MIVAR NAME=BEGIN DEFAULT=1>$START<?/MIVAR>


    <!--- DEFINITION OF RANGES --->
    <?MIVAR NAME=BEGIN>$(IF,$(<,$BEGIN,1),1,$BEGIN)<?/MIVAR> 
    <?MIVAR NAME=END>$(+,$BEGIN,$WINSIZE)<?/MIVAR>


    <!--- EXECUTION --->
    <!--  Set outer loop variables, row_color and ok_view_map -->
    <?MIVAR name=$row_color>$highlight<?/MIVAR>
    <?MIVAR NAME=$ok_view_map>0<?/MIVAR>
    <?MIVAR name=$first_row>1<?/MIVAR>
    <?MIVAR NAME=$rowNUM>$BEGIN<?/MIVAR>

    <!--- Query Database --->
    <?MISQL WINSTART=$BEGIN WINSIZE=$WINSIZE SQL="
	  select mrkr_abbrev, mrkr_type, mrkr_zdb_id,mrkr_abbrev_order,
		 clone_sequence_type, vector_type_name $name_sig_col, mrkrtype_type_display
	    from $msegtable, marker_types
           where mrkr_type = marker_type
	  order by $sig_order mrkr_abbrev_order ;">
	  <?MIVAR NAME=$abbrev>$1<?/MIVAR>
	  <?MIVAR NAME=$mtype>$2<?/MIVAR>
	  <?MIVAR NAME=$OID>$3<?/MIVAR>
	  <?MIVAR NAME=$clone_sequence_type>$5<?/MIVAR>
	  <?MIVAR NAME=$vector_type_name>$6<?/MIVAR>
          <?MIVAR NAME=$match_name>$(URLDECODE,$7)<?/MIVAR>
	  <?MIVAR NAME=$match_sig>$8<?/MIVAR>
	  <?MIVAR NAME=$match_text>$9<?/MIVAR>
	  <?MIVAR NAME=$mtype_display>$10<?/MIVAR>

	  <?MIVAR NAME=$viewer>aa-markerview.apg<?/MIVAR>
     <!-- create form for each marker  -->
      <!-- get rid of dashes to avoid javascript error -->

      <?MIVAR NAME=$form_name DELIMIT="-" REPLACE="">$OID<?/MIVAR>

      <form method=post  
	    action="/<!--|CGI_BIN_DIR_NAME|-->/view_mapplet.cgi"
	    name="$form_name">

	<?MIVAR name=$first_row>1<?/MIVAR>

	  $(IF,$(>,$(POSITION,$OID,LOCUS),0),
	    $(SETVAR,$viewer,aa-locusview.apg))              

	  $(IF,$(>,$(POSITION,$OID,FISH),0),
	    $(SETVAR,$viewer,aa-fishview.apg))
<!-- Column 1, Segment Name -->

	  <?MIBLOCK COND="$(EC,$first_row,1)">
	    <!-- start new row and column -->
	    <TR bgcolor="<?MIVAR>$row_color<?/MIVAR>">
	      <TD valign=top>&nbsp;</TD>

		<?MIVAR name=$rowNUM>$(+,$rowNUM,1)<?/MIVAR>

	      <TD valign=top> 
              <?MIVAR> 
                <font size=2>
                  $(IF,$(XST,$return_rec),<A HREF=/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-do-select.apg&return_rec=$return_rec&new_oid=$OID>SELECT</A>)
                </font>

		$(IF,$(OR,$(XST,$accession),$(XST,$pubId)),$mtype_display:)
		<A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=$viewer&OID=$OID">$abbrev</A>
              <?/MIVAR>
	      </TD>
	  <?/MIBLOCK>


	  <?MIBLOCK COND="$(EC,$first_row,0)">
	    <!--   start new row and column   -->
	    <TR bgcolor="<?MIVAR>$row_color<?/MIVAR>">
	      <TD><font size=1> &nbsp;</font></TD>
	      <TD>&nbsp;</TD>
	  <?/MIBLOCK>

	<TD> 
	 <?MIVAR>$clone_sequence_type<?/MIVAR>
        </TD> 

	<TD> 
	 <?MIVAR>$vector_type_name<?/MIVAR>
        </TD> 

	<TD>
          <?MISQL SQL="select WebExplode(object,'&mapdetails_mode=mini&split=break&hide_empty=t&oID=$OID') from webPages where ID='aa-mappingdetail.apg';">$1<?/MISQL>
	</TD> 
       
        <?MIBLOCK COND="$(XST,$input_name)">   
        <TD>
	    <?MICOMMENT>$match_text: $(REPLACE,$match_name,$input_name,<b>$input_name</b>)<?/MICOMMENT>
	    <?MIVAR NAME=start_pos>$(POSITION,$(LOWER,$match_name),$(LOWER,$input_name))<?/MIVAR>
	    <?MIVAR NAME=str_length>$(STRLEN,$input_name)<?/MIVAR>
	    <?MIVAR>$match_text: $(SUBSTR,$match_name,1,$(-,$start_pos,1))<b>$(SUBSTR,$match_name,$start_pos,$str_length)</b>$(SUBSTR,$match_name,$(+,$start_pos,$str_length))		
	    <?/MIVAR>
        </TD>
        <?/MIBLOCK>
     </TR>

	  <?MIVAR name=$first_row>0<?/MIVAR>

	<!--    change row_color    -->
	<?MIBLOCK>
	  <?MIBLOCK COND="$(EC,$row_color,$highlight)">     
	    <?MIVAR name=$row_color>#FFFFFF<?/MIVAR>
	  <?MIELSE COND="$(EC,$row_color,#FFFFFF)">      
	    <?MIVAR name=$row_color>$highlight<?/MIVAR>
	  <?/MIBLOCK>
	<?/MIBLOCK>

	<!-- end form for map_marker -->         
      </FORM>

      <!-- end outer SQL -->  
     <?/MISQL>
  </TABLE>

  <BR>
  <Center>
  <Table width="70%" border="0">
    <tr>
      <td width="45%" align=right valign=top>&nbsp;

	<!-- to be used by walking windows -->
        <!-- want GET string as short as possible - append only when variable exists, buffer overflow may cause segmentation fault -->
        <?MIVAR name=comment>  Build array of user data  <?/MIVAR>
	<?MIVAR name=selector>MIval=aa-msegselect.apg&WINSIZE=$WINSIZE<?/MIVAR>
        <?MIVAR name=UserInput><?/MIVAR>
	<!--***-->
	<?MIBLOCK COND="$(NXST,$pubId)">
	<?MIVAR name=UserInput COND=$(XST,$lg)>$UserInput&lg=$lg<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$compare)>$UserInput&compare=$compare<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$return_rec)>$UserInput&return_rec=$return_rec<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$input_name)>$UserInput&input_name=$(URLENCODE,$input_name)<?/MIVAR>  
	<?MIVAR name=UserInput COND=$(XST,$sequence_type)>$UserInput&sequence_type=$sequence_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$vector_type)>$UserInput&vector_type=$vector_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$marker_type)>$UserInput&marker_type=$marker_type<?/MIVAR>
	<?MIVAR name=UserInput COND=$(XST,$input_acc)>$UserInput&input_acc=$(URLENCODE,$input_acc)<?/MIVAR>
        <?MIVAR name=UserInput COND=$(XST,$query_results)>$UserInput&query_results=$(URLENCODE,$query_results)<?/MIVAR>  
	
	<?MIELSE>
         <?MIVAR name=$UserInput>$UserInput&pubId=$pubId<?/MIVAR>
        <?/MIBLOCK>


	<!--- Return to the previous set of Rows --->
	<?MIBLOCK COND="$(>,$BEGIN,1)">

	  <?MIVAR>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$(-,$BEGIN,$WINSIZE)&BEGIN=$BEGIN&$selector$UserInput">Prev</A>&nbsp;&nbsp;&nbsp;&nbsp;<br>

	    <!-- If current not First Page, create link to first page. -->
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=1&BEGIN=1&$selector$UserInput">First Page</A>

	  <?/MIVAR>

	<?/MIBLOCK>

      </td>


      <!-- Calculate 3 pages before and 3 pages after current page. -->
      <?MIVAR name=$CURRENT>$(FIX,$(+,$(/,$BEGIN,$WINSIZE),1))<?/MIVAR>


      <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,3)),0)">
	<td valign=top>
	  <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,3))"> $(-,$CURRENT,3)</A> <?/MIVAR>
	</td>
      <?/MIBLOCK>

      <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,2)),0)">
	<td valign=top>
	  <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,2))"> $(-,$CURRENT,2)</A><?/MIVAR>
	</td>
      <?/MIBLOCK>

      <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,1)),0)">
	<td valign=top>
	  <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,1))"> $(-,$CURRENT,1)</A><?/MIVAR>
	</td>
      <?/MIBLOCK>

      <?MIBLOCK COND="$(>,$num_recs,$WINSIZE)">
	<td align=center valign=top>
	  <?MIVAR> $CURRENT <?/MIVAR>
	</td>
      <?/MIBLOCK>


      <?MIVAR COND=$(<=,$(+,$BEGIN,$(*,$WINSIZE,1)),$num_recs)>
	<td valign=top>
	  <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$END"> $(+,$CURRENT,1)</A>
	</td>
      <?/MIVAR>

      <?MIVAR COND=$(<=,$(+,$BEGIN,$(*,$WINSIZE,2)),$num_recs)>
	<td valign=top>
	  <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(+,$BEGIN,$(*,$WINSIZE,2))"> $(+,$CURRENT,2)</A>
	</td>
      <?/MIVAR>

      <?MIVAR COND=$(<=,$(+,$BEGIN,$(*,$WINSIZE,3)),$num_recs)>
	<td valign=top>
	  <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(+,$BEGIN,$(*,$WINSIZE,3))"> $(+,$CURRENT,3)</A>
	</td>
      <?/MIVAR>

      <td width="45%" align=left valign=top>&nbsp;

	<!--- Get the next set of Rows --->
	<?MIBLOCK COND="$(<=,$(+,$BEGIN,$WINSIZE),$num_recs)">
	  <?MIVAR>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$END&BEGIN=$BEGIN&$selector$UserInput">Next</A><br>
	  <?/MIVAR>


	  <!-- Calculate last page -->
	  <?MIVAR name=$START COND="$(=,$(MOD,$num_recs,$WINSIZE),0)">$(+,$(*,$(-,$(/,$num_recs,$WINSIZE),1),$WINSIZE),1)<?/MIVAR>

	  <?MIVAR name=$START COND="$(!=,$(MOD,$num_recs,$WINSIZE),0)">$(+,$(*,$(FIX,$(/,$num_recs,$WINSIZE)),$WINSIZE),1)<?/MIVAR>

	  <?MIVAR>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$START&$selector$UserInput">Last Page</A>
	  <?/MIVAR>
	<?/MIBLOCK>

	&nbsp;

      </td>
    </tr>
  </Table>
  </Center>

  <?/MIBLOCK> <!-- end # rows > 0 -->


 <?MISQL SQL="
  insert into msegselect_tmp_markers (mrkr_abbrev) values (NULL);
  drop table msegselect_tmp_markers;">
 <?/MISQL>


 <?/MIBLOCK> <!-- no simultanious name and acc search -->
<?/MIBLOCK><!-- xst query_result or xst pubId -->



<!----------------  Query Form -------------------------------------->
<?MIBLOCK COND="$(AND,$(NXST,$accession),$(NXST,$pubId))">   
  
  <?MISQL SQL="select WebExplode(object,'page=msegselect') from webPages where ID='aa-searchform.apg';">$1<?/MISQL>

<?/MIBLOCK> 



<?MIBLOCK COND="$(NXST,$accession)">
    <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpagefooter.apg';">$1<?/MISQL>
<?/MIBLOCK>

