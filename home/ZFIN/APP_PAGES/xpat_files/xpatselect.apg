<?MICOMMENT>

FILE:     xpatselect.apg
PREFIX:   xpatsel_

Query form and query result page for expression patterns.

This is called from at least these places:
1. From the home page, title bar, or jump_to.apg  In these cases the app page 
   is called with no search terms.
2. From pubview2.apg page via an href link.  In this case the publication 
   ID is passed in.
3. From itself, meaning the query form.  In this case, lots of variables
   can be set.  See below.
4. From anatdict.apg.  An anatomy item ID is passed in.
5. From anatomy_item.apg.  An anatomy item ID is passed in.
6. From markerselect.apg.  A gene name is passed in.

INPUT VARS:
  From pubview2.apg:
    pubId    the ZDB ID of a publication.  All expression patterns attributed
	     to this publication will be displayed, and the query form will 
	     not be displayed.
  From markerselect.apg
    query_results	Run query and display matching expression patterns
    gene_name		Abbrev of the gene to get expression patterns for.
			Causes search type to be set to 'equals'
			NOTE: Thought about passing in the gene ZDB ID instead 
			of the symbol.  However, there is no place on the 
			search form for gene ZDB ID.  Using the symbol allows 
			us to (almost) always get just the expression patterns 
			we want, and to prepopulate the search form with the 
			actual term used.
  From itself (xpatselect.apg):
    query_results	Run query and display matching expression patterns
    gene_name		Exists if user entered a gene/EST name
    searchtype          Should gene/EST name 'begins' with or 'contains' 
			gene_name.
    mutant		Exists if user entered a mutant/background string.
    mutsearchtype	Specifies if mutant name should 'begins' with or
			'contains' the string in mutant.
    author		Exists if user entered an author string
    authsearchtype	Specifies if the author should 'begins' with or
			'contains' the string in author.
    TA_selected_structures	  Exists if user entered any anatomical structures.
    xpatsel_processed_selected_structures Exists if user entered any anatomical structres.
					  Called from anatdict.apg & anatomy_item.apg

    include_substructures  	Possible values are 'checked' and '', I think.
    structure_bool	Possible values are 'and' (meaning every selected 
			structure) or 'or' (meaning any selected structure).  
    stage_start         starting stage of selected stage window.  Set to 
			first stage if user did not set it.
    stage_end		ending stage of selected stage window.  Set to 
			last stage if user did not set it.
    assay		Set to assay name if user specified one, otherwise "ANY"
    xpatsel_sortByDate  Exists if user requested output be sorted by date.
  From anatdict.apg and anatomy_item.apg
    query_results	If exists, means the page was called from itself.
    ?????

OUTPUT VARS:
  None.

OUTPUT:
  A list of expression patterns that meet the specified input criteria.

EFFECTS  
  Several session duration temporary tables may be created.

<?/MICOMMENT>

<?MIERROR>
  <?MIVAR COND=$(XST,$MI_SQL)>
    SQL: $MI_SQL<br><br>
  <?/MIVAR>

  Code:    $MI_ERRORCODE <br>
  State:   $MI_ERRORSTATE <br>
  Message: $MI_ERRORMSG <br>
<?/MIERROR>

<HTML>

<?MIVAR Name=page_name>$(IF,$(NXST,$query_results),ZFIN Search Expressions,ZFIN Expression Search Results)<?/MIVAR>

<?MIVAR><TITLE>$page_name</TITLE><?/MIVAR>
<SCRIPT>

function start_help() {
   top.zfinhelp=open("/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-xpatselect_help.apg","helpwindow","scrollbars=yes,toolbar=no,directories=no,menubar=no,status=no,resizable=yes,width=555,height=350");
}

function start_note() {
  top.zfinhelp=open("/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-xpatselect_note.apg","notewindow","scrollbars=no,toolbar=no,directories=no,menubar=no,status=no,resizable=yes,width=400,height=150");
}

function process_structures(list) {

  matchcomma = /\,/g;
  list = list.replace(matchcomma,"|");

  matchreturn = /\n/g;
  list = list.replace(matchreturn,",");

  matchmulticomma = /,{1,}/g;
  list = list.replace(matchmulticomma,",");

  matchfirstcomma = /^,/g;
  list = list.replace(matchfirstcomma,"");  

  matchlastcomma = /,$/g;
  list = list.replace(matchlastcomma,"");

  document.critform.xpatsel_processed_selected_structures.value = list;
}

function call_submit() {

  process_structures(document.critform.TA_selected_structures.value);

  if (document.critform.stage_start.selectedIndex > document.critform.stage_end.selectedIndex) {
    //swap it so that the earlier stage is first.. after all, the user isn't "wrong" in saying
    //that they want all the stages between Adult & Zygote instead of Zygote & Adult..

    tempindex = document.critform.stage_end.selectedIndex;
    document.critform.stage_end.selectedIndex = document.critform.stage_start.selectedIndex;
    document.critform.stage_start.selectedIndex = tempindex;
  }

  //remove double quotes
  document.critform.TA_selected_structures.value=document.critform.TA_selected_structures.value.replace(/"/g,"");
  document.critform.submit();
  return true;
}



function call_reset() {
  document.critform.gene_name.value = '';
  document.critform.author.value = '';
  document.critform.mutant.value = '';
  document.critform.stage_start.selectedIndex = 0;
  document.critform.stage_end.selectedIndex = document.critform.stage_end.options.length - 1;
  document.critform.assay.value=document.critform.assay[0].value;
  document.critform.TA_selected_structures.value = '';
  document.critform.include_substructures.checked = true;
  document.critform.structure_bool[0].checked = true;
  document.critform.searchtype.selectedIndex = 1;
  document.critform.mutsearchtype.selectedIndex = 1;
  document.critform.authsearchtype.selectedIndex = 1;
  document.critform.WINSIZE.value = 25;
  document.critform.xpatsel_sortByDate.checked = false;
}

</SCRIPT>


<?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpageheader.apg';">$1<?/MISQL>


<?MICOMMENT> 
  ============================================================================
  ==========  GET MIN AND MAX STAGES
  ============================================================================
<?/MICOMMENT>

<?MISQL SQL="
  select stg_zdb_id
    from stage
    where stg_hours_start = 
	  ( select min(stg_hours_start) 
	      from stage )
      and stg_name <> 'Unknown'; ">
  <?MIVAR NAME=$xpatsel_minStage>$1<?/MIVAR>
<?/MISQL>
<?MISQL SQL="
  select stg_zdb_id
    from stage
    where stg_hours_start = 
	  ( select max(stg_hours_start) 
	      from stage )
      and stg_name <> 'Unknown'; ">
  <?MIVAR NAME=$xpatsel_maxStage>$1<?/MIVAR>
<?/MISQL>

<?MICOMMENT>
  ============================================================================
  ==========  SET DEFAULT VALUES
  ============================================================================
			(these should match the javascript reset above)
<?/MICOMMENT>

<?MIVAR COND=$(NXST,$stage_start) NAME=$stage_start>$xpatsel_minStage<?/MIVAR>
<?MIVAR COND=$(NXST,$stage_end) NAME=$stage_end>$xpatsel_maxStage<?/MIVAR>
<?MIVAR COND=$(NXST,$assay) NAME=$assay>ANY<?/MIVAR>
<?MIVAR COND=$(NXST,$structure_bool) NAME=$structure_bool>and<?/MIVAR>

<?MICOMMENT>
  If this page is called from markerselect.apg then the exact 
  name of the thing we are looking for will be specifed, but the search type 
  will not be.  In these cases, set the search type to equals.
<?/MICOMMENT>
<?MIVAR COND=$(AND,$(XST,$gene_name),$(NXST,$searchtype)) NAME=$searchtype>equals<?/MIVAR>

<?MICOMMENT> This variable gets set to 't' if we want to force 0 results to show,
             initially, the only place that it can be set to 'true' is when an anatomy
	     item doesn't exist. <?/MICOMMENT>
<?MIVAR NAME="$xpatsel_anatomy_error_occured">f<?/MIVAR>


<?MICOMMENT> 
  ============================================================================
  ==========  CONVERT STRUCTURE NAMES TO ZDB_IDs, DISPLAY FEEDBACK
  ============================================================================
  If the user entered structures in the Anatomy text area, it will populate
  two variables.  The direct variable (TA_selected_structures) and via 
  javascript, xpatsel_processed_selected_structures, which has commas replaced with
  pipes, so that it can be comma seperated (webblade likes comma seperation,
  and not much else). 
  
  xpatselectanatverify.apg will handle this, xpatsel_processed_selected_structures
  goes in, anatomy_zdb_id_list and xpatsel_anatomy_error_occured come out.

  the output of this section is $anatomy_zdb_id_list & $xpatsel_anatomy_error_occured may 
  get set to 't'

<?/MICOMMENT>

<?MIBLOCK COND="$(AND,$(XST,$TA_selected_structures),$(XST,$xpatsel_processed_selected_structures))">

    <?MICOMMENT> pass in $xpatsel_processed_selected_structures, retrieve xpanatv_anatomy_zdb_id_list, 
                 xpanatv_anatomy_error_occured<?/MICOMMENT>
    <?MISQL SQL="
    select WebExplode(object, 'xpanatv_processed_selected_structures=$(URLENCODE,$xpatsel_processed_selected_structures)&xpanatv_anatomy_error_occured=$xpatsel_anatomy_error_occured')
      from webpages 
      where id = 'aa-xpatselectanatverify.apg';">
    $1
    <?/MISQL> <?MICOMMENT> returns xpanatv_anatomy_zdb_id_list & xpatanv_anatomy_error_occured <?/MICOMMENT>

    <?MIVAR NAME="$xpatsel_anatomy_error_occured">$xpanatv_anatomy_error_occured<?/MIVAR>

<?/MIBLOCK>

<?MICOMMENT>
  ============================================================================
  ==========  GET EXPRESSION PATTERNS FROM DATABASE
  ============================================================================

  Depending on from where this page was called, the code webexplodes different
  app pages to get the different query results.  The end result of all the app
  pages is that they populate a temp table with expression pattern ZDB IDs that
  meet whatever criteria this page was called with.  The temp table will also
  include the text that matched in the case of gene name or fish name searches.

  First create temp table if it does not already exist.  The temp table reuses
  the column names from expression_pattern.  This simplifies code in the 
  webexploded pages.
<?/MICOMMENT>

<?MISQL SQL="
  select dbinfo('sessionid') 
    from single;">
  <?MIVAR NAME=$xpatsel_session_id>$1<?/MIVAR>
  <?MIVAR NAME=$xpatselect_temp_match>$(CONCAT,xpatselect_temp_match_,$xpatsel_session_id)<?/MIVAR>
<?/MISQL>

<?MISQL SQL="
  execute function table_exists('$xpatselect_temp_match')">
  <?MISQL COND=$(EC,$1,f) SQL="
    create temp table $xpatselect_temp_match (
      xpat_zdb_id 		varchar(50),
      xpat_image_count          integer,
      xpat_ann_exist		boolean,
      xpat_matching_text 	varchar(255),
      xpat_matching_precedence	varchar(80),
      xpat_matching_significance integer,
      primary key (xpat_zdb_id)
    ) with NO LOG;">
  <?/MISQL>
<?/MISQL>

<?MICOMMENT>
  ============================================================================
  ==========  Invoke correct selection query/app page
  ============================================================================
<?/MICOMMENT>

<?MIBLOCK COND="$(XST,$pubId)">
  <?MICOMMENT> 
    Originally had this SQL in a separate app page.  However, it was the only 
    code in that app page, so I folded it back in here.
  <?/MICOMMENT>
  <?MISQL SQL="
    insert into $xpatselect_temp_match      
	( xpat_zdb_id, xpat_image_count, xpat_matching_text, 
	xpat_matching_precedence, xpat_matching_significance )
      select xpat_zdb_id, 
	     ( select count(*) 
		 from expression_pattern_image
		 where xpatfimg_xpat_zdb_id = xpat_zdb_id ),
	     NULL::varchar(255), NULL::varchar(80), NULL::integer
	from expression_pattern
	where xpat_source_zdb_id = '$pubId';">
  <?/MISQL>
  <?MISQL SQL="
	update $xpatselect_temp_match set xpat_ann_exist = 't'
			where xpat_zdb_id in (select xpatstg_xpat_zdb_id
				 	from expression_pattern_stage
			        	where xpatstg_comments is not null);">
  <?/MISQL>
  <?MISQL SQL="
	update $xpatselect_temp_match set xpat_ann_exist = 't'
			where xpat_zdb_id in (select xpatanat_xpat_zdb_id
				 	from expression_pattern_anatomy);">
  <?/MISQL>



<?MIELSE COND="$(AND,$(XST,$query_results),$(EC,$xpatsel_anatomy_error_occured,f))">
  <?MICOMMENT>
    Page Called from itself.  Pass any query form variables, if they exist,
    to the form handling page.
  <?/MICOMMENT>
  <?MIVAR>
    $(VECAPPEND,$xpatsel_queryVec,xpatselqry_resultTable=$xpatselect_temp_match)
    $(IF,$(XST,$gene_name),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_mrkrName=$(URLENCODE,$gene_name)))
    $(IF,$(XST,$searchtype),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_mrkrSearchType=$searchtype))
    $(IF,$(XST,$mutant),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_fishName=$(URLENCODE,$mutant)))
    $(IF,$(XST,$mutsearchtype),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_fishSearchType=$mutsearchtype))
    $(IF,$(XST,$author),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_author=$(URLENCODE,$author)))
    $(IF,$(XST,$authsearchtype),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_authorSearchType=$authsearchtype))
    <?MIBLOCK INDEX=$anat_id FOREACH=$xpanatv_anatomy_zdb_id_list>
      <?MIVAR> $(VECAPPEND,$xpatsel_queryVec,xpatselqry_anatomyZdbIdList=$anat_id) <?/MIVAR>
    <?/MIBLOCK>
    $(IF,$(XST,$include_substructures),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_includeSubstructures=$include_substructures))
    $(IF,$(XST,$structure_bool),$(VECAPPEND,$xpatsel_queryVec,xpatselqry_structureBool=$structure_bool))
    <?MIVAR COND="$(OR,$(NE,$stage_start,$xpatsel_minStage),$(NE,$stage_end,$xpatsel_maxStage))">
      $(VECAPPEND,$xpatsel_queryVec,xpatselqry_stageStart=$stage_start)
      $(VECAPPEND,$xpatsel_queryVec,xpatselqry_stageEnd=$stage_end)
    <?/MIVAR>
    <?MIVAR COND="$(NE,$assay,ANY)">
      $(VECAPPEND,$xpatsel_queryVec,xpatselqry_assay=$assay)
    <?/MIVAR>
    <?MIVAR NAME=$xpatsel_queryParams>$(SEPARATE,$xpatsel_queryVec,&)<?/MIVAR>
  <?/MIVAR>
  <?MISQL SQL="
    select WebExplode(object, '$xpatsel_queryParams')
      from webpages 
      where id = 'aa-xpatselectquery.apg';">
    $1
  <?/MISQL>

<?/MIBLOCK>

<?MICOMMENT>
  ============================================================================
  ==========  DISPLAY QUERY RESULTS
  ============================================================================

  Results, if there are any, are stored in the temp table.  Walk through the 
  results and show them.
<?/MICOMMENT>

<?MIBLOCK COND="$(AND,$(XST,$debug),$(EC,$debug,true))">
<?MICOMMENT>  ---- DEBUGGING ---- <?/MICOMMENT>
  <table border="0" align="center">
    <?MIBLOCK INDEX=$xpatsel_testIndex FROM=1 TO=$(VECSIZE,$xpatselqry_testCountVec)>
      <tr>
        <?MIVAR>
	  <td align="right">$xpatselqry_testCountVec[$xpatsel_testIndex]</td>
	  <td align="left">expression patterns retained after "$xpatselqry_testNameVec[$xpatsel_testIndex]" test.</td>
        <?/MIVAR>
      </tr>
    <?/MIBLOCK>
  </table>

<?/MIBLOCK>

<?MIBLOCK COND="$(OR,$(XST,$pubId),$(XST,$query_results))">
  <?MISQL SQL="
    select count(distinct mrkr_zdb_id)::integer
      from marker, expression_pattern xp, $xpatselect_temp_match match
      where mrkr_zdb_id = xp.xpat_gene_zdb_id
	and xp.xpat_zdb_id = match.xpat_zdb_id">
  <?/MISQL>
  <?MIVAR NAME=$xpatsel_nResults>$1<?/MIVAR>
  <table width=100% border=0>
    <tr>
      <td width=20%>&nbsp;</td>
      <td width=60% align=center>
        <font size="+1">Expression Pattern Search Results<br>
        <?MIVAR> 
	  (<b>$xpatsel_nResults</b> genes with expression)</font>
        <?/MIVAR>
      </td>
      <td width="20%" align="center">
        <a href=#modify>Modify Search</a>
        <!-- Insert a form with one button. Label button Your Input Welcome -->
        <?MISQL SQL="
	  select WebExplode(object,'') 
	    from webPages 
            where ID='aa-input_button_generic.apg';">
	  $1
	<?/MISQL>
      </td>
    </tr>
  </table>

  <?MIBLOCK COND="$(=,$xpatsel_nResults,0)">
    <?MICOMMENT>
      ============================================================================
      ==========  No results found
      ============================================================================
    <?/MICOMMENT>
    <p align=center>
    <b>No gene expression patterns were found for your search.</b>
    <br><br>
  <?MIELSE>
    <?MICOMMENT>
      ============================================================================
      ==========  Start table to show results in
      ============================================================================
    <?/MICOMMENT>
    <TABLE width="100%" border="0" cellspacing="0" cellpadding="3">
      <TR>
        <TH>&nbsp;</TH>
        <TH align="left">Gene symbol - name</TH>
	<TH align="left">Expression <font size="-1">(<a href="javascript:start_note();">current status</a>)</font></TH>
	<TH align="left">Publication(s)<?MIVAR COND=$(XST,$xpatsel_sortByDate)><br><font size="-1">(Release Date)</font><?/MIVAR></TH>
	<?MIBLOCK COND="$(OR,$(XST,$gene_name),$(XST,$mutant))">
      	  <TD align=left><b>Matching Text</b></TH>
        <?/MIBLOCK>
      </TR>

      <?MICOMMENT> Outer SQL contains WW, retrieves gene names. <?/MICOMMENT>
      <?MIVAR NAME=WINSIZE DEFAULT=25>$WINSIZE<?/MIVAR>
      <?MIVAR NAME=BEGIN DEFAULT=1>$START<?/MIVAR>

      <?MICOMMENT> DEFINITION OF RANGES <?/MICOMMENT>
      <?MIVAR NAME=BEGIN>$(IF,$(<,$BEGIN,1),1,$BEGIN)<?/MIVAR> 
      <?MIVAR NAME=END>$(+,$BEGIN,$WINSIZE)<?/MIVAR>

      <?MICOMMENT> EXECUTION: set row_color to grey <?/MICOMMENT>
      <?MIVAR name=$highlight><!--|HIGHLIGHT_COLOR|--><?/MIVAR>
      <?MIVAR name=$row_color>#FFFFFF<?/MIVAR>

      <?MICOMMENT>
	============================================================================
	==========  Get qualifying expression patterns
	============================================================================

	I originally wrote this code to use a single level of SQL, but then changed it
	to be use an inner and outer SQL.  With the one level SQL, each expression 
	pattern record was counted in the results.  With the 2 level SQL, each marker
	is counted and then (possibly) multiple expression pattern records are shown
	for each gene.

	This means that the record count shown on the page is not the number of 
	expression patterns, but rather the number of genes with expression patterns.
	This will probably work better with GELI expression patterns.
      <?/MICOMMENT>

      <?MICOMMENT> 
	The outer SQL is very different depending on whether or not we are 
	sorting by date.  This code will need to be reworked for GELI.
      <?/MICOMMENT>
      <?MIBLOCK COND=$(XST,$xpatsel_sortByDate)>
	<?MIVAR NAME=$xpatsel_geneSql>
	  select mrkr_zdb_id, mrkr_name, mrkr_abbrev, mrkr_abbrev_order,
		  match.xpat_matching_significance, 
		  max(xp.xpat_direct_submission_date) max_date
	    from marker, expression_pattern xp, $xpatselect_temp_match match
	    where mrkr_zdb_id = xp.xpat_gene_zdb_id
	      and xp.xpat_zdb_id = match.xpat_zdb_id
	    group by mrkr_zdb_id, mrkr_name, mrkr_abbrev, mrkr_abbrev_order,
		     match.xpat_matching_significance
	    order by max_date desc, xpat_matching_significance, mrkr_abbrev_order
	<?/MIVAR>
        <?MIVAR NAME=$xpatsel_xpatSortCols>xp.xpat_direct_submission_date desc, match.xpat_image_count desc, xpatassay_display_order<?/MIVAR>
      <?MIELSE>
	<?MIVAR NAME=$xpatsel_geneSql>
	  select distinct mrkr_zdb_id, mrkr_name, mrkr_abbrev, mrkr_abbrev_order,
			  match.xpat_matching_significance, NULL::date
	    from marker, expression_pattern xp, $xpatselect_temp_match match
	    where mrkr_zdb_id = xp.xpat_gene_zdb_id
	      and xp.xpat_zdb_id = match.xpat_zdb_id
	    order by xpat_matching_significance, mrkr_abbrev_order
	<?/MIVAR>
        <?MIVAR NAME=$xpatsel_xpatSortCols>match.xpat_image_count desc, xpatassay_display_order<?/MIVAR>
      <?/MIBLOCK>

      <?MICOMMENT>
        ============================================================================
        ==========  Outer loop - one line per gene
        ============================================================================
      <?/MICOMMENT>
      <?MIVAR NAME=$xpatsel_prevPrintedGeneId><?/MIVAR>	
      <?MISQL WINSTART=$BEGIN WINSIZE=$WINSIZE SQL="$xpatsel_geneSql">
	<?MIVAR NAME=$xpatsel_gene_zdb_id>$1<?/MIVAR>
	<?MIVAR NAME=$xpatsel_gene_name>$2<?/MIVAR>
	<?MIVAR NAME=$xpatsel_gene_abbrev>$3<?/MIVAR>
	<?MIVAR>$(UNSETVAR,$xpatsel_noImagesXpats)<?/MIVAR>
	<?MIVAR NAME=$row_color>$(IF,$(EC,$row_color,#FFFFFF),$highlight,#FFFFFF)<?/MIVAR>

	<?MICOMMENT>
	  ============================================================================
	  ==========  Inner loop, one iteration per expression pattern
	  ============================================================================

	  However, the display is more complicated
	  if the xpat has images then
	    display it on its own line.
          else
	    group them together by assay type.  Show one line per assay type

	<?/MICOMMENT>
	<?MIVAR NAME=$xpatsel_prevPrintedXpatId><?/MIVAR>
	<?MIVAR NAME=$xpatsel_noImagesCount>0<?/MIVAR>	
	<?MISQL SQL="
	  select xp.xpat_zdb_id, xp.xpat_probe_zdb_id, 
		 xp.xpat_direct_submission_date,
		 xpatassay_name, xpatassay_display_order, 
		 match.xpat_image_count,
		 match.xpat_matching_text, match.xpat_matching_precedence,
		 match.xpat_ann_exist, xp.xpat_source_zdb_id
	    from expression_pattern xp, $xpatselect_temp_match match,
		 expression_pattern_assay
	    where xp.xpat_gene_zdb_id = '$xpatsel_gene_zdb_id'
	      and xp.xpat_zdb_id = match.xpat_zdb_id
	      and xp.xpat_assay_name = xpatassay_name
	    order by $xpatsel_xpatSortCols">
	  <?MIVAR NAME=$xpatsel_xpat_zdb_id>$1<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_xpat_probe_zdb_id>$2<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_xpat_direct_submission_date>$3<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_assay_name>$4<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_assay_display_order>$5<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_image_count>$6<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_matching_text>$7<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_matching_precedence>$8<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_ann_exist>$9<?/MIVAR>
	  <?MIVAR NAME=$xpatsel_xpat_source_zdb_id>$10<?/MIVAR>

	  <?MIBLOCK COND=$(OR,$(!=,$xpatsel_image_count,0),$(EC,$xpatsel_ann_exist,t))>
	    <?MICOMMENT>
	      ============================================================================
	      ==========  We have images, Call row display page
	      ============================================================================
	    <?/MICOMMENT>
            <?MIVAR NAME=$xpatsel_probe_name_link_text><?/MIVAR>
            <?MISQL COND="$(NE,$xpatsel_xpat_probe_zdb_id,NULL)" SQL="
              select mrkr_name
                from marker
                where mrkr_zdb_id = '$xpatsel_xpat_probe_zdb_id'">
              <?MIVAR NAME=$xpatsel_probe_name_link_text>$1:<?/MIVAR>
            <?/MISQL>

	    <?MIVAR>
	      $(UNSETVAR,$xpatsel_rowVec)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_color=$row_color)

	      $(IF,$(NE,$xpatsel_prevPrintedGeneId,$xpatsel_gene_zdb_id),
		$(VECAPPEND,$xpatsel_rowVec,xpatselrow_showGene=exists))
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneZdbId=$xpatsel_gene_zdb_id)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneAbbrev=$xpatsel_gene_abbrev)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneName=$(URLENCODE,$xpatsel_gene_name))

	      $(IF,$(NE,$xpatsel_prevPrintedXpatId,$xpatsel_xpat_zdb_id),
		$(VECAPPEND,$xpatsel_rowVec,xpatselrow_showXpat=exists))
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_xpatZdbId=$xpatsel_xpat_zdb_id)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_xpatLinkText=$xpatsel_probe_name_link_text $xpatsel_assay_name)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_xpatSourceZdbId=$xpatsel_xpat_source_zdb_id)
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_imageCount=$xpatsel_image_count)

	      $(IF,$(AND,$(XST,$xpatsel_sortByDate),$(NE,$xpatsel_xpat_direct_submission_date,NULL)),
		  $(VECAPPEND,$xpatsel_rowVec,xpatselrow_directSubmissionDate=$xpatsel_xpat_direct_submission_date))
	      $(IF,$(NE,$xpatsel_matching_text,NULL),
		  $(VECAPPEND,$xpatsel_rowVec,xpatselrow_matchingTextCol=exists))
	      $(IF,$(AND,$(NE,$xpatsel_prevPrintedGeneId,$xpatsel_gene_zdb_id),$(NE,$xpatsel_matching_text,NULL)),
		  $(VECAPPEND,$xpatsel_rowVec,xpatselrow_matchingText=$(URLENCODE,$xpatsel_matching_precedence): $(URLENCODE,$xpatsel_matching_text)))

	      <?MIVAR NAME=$xpatsel_rowParams>$(SEPARATE,$xpatsel_rowVec,&)<?/MIVAR>
	    <?/MIVAR>
	    <?MISQL SQL="
	      select WebExplode(object, '$xpatsel_rowParams')
		from webpages 
		where id = 'aa-xpatselectrowdisplay.apg';">
	      $1
	    <?/MISQL>
	    <?MIVAR NAME=$xpatsel_prevPrintedXpatId>$xpatsel_xpat_zdb_id<?/MIVAR>
	    <?MIVAR NAME=$xpatsel_prevPrintedGeneId>$xpatsel_gene_zdb_id<?/MIVAR>
	  <?MIELSE>
	    <?MICOMMENT>
	      ============================================================================
	      ==========  We don't have images, Accumulate information.
	      ============================================================================
	    <?/MICOMMENT>
	    <?MIVAR NAME=$xpatsel_noImagesCount>$(+,$xpatsel_noImagesCount,1)<?/MIVAR>
	    <?MIVAR>$(VECAPPEND,$xpatsel_noImagesXpats,$xpatsel_xpat_zdb_id)<?/MIVAR>

          <?/MIBLOCK> <?MICOMMENT> end if xpat has images or not <?/MICOMMENT>

        <?/MISQL> <?MICOMMENT> end Inner loop - one iteration per xpat <?/MICOMMENT>

	<?MIBLOCK COND=$(NE,$xpatsel_noImagesCount,0)>
	  <?MICOMMENT>
	    ============================================================================
	    ==========  We had xpats without images.  Print 1 line for all of them.
	    ============================================================================
	  <?/MICOMMENT>

	  <?MIVAR>
	    $(UNSETVAR,$xpatsel_rowVec)
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_color=$row_color)

	    $(IF,$(NE,$xpatsel_prevPrintedGeneId,$xpatsel_gene_zdb_id),
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_showGene=exists))
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneZdbId=$xpatsel_gene_zdb_id)
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneAbbrev=$xpatsel_gene_abbrev)
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_geneName=$(URLENCODE,$xpatsel_gene_name))

	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_showXpat=exists)
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_xpatLinkText=$xpatsel_noImagesCount "assay(s) without images/annotation")
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_imageCount=0)
	    $(VECAPPEND,$xpatsel_rowVec,xpatselrow_noImagesXpats=$(SEPARATE,$xpatsel_noImagesXpats,.))
            

	    $(IF,$(NE,$xpatsel_matching_text,NULL),
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_matchingTextCol=exists))
	    $(IF,$(AND,$(NE,$xpatsel_prevPrintedGeneId,$xpatsel_gene_zdb_id),$(NE,$xpatsel_matching_text,NULL)),
	      $(VECAPPEND,$xpatsel_rowVec,xpatselrow_matchingText=$(URLENCODE,$xpatsel_matching_precedence): $(URLENCODE,$xpatsel_matching_text)))

	    <?MIVAR NAME=$xpatsel_rowParams>$(SEPARATE,$xpatsel_rowVec,&)<?/MIVAR>
	  <?/MIVAR>
	  <?MISQL SQL="
	    select WebExplode(object, '$xpatsel_rowParams')
	      from webpages 
	      where id = 'aa-xpatselectrowdisplay.apg';">
	    $1
	  <?/MISQL>
	  <?MIVAR NAME=$xpatsel_prevPrintedGeneId>$xpatsel_gene_zdb_id<?/MIVAR>
	<?/MIBLOCK> <?MICOMMENT> end we had xpats without images <?/MICOMMENT>
      <?/MISQL> <?MICOMMENT> end Outer loop - one row per gene <?/MICOMMENT>
    </TABLE> <?MICOMMENT> end query results table <?/MICOMMENT>

    <?MICOMMENT>
      ============================================================================
      ==========  WALKING WINDOWS
      ============================================================================

      Build array of user data

      to be used by walking windows and nav tile page_id
      javascript of nav tile logic can not deal with preformed string 
      using urlencode so save non-urlencoded string for use by nav tile
      others will be appended
      want GET string as short as possible - append only when variable 
      exists, buffer overflow may cause segmentation fault
    <?/MICOMMENT>

    <?MIVAR name=selector>MIval=aa-xpatselect.apg&WINSIZE=$WINSIZE<?/MIVAR>
    <?MIVAR name=$UserInput><?/MIVAR>
    <?MIBLOCK COND="$(XST,$pubId)">
      <?MIVAR name=$UserInput>$UserInput&pubId=$pubId<?/MIVAR>
    <?MIELSE>
      <?MIVAR name=$UserInput COND=$(XST,$gene_name)>$UserInput&gene_name=$(URLENCODE,$gene_name)<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$mutant)>$UserInput&mutant=$(URLENCODE,$mutant)<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$author)>$UserInput&author=$(URLENCODE,$author)<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$assay)>$UserInput&assay=$(URLENCODE,$assay)<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$searchtype)>$UserInput&searchtype=$searchtype<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$mutsearchtype)>$UserInput&mutsearchtype=$mutsearchtype<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$authsearchtype)>$UserInput&authsearchtype=$authsearchtype<?/MIVAR>
      <?MIVAR name=$UserInput>$UserInput&stage_start=$stage_start<?/MIVAR>
      <?MIVAR name=$UserInput>$UserInput&stage_end=$stage_end<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$structure_bool)>$UserInput&structure_bool=$structure_bool<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$query_results)>$UserInput&query_results=$query_results<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$include_substructures)>$UserInput&include_substructures=$include_substructures<?/MIVAR>
      <?MIVAR name=UserInput COND=$(XST,$TA_selected_structures)>$UserInput&TA_selected_structures=$(URLENCODE,$TA_selected_structures)<?/MIVAR>
      <?MIVAR name=UserInput COND=$(XST,$xpatsel_processed_selected_structures)>$UserInput&xpatsel_processed_selected_structures=$(URLENCODE,$xpatsel_processed_selected_structures)<?/MIVAR>
      <?MIVAR name=$UserInput COND=$(XST,$xpatsel_sortByDate)>$UserInput&xpatsel_sortByDate=$xpatsel_sortByDate<?/MIVAR>
      
    <?/MIBLOCK>
        

    <Center>
    <Table width="70%" border="0">
      <tr>
        <td width="45%" align=right valign=top>&nbsp;
	  <!--- Return to the previous set of Rows --->
	  <?MIBLOCK COND="$(>,$BEGIN,1)">
	    <?MIVAR>
	      <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$(-,$BEGIN,$WINSIZE)&BEGIN=$BEGIN&$selector$UserInput">Prev</A>&nbsp;&nbsp;&nbsp;&nbsp;<br>
	      <!-- If current not First Page, create link to first page. -->
	      <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=1&BEGIN=1&$selector$UserInput">First Page</A>
	    <?/MIVAR>
	  <?/MIBLOCK>
	</td>


        <!-- Calculate 3 pages before and 3 pages after current page. -->
        <?MIVAR name=$CURRENT>$(FIX,$(+,$(/,$BEGIN,$WINSIZE),1))<?/MIVAR>
        <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,3)),0)">
          <td valign=top>
	    <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,3))"> $(-,$CURRENT,3)</A> <?/MIVAR>
	  </td>
        <?/MIBLOCK>

        <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,2)),0)">
	  <td valign=top>
	    <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,2))"> $(-,$CURRENT,2)</A><?/MIVAR>
	  </td>
        <?/MIBLOCK>

        <?MIBLOCK COND="$(>=,$(-,$BEGIN,$(*,$WINSIZE,1)),0)">
	  <td valign=top>
	    <?MIVAR><A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(-,$BEGIN,$(*,$WINSIZE,1))"> $(-,$CURRENT,1)</A><?/MIVAR>
	  </td>
        <?/MIBLOCK>

        <?MIBLOCK COND="$(>,$xpatsel_nResults,$WINSIZE)">
	  <td align=center valign=top>
	    <?MIVAR>  $CURRENT <?/MIVAR>
	  </td>
        <?/MIBLOCK>

        <?MIVAR COND="$(<=,$(+,$BEGIN,$(*,$WINSIZE,1)),$xpatsel_nResults)">
	  <td valign=top>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$END"> $(+,$CURRENT,1)</A>
	  </td>
        <?/MIVAR>

        <?MIVAR COND="$(<=,$(+,$BEGIN,$(*,$WINSIZE,2)),$xpatsel_nResults)">
	  <td valign=top>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(+,$BEGIN,$(*,$WINSIZE,2))"> $(+,$CURRENT,2)</A>
	  </td>
        <?/MIVAR>

        <?MIVAR COND="$(<=,$(+,$BEGIN,$(*,$WINSIZE,3)),$xpatsel_nResults)">
	  <td valign=top>
	    <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?$selector$UserInput&START=$(+,$BEGIN,$(*,$WINSIZE,3))"> $(+,$CURRENT,3)</A>
	  </td>
        <?/MIVAR>

        <td width="45%" align=left valign=top>&nbsp;
          <!--- Get the next set of Rows --->
	  <?MIBLOCK COND="$(<=,$(+,$BEGIN,$WINSIZE),$xpatsel_nResults)">
	    <?MIVAR>
	      <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$END&BEGIN=$BEGIN&$selector$UserInput">Next</A><br>
	    <?/MIVAR>

	    <!-- Calculate last page -->
	    <?MIVAR name=$START COND="$(=,$(MOD,$xpatsel_nResults,$WINSIZE),0)">$(+,$(*,$(-,$(/,$xpatsel_nResults,$WINSIZE),1),$WINSIZE),1)<?/MIVAR>
	    <?MIVAR name=$START COND="$(!=,$(MOD,$xpatsel_nResults,$WINSIZE),0)">$(+,$(*,$(FIX,$(/,$xpatsel_nResults,$WINSIZE)),$WINSIZE),1)<?/MIVAR>
	    <?MIVAR>
	      <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?START=$START&$selector$UserInput">Last Page</A>
	    <?/MIVAR>
	  <?/MIBLOCK>
        </td>
      </tr>
    </table>  <?MICOMMENT> end walking windows table <?/MICOMMENT>

  <?/MIBLOCK> <?MICOMMENT> end if results / no results <?/MICOMMENT>
  <?MICOMMENT> Done with match table, delete results <?/MICOMMENT>
  <?MISQL SQL="
    delete from $xpatselect_temp_match">
  <?/MISQL>

<?/MIBLOCK> <?MICOMMENT> End if pubId or queryResults exists <?/MICOMMENT>




<?MICOMMENT>
  ============================================================================
  ==========  QUERY FORM
  ============================================================================
<?/MICOMMENT>

<?MIBLOCK COND="$(NXST,$pubId)">
  <table border=0 width=100% cellpadding=3 cellspacing=0>
    <tr>
      <td bgcolor="<!--|SIDEBAR_COLOR|-->" width=70%>
         &nbsp;&nbsp;

	<?MIBLOCK COND="$(NXST,$query_results)">
          <font size="+1"><b>Search for Gene Expression Data </b></font>
	<?MIELSE>
          <a name=modify></a><b>Modify your search.</b>
	<?/MIBLOCK>

      </td>

      <td bgcolor="<!--|SIDEBAR_COLOR|-->" align=right>
        <!-- Insert a form with one button. Label button Your Input Welcome -->
        <?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-input_button_generic.apg';">$1<?/MISQL>
      </td>
    </tr>
  </table>

  <form name=critform 
        method=post
        action="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->">
    <input type=hidden name=MIval value=aa-xpatselect.apg>
    <input type=hidden name=query_results value="exist">
    <input type=hidden name=START value="0">

    <?MIVAR COND="$(NXST,$stage_start)" NAME=$stage_start>$xpatsel_minStage<?/MIVAR>
    <?MIVAR COND="$(NXST,$stage_end)" NAME=$stage_end>$xpatsel_maxStage<?/MIVAR>
    <?MIVAR COND="$(NXST,$assay)" NAME=$assay>ANY<?/MIVAR>
    <table border=0 width=100% cellpadding=3 cellspacing=0>
      <?MIVAR>
	<tr>
	  <td nowrap>

	    <!-- gene name -->

	    <FONT size=2><B>Gene/EST</B></FONT>

	    <SELECT name=searchtype>
	      <option value=begins $(IF,$(AND,$(XST,$searchtype),$(EC,$searchtype,begins)),SELECTED)>Name begins with
	      <option value=contains $(IF,$(OR,$(NXST,$searchtype),$(EC,$searchtype,contains)),SELECTED)>Name contains
	    </select>
	    <input type=text name=gene_name size=30
		   onKeyDown="
		     k = (navigator.appName == 'Netscape') ? event.which : window.event.keyCode;
		     if (k == 13 ) { 
		       call_submit(); 
		     }  "  value="$(IF,$(XST,$gene_name),$gene_name)"  >
	    <!-- end gene name -->
	  </td>
	  <td rowspan=2>
	    <!-- stage -->
	    <FONT size=2><B> Between stages:</B> <br>
              <?MICOMMENT>the Unknown stage will only be used in AO, thus that should not 
                          be an option on xpatselect page.
              <?/MICOMMENT>
	      <SELECT NAME="stage_start" SIZE=1>
		<?MISQL SQL="select stg_name, stg_hours_start, stg_hours_end, stg_zdb_id
			       from stage
			      where stg_name <> 'Unknown'	
			      order by stg_hours_start, stg_hours_end desc;">
		  <OPTION $(IF,$(EC,$stage_start,$4),SELECTED) VALUE="$4"> $1 
		<?/MISQL>
	      </SELECT>
	      <b>&</b><br>
	      <SELECT NAME="stage_end" SIZE=1>
		<?MISQL SQL="
		  	select stg_name, stg_hours_start, stg_hours_end, stg_zdb_id
			  from stage
			 where stg_name <> 'Unknown'	
			order by stg_hours_start, stg_hours_end desc">
		  <OPTION $(IF,$(EC,$stage_end,$4), SELECTED) VALUE="$4")> $1 
		<?/MISQL>
	      </SELECT>
	    </FONT>
	    <br><a href="http://zfin.org/zf_info/zfbook/stages/index.html">Developmental Staging Series</a>
	    <!-- end stage -->
	  </td>
	</tr>
	<tr>
	  <td>
	    <!-- begin mutant -->
	    <FONT size=2><B>Mutant Background</B></FONT>
	      <SELECT name=mutsearchtype>
		<option value=begins $(IF,$(AND,$(XST,$mutsearchtype),$(EC,$mutsearchtype,begins)),SELECTED)>Name begins with
		<option value=contains $(IF,$(OR,$(NXST,$mutsearchtype),$(EC,$mutsearchtype,contains)),SELECTED)>Name contains
	      </SELECT>
	      <INPUT type=text name=mutant size=20
		     onKeyDown="
		       k = (navigator.appName == 'Netscape') ? event.which : window.event.keyCode;
		       if (k == 13 ) { call_submit(); }  " value="$(IF,$(XST,$mutant),$mutant)">
	      <!-- end mutant -->
	    </FONT>
	  </td>
	</tr>
	<tr>
	  <td>
	    <!-- begin author -->
	    <FONT size=2><B>Author</B></FONT>
	      <SELECT name=authsearchtype>
		<option value=begins $(IF,$(AND,$(XST,$authsearchtype),$(EC,$authsearchtype,begins)),SELECTED)>First Author begins with
		<option value=contains $(IF,$(OR,$(NXST,$authsearchtype),$(EC,$authsearchtype,contains)),SELECTED)>Name contains
	      </SELECT>
	      <input type=text name=author size=28  onKeyDown="
		     k = (navigator.appName == 'Netscape') ? event.which : window.event.keyCode;
		     if (k == 13 ) { call_submit(); }" value="$(IF,$(XST,$author),$author)">
	    </FONT>
	    <!-- end author -->
	  </td>
	  <td>
	    <!-- begin assay type -->
	    <FONT size=2><B>Assay Type</B></FONT>
	      <SELECT NAME=assay>
		<option <?MIVAR COND="$(EC,$assay,ANY)">SELECTED<?/MIVAR> value=ANY>ANY
		<?MISQL SQL="
		  select distinct xpat_assay_name, xpatassay_display_order
		    from expression_pattern_assay, expression_pattern
		    where xpatassay_name = xpat_assay_name
		    order by xpatassay_display_order;">
		  <OPTION $(IF,$(EC,$assay,$1),SELECTED) value='$1'>$1
		<?/MISQL>
	      </SELECT>
	    </FONT>
	    <!-- end assay type -->
	  </td>
	</tr>
      <?/MIVAR>
      <tr>

        <?MICOMMENT> <!--- new selected structures textarea ---> <?/MICOMMENT>

        <TD colspan=2> 
	  <TABLE border=0 bgcolor="#EEEEEE"> 
            <TR>
	      <TD colspan=2>
		<span style="float: left;">
                  <FONT size=2><B>Anatomy</B></FONT>
                </span>
                <span style="float: right;">
                  <FONT size="-1">[<I>Enter one anatomical term per line</I>]</FONT>
                </span>

	     </TD>
	     </TR>
	     <TR>
	     <TD>
	        <TEXTAREA cols="30" rows="5" name="TA_selected_structures" onChange="process_structures(document.critform.TA_selected_structures.value);"><?MIVAR COND="$(XST,$TA_selected_structures)">$TA_selected_structures<?/MIVAR></TEXTAREA>

	        <input type="hidden" name="xpatsel_processed_selected_structures" <?MIVAR COND=$(XST,$xpatsel_processed_selected_structures)>value=$xpatsel_processed_selected_structures<?/MIVAR>>

	 	<br>
		<FONT SIZE=-1>
		  <A HREF="/<!--|WEBDRIVER_PATH_FROM_ROOT|-->?MIval=aa-anatdict.apg&mode=search"><B>Search</B> the Anatomical Dictionary</A>
		</FONT>
	      </TD> <?MICOMMENT> <!--- end new selected structures textarea ---> <?/MICOMMENT>
	      <TD>
		<?MICOMMENT>
		  this bit is sneaky, basically, this means that if you're opening the page
		  for the first time and the variable is empty, then create it - but if
		  the page has been submitted and the variable is empty, then it's supposed
		  to be, and we wanna leave it that way.
		<?/MICOMMENT>
		<FONT size=-1>
		  <?MIBLOCK COND="$(AND,$(NXST,$include_substructures),$(NXST,$query_results))">
		    <?MIVAR NAME="include_substructures">checked<?/MIVAR>
		  <?/MIBLOCK>

	          <input type=checkbox name="include_substructures" value="checked" <?MIVAR> $(IF,$(AND,$(XST,$include_substructures),$(EC,$include_substructures,checked)),checked="checked") <?/MIVAR> >  Include substructures <br>

		  <?MIVAR COND="$(NXST,$structure_bool)" NAME="structure_bool">and<?/MIVAR>

	          <b>Return data for genes<br>expressed in:</b> <br>
		  <input type="radio" name="structure_bool" value="and" <?MIVAR>$(IF,$(EC,$structure_bool,and),checked="checked")<?/MIVAR> >
	          <b>Every</b> term entered <br>
		  

		  <input type="radio" name="structure_bool" value="or"  <?MIVAR>$(IF,$(EC,$structure_bool,or),checked="checked")<?/MIVAR> > 
	          <b>Any</b> term entered 
		</FONT>
	      </TD>
	    </TR>
	  </TABLE>
        </TD>
      </TR>

      <TR>
	<TD class="resultcount">
	  Display results in groups of 
	  <?MIVAR><input type="text" name="WINSIZE" size="3" onChange='document.critform.START.value = "";' $(IF,$(XST,$WINSIZE),value='$WINSIZE',value="25")>.<?/MIVAR>
	  <?MIBLOCK COND="$(AND,$(NOT,$(ISNULL,$WINSIZE)),$(XST,$WINSIZE))">
	    <?MIVAR> 
	      <SCRIPT> 
		document.critform.WINSIZE.value = "$WINSIZE" 
	      </SCRIPT>
	    <?/MIVAR> 
	  <?/MIBLOCK> 
	</TD>

	<TD>
          <input type="checkbox" name="xpatsel_sortByDate" value="sortByDate" <?MIVAR COND=$(XST,$xpatsel_sortByDate)> checked <?/MIVAR> >
	  Sort by release date
	</TD>	
      </TR>
      <tr>
	<td colspan=3 bgcolor=<!--|SIDEBAR_COLOR|--> align=right> 
	
	  <input type=button value=Search onClick="call_submit();">
	  <input type=button value=Reset onClick="call_reset();">

        </td>
      </tr>
    </table>
  </form>
<?/MIBLOCK> <!--*** end nxst pubId -->

<?MICOMMENT>
<SCRIPT LANGUAGE="JavaScript1.1">
  function keyDown(DnEvents) { 

     t = (navigator.appName == "Netscape") ? DnEvents.target : window.event.formElement.formElement;
     alert('formElement: ' + t);
     if (t != document.critform.TA_selected_structures) {
       k = (navigator.appName == "Netscape") ? DnEvents.which : window.event.keyCode;
       if (k == 13 ) { 
         call_submit();
       }
     }
  }
document.onkeydown = keyDown; 
if (navigator.appName == "Netscape") document.captureEvents(Event.KEYDOWN|Event.KEYUP);
</SCRIPT>
<?/MICOMMENT>

<?MISQL SQL="select WebExplode(object,'') from webPages where ID='aa-htmlpagefooter.apg';">$1<?/MISQL>
