
<?MICOMMENT>

FILE:     xpatselectquery.apg
PREFIX:   xpaselqry_
Queries the database for expression experiement figures that meet the criteria
specified by a user in xpatselect.apg.  The page is webexploded by
xpatselect.apg.

This populates the temp table named by xpatselqry_resultTable,
with a list of expression experiments and supporting figures.
For certain searches, we also return the text that caused the record
to match the search.

INPUT VARS:
  xpatselqry_resultTable        Name of the temp table to put matching 
				expression experiment figures in.  This table 
                                is the
				output of this page.  See above for more.
  xpatselqry_geneName		Exists if user entered a gene name
  xpatselqry_geneSearchType  	Should gene name 'begins' with or 'contains' 
				or 'equals'

  xpatselqry_geneZdbId		Think of it like a super duper equals search.
				If this variable comes in, we can immediately
				slim the query down to just xpatex records
				that match this very gene.

  xpatselqry_probeName		Exists if the user entered a probe name
  xpatselqry_probeSearchType	Should probe name be 
                                'begins' / 'contains' / 'equals' 

  xpatselqry_genoName		Exists if user entered a mutant/background string.
  xpatselqry_genoSearchType	Specifies if mutant name should 'starts' with or
				'contains' the string in mutant.

  xpatselqry_genoZdbId		Exists if called from genotype page.
  xpatselqry_MOgene		Exists if user entered a MO knockdown string.
  xpatselqry_MOsearchtype	Specifies if gene name should 'begins' with or
				'contains' the string.
  xpatselqry_author		Exists if user entered an author string
  xpatselqry_authorSearchType	Specifies if the author should 'begins' with or
				'contains' the string in author 
  xpatselqry_anatomyZdbIdList	Exists if user entered any anatomical structures.

  xpatselqry_includeSubstructures  	Possible values are 'checked' and '', I think.
  xpatselqry_structureBool	Possible values are 'and' (meaning every selected 
				structure) or 'or' (meaning any selected structure).  
  xpatselqry_stageStart		Exists if user specified a stage window.
				starting stage of selected stage window
  xpatselqry_stageEnd		Exists if user specified a stage window.
				ending stage of selected stage window.
  xpatselqry_assay		Exists if user specified and assay type.
  xpatselqry_jtype		Exists if user wants to constrain to just published
				or direct submission xpat records.
  xpatselqry_imagesOnly		Exists if user wants to constrain to figures
				with images only.
  xpatselqry_recentRecords	Exists if user wants to constrain to records that are
				new within the specified number of days.  For direct
				submission records, it's the direct submission date,
				for published data, it's the date that curation is closed.

OUTPUT VARS:
  xpatselqry_matchedText	This variable will start out not existing, if
				a query runs that causes text to get matched,
				the piece of text entered into the field will
				be stored here (for whichever field, gene name,
				probe name, genotype or author, so far).  If this
				variable exists when any of those querries
				starts, the query will just pass on matching
				text columns instead of re-filling them.
				(which means that the order of the queries
				implies the relative importance of them
				showing up in the matching text column)
  xpatselqry_matchedTextSearchType	'contains' / 'begins' / 'equals' for above

   edited on 10th april 2008 to accomodate EFG's: (Prita)
OUTPUT:
  This file does not produce any HTML.

EFFECTS  
  The table named by xpatselqry_resultTable contains information about matching
  expression experiments, their supporting figures, and matching text if 
  appropriate.

  Also, several other temp tables, that are specific to this app page may
  have been created.  Those temp tables will be empty.

DEBUGGING:
  This app page has support for $debug_sql and $debug_timing.

<?/MICOMMENT>

<?MIERROR>
  <?MIVAR COND=$(XST,$MI_SQL)>
    SQL: $MI_SQL<br><br>
  <?/MIVAR>

  Code:    $MI_ERRORCODE <br>
  State:   $MI_ERRORSTATE <br>
  Message: $MI_ERRORMSG <br>
<?/MIERROR>

<?MICOMMENT>
  <?MIVAR NAME=debug_timing>t<?/MIVAR>
  <?MIVAR NAME=debug_sql>t<?/MIVAR>
<?/MICOMMENT>

<?MISQL COND="$(XST,$debug_timing)" SQL="
  execute function get_time()">
  <br>$1 Starting query page
<?/MISQL>

<?MICOMMENT> 
   -------------------------------------
   -----   Escape single quotes
   ------------------------------------
<?/MICOMMENT>
<?MIVAR COND="$(XST,$xpatselqry_geneName)" NAME=$xpatselqry_geneName>$(REPLACE,$xpatselqry_geneName,','')<?/MIVAR> 
<?MIVAR COND="$(XST,$xpatselqry_probeName)" NAME=$xpatselqry_probeName>$(REPLACE,$xpatselqry_probeName,','')<?/MIVAR>
<?MIVAR COND="$(XST,$xpatselqry_genoName)" NAME=$xpatselqry_genoName>$(REPLACE,$xpatselqry_genoName,','')<?/MIVAR> 
<?MIVAR COND="$(XST,$xpatselqry_author)" NAME=$xpatselqry_author>$(REPLACE,$xpatselqry_author,','')<?/MIVAR> 
<?MIVAR COND="$(XST,$xpatselqry_MOgene)" NAME=$xpatselqry_MOgene>$(REPLACE,$xpatselqry_MOgene,','')<?/MIVAR> 

<?MICOMMENT> 
    -------------------------------------
    ------ Get session id
    -------------------------------------
<?/MICOMMENT>

<?MISQL SQL="
  select dbinfo('sessionid') 
    from single;">
  <?MIVAR NAME=$xpatselqry_session_id>$1<?/MIVAR>
<?/MISQL>

<?MIVAR NAME=xpatselqry_join><?/MIVAR>
<?MIVAR NAME=xpatselqry_cond><?/MIVAR>
<?MIVAR NAME=xpatselqry_cols>, null::varchar(255), null::varchar(80), 0<?/MIVAR>

<?MICOMMENT>
    =========================================================
    ==========  GENE ZDB ID
    ==========================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_geneZdbId)">
 <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond AND xpatex_gene_zdb_id = '$xpatselqry_geneZdbId' <?/MIVAR>
<?/MIBLOCK>

<?MICOMMENT>
    =========================================================
    ==========  GENOTYPE ZDB ID
    ==========================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_genoZdbId)">
 <?MIVAR NAME=xpatselqry_join> $xpatselqry_join join genotype_experiment on genox_zdb_id = xpatex_genox_zdb_id<?/MIVAR>
 <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond AND genox_geno_zdb_id = '$xpatselqry_genoZdbId' <?/MIVAR>
<?/MIBLOCK>

<?MICOMMENT>
    ============================================================================
    ==========  AUTHOR NAME TESTS
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_author)">
  
  <?MIBLOCK COND="$(EC,$xpatselqry_authorSearchType,begins)">
    <?MIVAR NAME=$xpatselqry_likeString>$(LOWER,$xpatselqry_author)%<?/MIVAR>
  <?MIELSE>
    <?MIVAR NAME=$xpatselqry_likeString>%$(LOWER,$xpatselqry_author)%<?/MIVAR>
  <?/MIBLOCK>
   
  <?MIVAR NAME=xpatselqry_join>$xpatselqry_join join publication on xpatex_source_zdb_id = zdb_id <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond AND  lower(authors) like '$xpatselqry_likeString' <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cols>, authors, 'Author', 500<?/MIVAR>
  <?MIVAR NAME=$xpatselqry_matchedText>$xpatselqry_author<?/MIVAR>
  <?MIVAR NAME=$xpatselqry_matchedTextSearchType>$xpatselqry_authorSearchType<?/MIVAR>

<?/MIBLOCK>

<?MICOMMENT> 
    =====================================================
    === JTYPE (direct submission, published literature)  
    =====================================================
 <?/MICOMMENT>

<?MIBLOCK COND="$(XST,$xpatselqry_jtype)">
  <?MIVAR COND="$(EC,$xpatselqry_jtype,Published)">$(SETVAR,$xpatselqry_jtype,Journal)<?/MIVAR>
    
  <?MIVAR COND="$(NXST,$xpatselqry_author)" NAME=xpatselqry_join>$xpatselqry_join join publication on xpatex_source_zdb_id = zdb_id <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and jtype = '$xpatselqry_jtype' <?/MIVAR>

<?/MIBLOCK>

<?MICOMMENT>
    ============================================================================
    ======= DATE test
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_recentRecords)">

  <?MIVAR NAME=xpatselqry_join COND="$(AND,$(NXST,$xpatselqry_author),$(NXST,$xpatselqry_jtype))">$xpatselqry_join join publication on xpatex_source_zdb_id = zdb_id <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatex_direct_submission_date::datetime year to day > current - $xpatselqry_recentRecords units day<?/MIVAR>
<?/MIBLOCK>


<?MICOMMENT>
    ============================================================================
    ======= WT only 
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_wtOnly)">
    <?MIVAR NAME=$xselqry_tmp_wt_genox>$(CONCAT,xselqry_tmp_wt_genox,$xpatselqry_session_id)<?/MIVAR>    

    <?MISQL SQL="
          execute function table_exists('$xselqry_tmp_wt_genox')">
          <?MISQL COND="$(EC,$1,f)" SQL="
             create temp table $xselqry_tmp_wt_genox (
		  xtwg_genox_zdb_id		varchar(50)
             ) with NO LOG;">
          <?/MISQL>
          <?MISQL COND="$(EC,$1,t)" SQL="
                delete from $xselqry_tmp_wt_genox;">
          <?/MISQL>
    <?/MISQL>

    <?MISQL SQL="
    	    insert into $xselqry_tmp_wt_genox
	    	 select genox_zdb_id
                   from genotype_experiment, genotype, experiment
                  where genox_geno_zdb_id = geno_zdb_id
                    and genox_exp_zdb_id = exp_zdb_id
                    and geno_is_wildtype = 't'
                    and exp_name = '_Standard';"> 
          
    <?/MISQL>
   <?MIVAR NAME=xpatselqry_join>$xpatselqry_join,  $xselqry_tmp_wt_genox <?/MIVAR>
   <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatex_genox_zdb_id = xtwg_genox_zdb_id <?/MIVAR>
 
<?/MIBLOCK>



<?MICOMMENT>
    ============================================================================
    ==========  MO knockdown Gene
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(AND,$(XST,$xpatselqry_MOgene),$(NXST,,$xpatselqry_wtOnly))">
 
  <?MIVAR NAME=$xpatselqry_nameEndsTable><?/MIVAR>

  <?MIBLOCK COND="$(EC,$xpatselqry_MOsearchtype,begins)">
    <?MIVAR NAME=$xpatselqry_nameCond>allmapnm_name_lower like '$(LOWER,$xpatselqry_MOgene)%'<?/MIVAR>
  <?MIELSE>
    <?MIVAR NAME=$xpatselqry_nameEndsTable>
      join all_name_ends on allmapnm_serial_id = allnmend_allmapnm_serial_id
    <?/MIVAR>
    <?MIVAR NAME=$xpatselqry_nameCond>allnmend_name_end_lower like '$(LOWER,$xpatselqry_MOgene)%'<?/MIVAR>
  <?/MIBLOCK>
    
  <?MIVAR NAME=xselqry_tmp_mo_sig>$(CONCAT,xselqry_tmp_mo_sig_,$xpatselqry_session_id)<?/MIVAR>
  <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_mo_sig')">
      <?MISQL COND="$(EC,$1,f)" SQL="
        create temp table $xselqry_tmp_mo_sig (
                    xtmn_mrkr_zdb_id		varchar(50),
		    xtmn_name_significance	integer
		    )with no log;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,t)" SQL="
      	      delete from $xselqry_tmp_mo_sig ;">
      <?/MISQL>
  <?/MISQL>
    
  <?MISQL SQL="
    	    insert into $xselqry_tmp_mo_sig 
    	    select allmapnm_zdb_id, min(allmapnm_significance)
              from all_map_names $xpatselqry_nameEndsTable
             where $xpatselqry_nameCond
               and (allmapnm_zdb_id like 'ZDB-GENE%' or allmapnm_zdb_id like 'ZDB-EFG%') 
               and allmapnm_precedence in ('Current symbol', 'Current name')                
            group by allmapnm_zdb_id;">
  <?/MISQL>
 
  <?MIVAR NAME=$xselqry_tmp_mo_name>$(CONCAT,xselqry_tmp_mo_name_,$xpatselqry_session_id)<?/MIVAR>
  <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_mo_name')">
      <?MISQL COND="$(EC,$1,f)" SQL="
        create temp table $xselqry_tmp_mo_name (
                    xtmg_genox_zdb_id		varchar(50),
		    xtmg_match_name		varchar(255),
		    xtmg_match_name_precedence	varchar(80),
		    xtmg_match_name_signif	integer
		    )with no log;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,t)" SQL="
      	      delete from $xselqry_tmp_mo_name ;">
      <?/MISQL>
  <?/MISQL>
  <?MISQL SQL="
    	    insert into $xselqry_tmp_mo_name
                 select genox_zdb_id, allmapnm_name, 
                        case allmapnm_precedence
                             when 'Current symbol' then 'MO symbol'
                             when 'Current name' then 'MO name'
                        end, xtmn_name_significance
                   from $xselqry_tmp_mo_sig, marker_relationship,experiment_condition,
		        genotype_experiment, all_map_names $xpatselqry_nameEndsTable
                  where $xpatselqry_nameCond
                    and xtmn_mrkr_zdb_id = allmapnm_zdb_id
                    and xtmn_name_significance = allmapnm_significance
                    and xtmn_mrkr_zdb_id = mrel_mrkr_2_zdb_id
                    and mrel_mrkr_1_zdb_id = expcond_mrkr_zdb_id
                    and expcond_exp_zdb_id = genox_exp_zdb_id;">
  <?/MISQL>

  <?MIVAR NAME=xpatselqry_join>
     $xpatselqry_join join $xselqry_tmp_mo_name on xpatex_genox_zdb_id = xtmg_genox_zdb_id
  <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cols>, xtmg_match_name, xtmg_match_name_precedence,xtmg_match_name_signif<?/MIVAR>
  <?MIVAR NAME=xpatselqry_matchedText>$xpatselqry_MOgene<?/MIVAR>
  <?MIVAR NAME=xpatselqry_matchedTextSearchType>$xpatselqry_MOsearchtype<?/MIVAR>


<?/MIBLOCK>  <?MICOMMENT> --- end MO name query --- <?/MICOMMENT>

<?MICOMMENT>
    ============================================================================
    ==========  GENOTYPE NAME 
    ============================================================================

<?/MICOMMENT>
<?MIBLOCK COND="$(AND,$(XST,$xpatselqry_genoName),$(NXST,$xpatselqry_genoZdbId),$(NXST,$xpatselqry_wtOnly))">

    <?MISQL SQL="select WebExplode(object,'genonm_inputname=$xpatselqry_genoName&genonm_session_id=$xpatselqry_session_id&compare=$xpatselqry_genoSearchType') from webPages where ID='aa-genotype_name_match.apg';">$1<?/MISQL>   

    <?MIVAR NAME=xselqry_tmp_geno_name>$genonm_temp_on_name<?/MIVAR>
      
   <?MIVAR NAME=xpatselqry_join>
      	  $xpatselqry_join, $xselqry_tmp_geno_name, genotype_experiment
   <?/MIVAR>
   <?MIVAR NAME=xpatselqry_cond>
       $xpatselqry_cond AND xpatex_genox_zdb_id = genox_zdb_id and g_zdb_id = genox_geno_zdb_id
   <?/MIVAR>
   <?MIVAR NAME=xpatselqry_cols>, m_text, 'Background:'||m_type, m_order<?/MIVAR>
   <?MIVAR NAME=xpatselqry_matchedText>$xpatselqry_genoName<?/MIVAR>
   <?MIVAR NAME=xpatselqry_matchedTextSearchType>$xpatselqry_genoSearchType<?/MIVAR>

<?/MIBLOCK>  <?MICOMMENT> --- end geno name query ---<?/MICOMMENT>

<?MICOMMENT>
    =========================================================
    ==========  GENE NAME TESTS 
    ==========================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(AND,$(XST,$xpatselqry_geneName),$(NXST,$xpatselqry_geneZdbId))">

    <?MIVAR NAME=$xpatselqry_nameEndsTable><?/MIVAR>
   
    <?MIVAR COND="$(EC,$xpatselqry_geneSearchType,begins)" NAME=$xpatselqry_nameCond>
      allmapnm_name_lower like '$(LOWER,$xpatselqry_geneName)%'<?/MIVAR>
    <?MIVAR COND="$(EC,$xpatselqry_geneSearchType,equals)" NAME=$xpatselqry_nameCond>
      allmapnm_name_lower = '$(LOWER,$xpatselqry_geneName)'<?/MIVAR>  
    <?MIVAR COND="$(EC,$xpatselqry_geneSearchType,contains)" NAME=$xpatselqry_nameEndsTable>
      join all_name_ends on allmapnm_serial_id = allnmend_allmapnm_serial_id<?/MIVAR>
    <?MIVAR COND="$(EC,$xpatselqry_geneSearchType,contains)" NAME=$xpatselqry_nameCond>
      allnmend_name_end_lower like '$(LOWER,$xpatselqry_geneName)%'<?/MIVAR>

    <?MIVAR NAME=$xselqry_tmp_name>$(CONCAT,xselqry_tmp_name_,$xpatselqry_session_id)<?/MIVAR>
    <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_name')">
      <?MISQL COND="$(EC,$1,f)" SQL="
        create temp table $xselqry_tmp_name (
                    xtn_mrkr_zdb_id		varchar(50),
		    xtn_match_name		varchar(255),
		    xtn_match_name_precedence	varchar(80),
		    xtn_match_name_signif	integer
		    )with no log;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,f)" SQL="
         create index idx_$xselqry_tmp_name on $xselqry_tmp_name(xtn_mrkr_zdb_id) in idxdbs3;">
      <?/MISQL> 
      <?MISQL COND="$(EC,$1,t)" SQL="
      	    delete from  $xselqry_tmp_name;">
      <?/MISQL> 
    <?/MISQL>

    <?MICOMMENT> Before IDS sql has an aggregation function of FIRST(), I couldn't think
                 of any faster way than to use two temp tables. Could use subquery, but slow.
    <?/MICOMMENT>
    <?MIVAR NAME=$xselqry_tmp_g_mth>$(CONCAT,xselqry_tmp_g_mth,$xpatselqry_session_id)<?/MIVAR>
    <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_g_mth')">
      <?MISQL COND="$(EC,$1,f)" SQL="
        create temp table $xselqry_tmp_g_mth (
                    xtg_mrkr_zdb_id		varchar(50),
		    xtg_name_significance	integer,
		    xtg_name_match		varchar(255),
		    xtg_name_precedence		varchar(80)
		    )with no log;">
      <?/MISQL> 
      <?MISQL COND="$(EC,$1,t)" SQL="
      	    delete from  $xselqry_tmp_g_mth;">
      <?/MISQL> 
    <?/MISQL>
 
    <?MIVAR NAME=$xselqry_tmp_sig>$(CONCAT,xselqry_tmp_sig_,$xpatselqry_session_id)<?/MIVAR>
    <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_sig')">
      <?MISQL COND="$(EC,$1,f)" SQL="
        create temp table $xselqry_tmp_sig (
                    xtf_mrkr_zdb_id		varchar(50),
		    xtf_name_significance	integer
		    )with no log;">
      <?/MISQL> 
      <?MISQL COND="$(EC,$1,t)" SQL="
      	    delete from  $xselqry_tmp_sig;">
      <?/MISQL> 
    <?/MISQL>

    <?MISQL SQL="
    	    insert into $xselqry_tmp_g_mth
    	    select allmapnm_zdb_id, allmapnm_significance, allmapnm_name, allmapnm_precedence
              from all_map_names $xpatselqry_nameEndsTable
             where $xpatselqry_nameCond
               and (allmapnm_zdb_id like 'ZDB-GENE%' or allmapnm_zdb_id like 'ZDB-EFG%') ;">	    
    <?/MISQL>
    
    <?MIBLOCK COND="$(>,$MI_ROWCOUNT,0)">
       <?MIVAR NAME=xpatselqry_gene_ismatched>t<?/MIVAR>
       <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatex_gene_zdb_id = xtn_mrkr_zdb_id<?/MIVAR>

    <?MIELSE>
      <?MICOMMENT>
           =========================================================
           === Try PROBE NAME  only if NO GENE match
           =========================================================
      <?/MICOMMENT>
    
      <?MISQL SQL="
    	    insert into $xselqry_tmp_g_mth
    	    select allmapnm_zdb_id, allmapnm_significance, allmapnm_name,
                      case allmapnm_precedence
                        when 'Current symbol' then 'Probe name'
                        when 'Accession number' then 'Probe acc#'
                      else allmapnm_precedence
                      end
              from all_map_names $xpatselqry_nameEndsTable
             where $xpatselqry_nameCond
               and (allmapnm_zdb_id like 'ZDB-EST%' or allmapnm_zdb_id like 'ZDB-CDNA%');">
      <?/MISQL>
      <?MIVAR NAME=xpatselqry_probe_ismatched>t<?/MIVAR>
      <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatex_probe_feature_zdb_id = xtn_mrkr_zdb_id<?/MIVAR>

    <?/MIBLOCK><?MICOMMENT>-- end gene / probe --<?/MICOMMENT>

    <?MISQL SQL="
    	    insert into $xselqry_tmp_sig
	    	 select xtg_mrkr_zdb_id, min(xtg_name_significance)
                   from $xselqry_tmp_g_mth
    	       group by xtg_mrkr_zdb_id;">
    <?/MISQL>

    <?MICOMMENT> this depends on for each data type, e.g. gene, each significance corresponding
                to one precedence, which is true now.
    <?/MICOMMENT>
              
    <?MISQL SQL="
    	    insert into $xselqry_tmp_name
    	    select xtg_mrkr_zdb_id, min(xtg_name_match),min(xtg_name_precedence), xtf_name_significance
              from $xselqry_tmp_sig, $xselqry_tmp_g_mth, name_precedence
             where xtg_mrkr_zdb_id = xtf_mrkr_zdb_id
               and xtg_name_significance = xtf_name_significance 
           group by xtg_mrkr_zdb_id, xtf_name_significance;">
	    
    <?/MISQL>
    <?MIVAR NAME=xpatselqry_gene_probe_count>$MI_ROWCOUNT<?/MIVAR>

    <?MIVAR NAME=xpatselqry_join>$xpatselqry_join, $xselqry_tmp_name<?/MIVAR>
    <?MIVAR NAME=xpatselqry_cols>, xtn_match_name, xtn_match_name_precedence, xtn_match_name_signif<?/MIVAR>
    <?MIVAR NAME=xpatselqry_matchedText>$xpatselqry_geneName<?/MIVAR>
    <?MIVAR NAME=xpatselqry_matchedTextSearchType>$xpatselqry_geneSearchType<?/MIVAR>

<?/MIBLOCK>  <?MICOMMENT>-- end GENE / PROBE name test -- <?/MICOMMENT> 


<?MICOMMENT>
    ============================================================================
    ==========  ASSAY TYPE TESTS
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_assay)">
 
 <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond AND xpatex_assay_name = '$xpatselqry_assay'<?/MIVAR>

<?/MIBLOCK>  <?MICOMMENT> --- end assay name query --- <?/MICOMMENT>

<?MICOMMENT>
    ============================================================================
    ==========  ANATOMICAL STRUCTURES TESTS
    ============================================================================
<?/MICOMMENT>
<?MIBLOCK COND="$(XST,$xpatselqry_anatomyZdbIdList)">

    <?MIVAR NAME=$xpatselqry_anatitem_zdb_id_list>$(SEPARATE,$xpatselqry_anatomyZdbIdList,"','")<?/MIVAR>
    <?MIVAR NAME=$xpatselqry_item_count>$(VECSIZE,$xpatselqry_anatomyZdbIdList)<?/MIVAR>

    <?MIVAR NAME=$xselqry_tmp_anat_all>$(CONCAT,xselqry_tmp_anat_all,$xpatselqry_session_id)<?/MIVAR>    
    <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_anat_all')">
      <?MISQL COND="$(EC,$1,f)" SQL="
         create temp table $xselqry_tmp_anat_all (
                  xtaa_gene_zdb_id      	varchar(50),
		  xtaa_genox_zdb_id		varchar(50),
		  xtaa_search_anat_zdb_id	varchar(50),
		  xtaa_xpatres_zdb_id		varchar(50)
         ) with NO LOG;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,t)" SQL="
          delete from $xselqry_tmp_anat_all;">
      <?/MISQL>
    <?/MISQL>

    <?MICOMMENT> -- filter with stage overlapping if applicable --<?/MICOMMENT>
    <?MIVAR NAME=$xpatselqry_stage_overlap_tbl><?/MIVAR>
    <?MIVAR NAME=$xpatselqry_stage_overlap_tbl COND="$(XST,$xpatselqry_stageStart)">, stage ss, stage se <?/MIVAR>
    	   
   <?MIVAR NAME=$xpatselqry_stage_overlap_cnd><?/MIVAR>
    <?MIVAR NAME=$xpatselqry_stage_overlap_cnd COND="$(XST,$xpatselqry_stageStart)">and xpatres_start_stg_zdb_id = ss.stg_zdb_id and xpatres_end_stg_zdb_id = se.stg_zdb_id and ss.stg_hours_start < $xpatselqry_stageEnd and se.stg_hours_end > $xpatselqry_stageStart <?/MIVAR>

    <?MICOMMENT> -- filter with gene/probe name matching if applicable --<?/MICOMMENT>
    <?MIVAR NAME=xpatselqry_gene_tbl_join><?/MIVAR>
    <?MIVAR NAME=xpatselqry_gene_tbl_cnd><?/MIVAR>
    <?MIBLOCK COND="$(AND,$(XST,$xpatselqry_gene_probe_count),$(>,$xpatselqry_gene_probe_count,0))">
        <?MIVAR NAME=xpatselqry_gene_tbl_join>, $xselqry_tmp_name <?/MIVAR>
        <?MIVAR COND="$(XST,$xpatselqry_gene_ismatched)" NAME=xpatselqry_gene_tbl_cnd> and xpatex_gene_zdb_id = xtn_mrkr_zdb_id<?/MIVAR>
        <?MIVAR COND="$(XST,$xpatselqry_probe_ismatched)" NAME=xpatselqry_gene_tbl_cnd> and xpatex_probe_feature_zdb_id = xtn_mrkr_zdb_id<?/MIVAR>
    <?/MIBLOCK>

    <?MICOMMENT> -- filter with WT only if applicable --<?/MICOMMENT>
    <?MIVAR NAME=xpatselqry_wt_tbl_join><?/MIVAR>
    <?MIVAR NAME=xpatselqry_wt_tbl_cnd><?/MIVAR>
    <?MIBLOCK COND="$(XST,$xpatselqry_wtOnly)">
      <?MIVAR NAME=xpatselqry_wt_tbl_join>, $xselqry_tmp_wt_genox<?/MIVAR>
      <?MIVAR NAME=xpatselqry_wt_tbl_cnd> and xpatex_genox_zdb_id = xtwg_genox_zdb_id <?/MIVAR>
    <?/MIBLOCK>


    <?MISQL SQL="
       insert into $xselqry_tmp_anat_all
	    select xpatex_gene_zdb_id, xpatex_genox_zdb_id, xpatres_anat_item_zdb_id, xpatres_zdb_id
              from expression_experiment, expression_result 
                   $xpatselqry_gene_tbl_join $xpatselqry_stage_overlap_tbl $xpatselqry_wt_tbl_join
             where xpatres_anat_item_zdb_id in ('$xpatselqry_anatitem_zdb_id_list')
               and xpatres_expression_found = 't'
               and xpatex_zdb_id = xpatres_xpatex_zdb_id 
	       $xpatselqry_wt_tbl_cnd
	       $xpatselqry_gene_tbl_cnd
               $xpatselqry_stage_overlap_cnd
                ;">
    <?/MISQL>

    <?MISQL COND="$(AND,$(XST,$xpatselqry_includeSubstructures),$(NE,$xpatselqry_includeSubstructures,),$(NE,$xpatselqry_includeSubstructures,unchecked))" SQL="
       insert into $xselqry_tmp_anat_all
	    select xpatex_gene_zdb_id, xpatex_genox_zdb_id, allanatcon_container_zdb_id, xpatres_zdb_id
              from expression_experiment, expression_result, all_anatomy_contains 
                   $xpatselqry_gene_tbl_join $xpatselqry_stage_overlap_tbl $xpatselqry_wt_tbl_join
             where allanatcon_container_zdb_id in ('$xpatselqry_anatitem_zdb_id_list')
               and xpatres_expression_found = 't' 
               and xpatres_anat_item_zdb_id = allanatcon_contained_zdb_id
               and xpatres_xpatex_zdb_id = xpatex_zdb_id
	       $xpatselqry_wt_tbl_cnd
	       $xpatselqry_gene_tbl_cnd
               $xpatselqry_stage_overlap_cnd ;">
    <?/MISQL>

    <?MICOMMENT> --------------------------------------------
                 ------ Create Table with final XPATRES ids
                 --------------------------------------------- 
    <?/MICOMMENT>
    <?MIVAR NAME=$xselqry_tmp_anat_res_id>$(CONCAT,xselqry_tmp_anat_res_id,$xpatselqry_session_id)<?/MIVAR> 
    <?MIVAR NAME=$xselqry_tmp_anat_res_id_index>$(CONCAT,$xselqry_tmp_anat_res_id,_index)<?/MIVAR>    
    <?MISQL SQL="
      execute function table_exists('$xselqry_tmp_anat_res_id')">
      <?MISQL COND="$(EC,$1,f)" SQL="
         create temp table $xselqry_tmp_anat_res_id (
                  xtari_xpatres_zdb_id      	varchar(50)
         ) with NO LOG;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,f)" SQL="
	 create index $xselqry_tmp_anat_res_id_index
                  on $xselqry_tmp_anat_res_id (xtari_xpatres_zdb_id) in idxdbs3;">
      <?/MISQL>
      <?MISQL COND="$(EC,$1,t)" SQL="
          delete from $xselqry_tmp_anat_res_id;">
      <?/MISQL>
    <?/MISQL> 

    <?MICOMMENT> -----------------------
                 ------ For AND search
                 ----------------------- 
    <?/MICOMMENT>
    <?MIBLOCK COND="$(AND,$(XST,$xpatselqry_structureBool),$(EC,$xpatselqry_structureBool,and))">
       <?MIVAR NAME=$xselqry_tmp_anat_real>$(CONCAT,xselqry_tmp_anat_real,$xpatselqry_session_id)<?/MIVAR>    
       <?MISQL SQL="
          execute function table_exists('$xselqry_tmp_anat_real')">
          <?MISQL COND="$(EC,$1,f)" SQL="
             create temp table $xselqry_tmp_anat_real (
                  xtar_gene_zdb_id      	varchar(50),
		  xtar_genox_zdb_id		varchar(50)
             ) with NO LOG;">
          <?/MISQL>
          <?MISQL COND="$(EC,$1,t)" SQL="
                delete from $xselqry_tmp_anat_real;">
          <?/MISQL>
      <?/MISQL>

      <?MIBLOCK COND="$(NXST,$xpatselqry_wtOnly)">
        <?MISQL SQL="
	     insert into $xselqry_tmp_anat_real
                  select xtaa_gene_zdb_id, xtaa_genox_zdb_id
                    from $xselqry_tmp_anat_all 
		group by xtaa_gene_zdb_id, xtaa_genox_zdb_id
                  having count(distinct xtaa_search_anat_zdb_id) = $xpatselqry_item_count
	   ;">
         <?/MISQL>

         <?MISQL SQL="
      	      insert into $xselqry_tmp_anat_res_id
                  select distinct xtaa_xpatres_zdb_id 
                    from $xselqry_tmp_anat_real, $xselqry_tmp_anat_all
                   where xtar_gene_zdb_id = xtaa_gene_zdb_id  
                     and xtar_genox_zdb_id = xtaa_genox_zdb_id ;">
         <?/MISQL>
      <?MIELSE>    <?MICOMMENT> --- WT only and flat WTs  --- <?/MICOMMENT>
       <?MISQL SQL="
	     insert into $xselqry_tmp_anat_real(xtar_gene_zdb_id)
                  select xtaa_gene_zdb_id
                    from $xselqry_tmp_anat_all 
		group by xtaa_gene_zdb_id
                  having count(distinct xtaa_search_anat_zdb_id) = $xpatselqry_item_count
	   ;">
         <?/MISQL>

         <?MISQL SQL="
      	      insert into $xselqry_tmp_anat_res_id
                  select distinct xtaa_xpatres_zdb_id 
                    from $xselqry_tmp_anat_real, $xselqry_tmp_anat_all
                   where xtar_gene_zdb_id = xtaa_gene_zdb_id ;">
         <?/MISQL>

      <?/MIBLOCK>
      

    <?MIELSE>  <?MICOMMENT> -------------------------------------------
                            --   OR search  (no worry of WT flatting)      
                            -------------------------------------------
               <?/MICOMMENT>

        <?MISQL SQL="
	     insert into $xselqry_tmp_anat_res_id
                  select distinct xtaa_xpatres_zdb_id 
                    from $xselqry_tmp_anat_all;">
        <?/MISQL>
    <?/MIBLOCK>
	   
    <?MIVAR NAME=xpatselqry_join>$xpatselqry_join , $xselqry_tmp_anat_res_id<?/MIVAR>
    <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatres_zdb_id = xtari_xpatres_zdb_id<?/MIVAR>

<?/MIBLOCK> <?MICOMMENT> --- end xst anat zdb list --- <?/MICOMMENT>


<?MICOMMENT>
    ============================================================================
    ==========  STAGE WINDOWS TESTS
    ============================================================================

    Only run this test if user specified a stage range and they did not specify
    any anatomy. If they specified anatomy then the stage test has already been run.
<?/MICOMMENT>

<?MIBLOCK COND="$(AND,$(XST,$xpatselqry_stageStart),$(NXST,$xpatselqry_anatomyZdbIdList))">

  <?MIVAR NAME=xpatselqry_join>$xpatselqry_join, stage ss, stage se<?/MIVAR>
  <?MIVAR NAME=xpatselqry_cond>$xpatselqry_cond and xpatres_start_stg_zdb_id = ss.stg_zdb_id and xpatres_end_stg_zdb_id = se.stg_zdb_id and ss.stg_hours_start < $xpatselqry_stageEnd and se.stg_hours_end > $xpatselqry_stageStart<?/MIVAR>
 
<?/MIBLOCK> 

<?MICOMMENT>
    ============================================================================
    ======= IMAGE only
    ============================================================================
<?/MICOMMENT>

<?MIBLOCK COND="$(XST,$xpatselqry_imagesOnly)">
  <?MIVAR NAME=xpatselqry_join>$xpatselqry_join , image <?/MIVAR>
  <?MIVAR NAME=xpatselqry_cond>
     $xpatselqry_cond and img_fig_zdb_id = xpatfig_fig_zdb_id
  <?/MIVAR>
<?/MIBLOCK>



<?MICOMMENT>
    ============================================================================
    ======= Exclude withdrawn records 
    ============================================================================
    ======= This will always happen, but I want it to be in it's own section
    ======= so that one day, when we handle withdrawn/obsolete records in a 
    ======= more systematic way, we can remove / replace this.
    ============================================================================
<?/MICOMMENT>


<?MICOMMENT>
Do not show a withdrawn gene, a gene with a withdrawn clone, or a gene with a chimeric clone.
<?/MICOMMENT>
 <?MIVAR NAME="xpatselqry_outer_join"><?/MIVAR>

 <?MIVAR NAME="xpatselqry_outer_join">, outer marker probe<?/MIVAR>
 <?MIVAR NAME="xpatselqry_join">$xpatselqry_join , marker as gene <?/MIVAR>
 <?MIVAR NAME="xpatselqry_cond">
    $xpatselqry_cond 
     and xpatex_gene_zdb_id = gene.mrkr_zdb_id
     and gene.mrkr_abbrev[1,10] <> "WITHDRAWN:"
     and not exists(
         select 'x' from clone
         where clone_mrkr_zdb_id=xpatex_probe_feature_zdb_id
         and clone_problem_type = 'Chimeric'
     )
     and not exists (select 'x' from marker
                        where mrkr_zdb_id = xpatex_probe_feature_zdb_id
                                    and mrkr_abbrev[1,10] = "WITHDRAWN:")
 <?/MIVAR>


<?MICOMMENT>
  ============================================================================
  ==========  Into RESULT TABLE
  ============================================================================

<?/MICOMMENT>

<?MIVAR NAME=xpatselqry_final_sql>
     insert into $xpatselqry_resultTable
          (xpat_gene_zdb_id, xpat_fig_zdb_id, xpat_xpatex_zdb_id, xpat_matching_text,
           xpat_matching_precedence, xpat_matching_signif)
	select distinct xpatex_gene_zdb_id, xpatfig_fig_zdb_id, xpatex_zdb_id
               $xpatselqry_cols
          from expression_result,
               expression_pattern_figure,
	       expression_experiment
	       $xpatselqry_join
         where xpatex_zdb_id = xpatres_xpatex_zdb_id
           and xpatres_zdb_id = xpatfig_xpatres_zdb_id
           $xpatselqry_cond 
<?/MIVAR>

<?MISQL COND="$(XST,$debug_timing)" SQL="
  execute function get_time()">
  <br>$1 Before final query
<?/MISQL>

<?MISQL SQL="$xpatselqry_final_sql"><?/MISQL>

<?MICOMMENT>
  <?MIVAR>
   <pre> $xpatselqry_final_sql</pre>
   $MI_ROWCOUNT records
  <?/MIVAR>
<?/MICOMMENT>

<?MISQL COND="$(XST,$debug_timing)" SQL="
  execute function get_time()">
  <br>$1 End final query
<?/MISQL>

