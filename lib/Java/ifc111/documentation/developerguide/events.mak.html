<html><head><title></title></head>
<body bgcolor=#ffffff>

<A NAME="1001595">
<P>
</A><A NAME="996824">
<h1><FONT FACE="Helvetica,Arial">
   <center><i>
      Handling events

   </i></center>
</FONT></h1>
</A><A NAME="1005909">

<img src="Graphics/events.mak.anc.gif">

ost applications must respond to events of some kind, whether they are user interactions with the interface, such as button clicks or keypresses, or a program-controlled action, such as a timer firing. The IFC provides classes to let your application handle these events.<P></A>
<A NAME="1006123">
The <code>View</code> class and its subclasses direct events to the appropriate object. You handle the events by overriding a few methods in the receiving object.<P></A>
<HR>
<A NAME="Event basics"></A>
<A NAME="1005516">
<H1><FONT FACE="Helvetica,Arial"> Event basics</FONT></H1>
</A><A NAME="1005518">
The <code>Event</code> class provides the foundation for recording event information. Two subclasses of <code>Event</code> record the basic types of events:<P></A>
<ul><A NAME="1005520">
<LI>The <code>MouseEvent</code> class records mouse actions, such as clicks and drags.
</A><A NAME="1005522">
<LI>The <code>KeyEvent</code> class records keypresses.
</A></ul><A NAME="1005524">
As an event arrives from the AWT, the IFC places it on the application's event queue. Each IFC application has a main thread that removes an event from the event queue and directs it to the object that should receive it.<P></A>
<A NAME="1006379">
<B>IFC event processing
<img src="Graphics/events.mak.anc1.gif">


</B>
<P>
</A>


<A NAME="1006410">
In its main thread, the application removes an event from the queue, determines its destination, and then delivers the event, executing the event processing code in the receiving object. Once this code completes, the application's main thread removes the next event and repeats the cycle.<P></A>
<A NAME="1005561">
Unless your application creates additional threads, this design ensures that there is never more than one thread executing code in your application.<P></A>
<HR>
<A NAME="Mouse events"></A>
<A NAME="1005563">
<H1><FONT FACE="Helvetica,Arial"> Mouse events</FONT></H1>
</A><A NAME="1005564">
The <code>MouseEvent</code> class records an action that the user took with the mouse. For example, whenever the user presses a mouse button, the application receives a <code>MOUSE_DOWN</code> event, which it directs to the view that should receive it.<P></A>
<A NAME="1005565">
Constants in the <code>MouseEvent</code> class define the following types of mouse events:<P></A>
<ul><A NAME="1005567">
<LI><code>MOUSE_DOWN</code>--User pressed a mouse button.
</A><A NAME="1005569">
<LI><code>MOUSE_DRAGGED</code>--User moved the mouse while holding a mouse button down.
</A><A NAME="1005571">
<LI><code>MOUSE_UP</code>--User released the mouse button.
</A><A NAME="1005573">
<LI><code>MOUSE_ENTERED</code>--User moved the mouse pointer into a view's bounds.
</A><A NAME="1005575">
<LI><code>MOUSE_MOVED</code>--User moved the mouse pointer within a view's bounds.
</A><A NAME="1005577">
<LI><code>MOUSE_EXITED</code>--User moved the mouse pointer out of a view's bounds.
</A></ul><A NAME="1006435">
The <em>x</em> and <em>y</em> variables in the <code>MouseEvent</code> class record the location at which an event occurred, and the <em>modifiers</em> variable records information about the state of modifier keys, such as the Shift key.<P></A>
<A NAME="Mouse events in the view hierarchy"></A>
<A NAME="1006895">
<H2><FONT FACE="Helvetica,Arial"> Mouse events in the view hierarchy</FONT></H2>
</A><A NAME="1006899">
When the user clicks within an application user interface, the application must determine which view receives the mouse down event. The receiving view is the deepest view within the view hierarchy that contains the mouse down point, determined using the <code>viewForMouse</code> method. The application sends the mouse down event, and corresponding mouse dragged<em> </em>and mouse up events, to this view.<P></A>
<A NAME="Down, dragged, and up events"></A>
<A NAME="1005579">
<H2><FONT FACE="Helvetica,Arial"> Down, dragged, and up events</FONT></H2>
</A><A NAME="1005580">
To receive mouse-down, mouse-dragged, and mouse-up events, override the <code>View</code> methods listed in <a href="events.mak.html#1005580">Table&nbsp;4.1</a>:

<TABLE BORDER="2">
<CAPTION></CAPTION>
<tr><th><b><A NAME="1005587">
Constant<P>
</A><B><th><b><A NAME="1005589">
Method<P>
</A><B>
<tr><td><A NAME="1005592">
<code>MOUSE_DOWN</code> <P>
</A><td><A NAME="1005594">
<code>public boolean mouseDown(MouseEvent event);</code><P>
</A>
<tr><td><A NAME="1005597">
<code>MOUSE_DRAGGED</code><P>
</A><td><A NAME="1005599">
<code>public void mouseDragged(MouseEvent event);</code><P>
</A>
<tr><td><A NAME="1005602">
<code>MOUSE_UP</code><P>
</A><td><A NAME="1005604">
<code>public void mouseUp(MouseEvent event);</code><P>
</A>

</TABLE>

<TABLE>
<TR><TD>
</TABLE>


<P></A>
<A NAME="1005605">
In the <code>View</code> subclass that is handling events, override methods that correspond to events that you want to process. For example, a button-like <code>View</code> subclass could use the following mouse-handling code:<P></A>
<A NAME="1005606">
<PRE><code>p</code>ublic boolean mouseDown(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!isEnabled()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pressed = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>public void mouseDragged(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean mouseOver;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mouseOver = bounds.containsPoint(event.x, event.y);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pressed != mouseOver){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pressed = mouseOver;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>public void mouseUp(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pressed) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;performClick();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pressed = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</PRE>
</A>
<A NAME="1005607">
This <code>View</code> subclass takes action on all three mouse events. If the object is disabled, <code>mouseDown</code> returns false, indicating that the object does not wish to receive the corresponding mouse-dragged and mouse-up events.<P></A>
<A NAME="Entered, moved, and exited events"></A>
<A NAME="1005619">
<H2><FONT FACE="Helvetica,Arial"> Entered, moved, and exited events</FONT></H2>
</A><A NAME="1005620">
To receive mouse entered, moved, and exited events, override the <em>View</em> methods listed in <a href="events.mak.html#1005620">Table&nbsp;4.2</a>:

<TABLE BORDER="2">
<CAPTION></CAPTION>
<tr><th><b><A NAME="1005627">
Event<P>
</A><B><th><b><A NAME="1005629">
Method<P>
</A><B>
<tr><td><A NAME="1005632">
<code>MOUSE_ENTERED </code><P>
</A><td><A NAME="1005634">
<code>public void mouseEntered(MouseEvent event);</code><P>
</A>
<tr><td><A NAME="1005637">
<code>MOUSE_MOVED</code><P>
</A><td><A NAME="1005639">
<code>public void mouseMoved(MouseEvent event);</code><P>
</A>
<tr><td><A NAME="1005642">
<code>MOUSE_EXITED</code><P>
</A><td><A NAME="1005644">
<code>public void mouseExited(MouseEvent event);</code><P>
</A>

</TABLE>

<TABLE>
<TR><TD>
</TABLE>


<P></A>
<A NAME="1006507">
Override any or all of these methods, depending upon the event types that you wants to process.<P></A>
<A NAME="1006850">
A <code>View</code> subclass that animates its contents when the mouse appears within a certain portion of its bounds could use the following mouse handling code:<P></A>
<A NAME="1005648">
<PRE>public void mouseEntered(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hotPolygon.contains(event.x, event.y)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startAnimating();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>public void mouseMoved(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hotPolygon.contains(event.x, event.y)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startAnimating();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopAnimating();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br>public void mouseExited(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stopAnimating();<br>}</PRE>
</A>
<A NAME="Event coalescing"></A>
<A NAME="1005650">
<H2><FONT FACE="Helvetica,Arial"> Event coalescing</FONT></H2>
</A><A NAME="1006853">
When your application is working with mouse-dragged or mouse-moved events, you typically do not want to respond to every event; instead, you usually want to work with the most recent event.<P></A>
<A NAME="1006564">
For example, suppose that you want to display an image under the mouse pointer as the user drags the mouse. If your application responds to every event, the image will appear to lag and follow the path of the pointer, rather than always appearing at the current pointer location. When you respond to every event, this behavior occurs because the system generates mouse-dragged events faster than your view can process them.<P></A>
<A NAME="1005658">
To solve this problem, the IFC <B>coalesces</B> mouse events; that is, it sends only the most recent mouse-dragged or mouse-moved events to a view and ignores the rest. In the following example, the result is that the image always appears at the current mouse pointer location rather than trailing the pointer and appearing at each of its intermediate positions.<P></A>
<A NAME="1006928">
<B>Event coalescing
<img src="Graphics/events.mak.anc2.gif">


</B>
<P>
</A>


<A NAME="1005680">
If you want to process all mouse-dragged or mouse-moved events, you can disable coalescing. In the subclass that is processing these events, override the <code>wantsMouseEventCoalescing</code> method to return false.<P></A>
<A NAME="Autoscrolling"></A>
<A NAME="1005683">
<H2><FONT FACE="Helvetica,Arial"> Autoscrolling</FONT></H2>
</A><A NAME="1006856">
Interface elements that appear within a scroll view, such as a list view or a text view, often allow the user to scroll an area into view by clicking within the view and dragging outside its visible bounds.<P></A>
<A NAME="1007476">
For example, word-processing applications often let the user select more text than is visible by clicking within the visible area and dragging above or below this area. While the user holds the mouse outside the visible area, the program scrolls a new portion of the document into view and selects it. This process is called <B>autoscrolling</B>.<P></A>
<A NAME="1006597">
<B>Autoscrolling in a text view
<img src="Graphics/events.mak.anc3.gif">


</B>
<P>
</A>


<A NAME="1006868">
To support autoscrolling, a view must scroll a different portion of itself into view while the user holds the mouse outside its visible bounds. A view must perform this scrolling in response to some event; however, because the user is holding the mouse in one place, there are no events to trigger the scrolling. The <em>View</em> class contains built-in support for generating autoscroll events--you do not need to create a special device, such as a timer, to generate events that the view can respond to.<P></A>
<A NAME="1005727">
To receive autoscroll events, override the <code>wantsAutoscrollEvents</code> method to return true. If the user clicks within the view's bounds and drags the mouse pointer outside the view's visible area, the view will periodically receive mouse-dragged events sent to its <code>mouseDragged</code> method. The view then compares the mouse coordinates contained in the event to the view's visible area and scrolls the appropriate portion of itself into view.<P></A>
<A NAME="1006627">
For example, the following code shows how to override the <code>mouseDragged</code> method to respond to autoscroll events in a list view:<P></A>
<A NAME="1005731">
<PRE>public void mouseDragged(MouseEvent event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!containsPointInVisibleRect(event.x, event.y)){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tmpRect = new Rect(bounds.x, event.y, 1, rowHeight);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;scrollRectToVisible(tmpRect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>}</PRE>
</A>
<A NAME="1005734">
The <code>scrollRectToVisible</code> method travels up the view hierarchy until it locates a view that is able to perform the scrolling operation.<P></A>
<HR>
<A NAME="Key events"></A>
<A NAME="1006648">
<H1><FONT FACE="Helvetica,Arial"> Key events</FONT></H1>
</A><A NAME="1006651">
A key event records the action of the user pressing or releasing a key on the keyboard. Constants in the <code>KeyEvent</code> class define the following types of key events:<P></A>
<ul><A NAME="1005739">
<LI><code>KEY_DOWN</code>--User pressed a key.
</A><A NAME="1007535">
<LI><code>KEY_UP</code>--User released a key.
</A></ul><A NAME="1007536">
All key events specify which key was pressed or released and provide information about the state of modifier keys, such as the Shift key.<P></A>
<A NAME="Receiving key events"></A>
<A NAME="1005743">
<H2><FONT FACE="Helvetica,Arial"> Receiving key events</FONT></H2>
</A><A NAME="1006755">
To receive key events, override the <code>View</code> methods listed in <a href="events.mak.html#1006755">Table&nbsp;4.1</a>.

<TABLE BORDER="2">
<CAPTION></CAPTION>
<tr><th><b><A NAME="1006764">
Constant<P>
</A><B><th><b><A NAME="1006766">
Method<P>
</A><B>
<tr><td><A NAME="1006769">
<code>KEY_DOWN</code><P>
</A><td><A NAME="1006771">
<code>public void keyDown(KeyEvent, event);</code><P>
</A>
<tr><td><A NAME="1006774">
<code>KEY_UP</code><P>
</A><td><A NAME="1006776">
<code>public void keyUp(KeyEvent, event);</code><P>
</A>

</TABLE>

<TABLE>
<TR><TD>
</TABLE>


<P></A>
<A NAME="1005765">
You only have to handle the key-down event to receive keyboard input.<P></A>
<A NAME="1005766">
Because several views might be competing for keyboard input, a view that is interested in receiving key events must notify the application by sending <code>setFocusedView</code> to itself. This method causes the application to stop sending key events to the view that has the current keyboard focus and begin forwarding them to the requesting view.<P></A>
<A NAME="Pausing and resuming focus"></A>
<A NAME="1005769">
<H2><FONT FACE="Helvetica,Arial"> Pausing and resuming focus</FONT></H2>
</A><A NAME="1005770">
An application suspends the sending of keyboard input to the focused view under certain conditions. For example, if the user begins using a different application, the new application receives the subsequent keyboard input. Whenever the Java application suspends input to a focused view, the focused view receives a <code>pauseFocus</code> message. In response, you can have it redraw itself to indicate this suspended state. For example, you can hide its selection rectangle or its flashing insertion point. The application sends the focused view a <code>resumeFocus</code> message when keyboard input resumes.<P></A>

<hr><br>

<P>
<SCRIPT>
document.write("<FONT SIZE=-2>Last modified " + document.lastModified)
</SCRIPT>
<P>
</body>
</html>
