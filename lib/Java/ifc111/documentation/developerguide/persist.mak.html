<html><head><title></title></head>
<body bgcolor=#ffffff>

<A NAME="1001595">
<P>
</A><A NAME="1005375">
<h1><FONT FACE="Helvetica,Arial">
   <center><i>
      Making objects persistent 

   </i></center>
</FONT></h1>
</A><A NAME="1005382">

<img src="Graphics/persist.mak.anc.gif">

bject persistence is a fundamental feature of any object-oriented environment. A persistence mechanism enables objects or <em>graphs</em> of objects to record essential state information that allows the object graph to be reconstructed at a later date. At runtime, the IFC library rebuilds the user interface objects using the persistence information.<P></A>
<A NAME="1004812">
Because neither the Java language nor its associated libraries provide a persistence mechanism, the IFC library includes a framework that enables this functionality.<P></A>
<HR>
<A NAME="The Archive"></A>
<A NAME="1004819">
<H1><FONT FACE="Helvetica,Arial"> The Archive</FONT></H1>
</A><A NAME="1004823">
Within the IFC library, persistence information is managed by an <em>Archive</em>. An Archive is a pseudo-database mechanism for containing persistence information for one or more object graphs. Most objects, even simple ones, depend upon other objects to accomplish their tasks: a Button contains instance variables that refer to the Images it displays; a TextField contains an instance variable for the String holding its contents. These objects might, in turn, rely upon other objects. <P></A>
<A NAME="1004826">
An object graph refers to an object and all other objects that it directly or indirectly relies upon. The original object is called the <em>root</em> object. <em>Archiving</em> is the process of storing state information for a root object and other objects in the graph.<P></A>
<HR>
<A NAME="The Archiver and Unarchiver"></A>
<A NAME="1004831">
<H1><FONT FACE="Helvetica,Arial"> The Archiver and Unarchiver</FONT></H1>
</A><A NAME="1004833">
Archives manage state information, but you never work with them directly. Instead, you use an Archiver to archive objects and an Unarchiver to restore objects from the Archive. The following code segment archives an object to an archive:<P></A>
<A NAME="1004834">
<PRE>theArchive = new Archive();<br>archiver = new Archiver(theArchive);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>archiver.archiveRootObject(myObject);</PRE>
</A>
<A NAME="1004837">
The Archive traces the root object's object graph, instructing each object to write its state information into the Archive. Only objects that implement the Codable interface can be written into an Archive. See <a href="persist.mak.html#1004846">"The Codable interface"</a> below.<P></A>
<A NAME="1004842">
Retrieving objects from an Archive involves asking for the root objects that it contains:<P></A>
<A NAME="1004843">
<PRE>Codable rootObjects[];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>rootObjects = Unarchiver.unarchiveRoots(theArchive);</PRE>
</A>
<HR>
<A NAME="The Codable interface"></A>
<A NAME="1004846">
<H1><FONT FACE="Helvetica,Arial"> The Codable interface</FONT></H1>
</A><A NAME="1004847">
To be written to or reconstituted from an Archive, an object must conform to the Codable interface. The Codable interface defines methods called by the Archiver and Unarchiver to encode or decode an object, respectively:<P></A>
<A NAME="1004849">
<PRE>public interface Codable {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void describeClassInfo(ClassInfo info);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void encode(Encoder encoder) throws CodingException;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void decode(Decoder decoder) throws CodingException;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void finishDecoding() throws CodingException;<br>}</PRE>
</A>
<A NAME="Methods called by the Archiver"></A>
<A NAME="1004851">
<H2><FONT FACE="Helvetica,Arial"> Methods called by the Archiver</FONT></H2>
</A><A NAME="1004853">
The Archiver calls the first two methods, <code>describeClassInfo()</code> and <code>encode()</code>. Data is placed into and retrieved from the Archive by name-type pairs, where <em>name</em> is a string and <em>type</em> is one of the data types defined in the <em>Codable</em> interface, such as TYPE_OBJECT or TYPE_INTEGER. The <code>encode()</code> method contains the code to request that this data be stored:<P></A>
<A NAME="1004856">
<PRE>public class Button extends View {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image buttonImage;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String title;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean enabled;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final static int VERSION = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void describeClassInfo(ClassInfo, info){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.describeClassInfo(info);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addClass("netscape.application.Button",VERSION);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addField("image",TYPE_OBJECT);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addField("title",TYPE_STRING);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;info.addField("enabled",TYPE_BOOLEAN);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void encode(Encoder encoder) throws CodingException{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.encode(encoder);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encode.encodeObject("image", buttonImage);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encode.encodeString("title", title);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;encode.encodeBoolean("enabled", enabled);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</PRE>
</A>
<A NAME="1004857">
In the example above, the Button class has three instance variables that it needs to store: its image, its title, and whether it is enabled. Its <code>describeClassInfo()</code> method declares the name-type pairs it will archive, as well as the class, in the calls to the ClassInfo's <code>addClass()</code> and <code>addField()</code> methods. This method also declares the class' full name, which includes its package, and a version number. The full name allows the Unarchiver to instantiate the proper type of object when recreating objects from the Archive. <P></A>
<A NAME="1004863">
The version number allows a class to record the version that archived the information so that future versions can reconstitute themselves properly from the Archive. For example, suppose Button version two includes a background color that it stores in an Archive. Its <code>decode()</code> method can check the version number of the information stored in the Archive. If it encounters data stored by Button version one, rather than attempting to read the background color from the Archive, <code>decode()</code> can just set the color to some default value.<P></A>
<A NAME="Methods called by the Unarchiver"></A>
<A NAME="1004865">
<H2><FONT FACE="Helvetica,Arial"> Methods called by the Unarchiver</FONT></H2>
</A><A NAME="1004868">
The <code>decode()</code> and <code>finishDecoding()</code> methods are called by the Unarchiver. The <code>decode()</code> method contains counterpart code to the <code>encode()</code> method to retrieve the object's state from the Archive. The <code>finishDecoding()</code> method is called when all objects have been read from the Archive, providing a chance to perform any post unarchiving processing:<P></A>
<A NAME="1004872">
<PRE>public void decode(Decoder decoder) throws CodingException{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.decode(decoder);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buttonImage = (Image)decoder.decodeObject("image");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;title = decoder.decodeString("title");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enabled = decoder.decodeBoolean("enabled");<br>}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>public void finishDecoding() throws CodingException {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.finishDecoding();<br>}</PRE>
</A>
<A NAME="1004874">
The Button's <code>decode()</code> method retrieves data using the keys that it used to store the data into the Archive. Like most other Archivable implementations, its <code>finishDecoding()</code> method does nothing. The <code>finishDecoding()</code> method allows decoded objects to perform any post-decoding processing at a point at which all objects have been read from the Archive. For example, the View class' superview instance variable is not archived by its <code>encode()</code> method; therefore, it must be restored at some point after unarchiving. The View's <code>finishDecoding()</code> method sets the superview instance variable for all of its subviews to itself. It waits for the <code>finishDecoding()</code> method rather than the <code>decode()</code> method, so that all of its subviews are guaranteed to be completely unarchived.<P></A>
<HR>
<A NAME="Saving Archives"></A>
<A NAME="1004900">
<H1><FONT FACE="Helvetica,Arial"> Saving Archives</FONT></H1>
</A><A NAME="1004901">
The Archive is a data structure, not a storage mechanism, meaning that it does not dictate how its contents are stored in a file or other storage medium. Because it is not a storage mechanism, an Archive's data can be easily mapped to a relational database, binary data stream, or any other storage device. The Archive provides methods that write and read its data using the AsciiSerializer and AsciiDeserializer. The Archive's database-like structure, combined with the human-readable nature of AsciiSerializer output, makes hand-editing of serialized archives very easy. The Archive also provides a more compact binary storage format.<P></A>
<A NAME="The Archive as a database"></A>
<A NAME="1004905">
<H2><FONT FACE="Helvetica,Arial"> The Archive as a database</FONT></H2>
</A><A NAME="1004906">
The Archive's database-like access to data (using names) provides several advantages to working with Archives. <P></A>
<A NAME="1004907">
Archives are random-access containers, meaning that an object can ask for any archived datum at any time during its unarchiving process, including data which does not exist. By contrast, the typical archiving system treats the archive as a binary stream, where data must be read in the exact order that it was written. The binary stream approach also presents the possibility of an object, early in the unarchiving process, reading too few or too many bytes from the stream and confusing objects at a later point in the unarchiving process.<P></A>
<A NAME="1004908">
Because an Archive resembles a database, its contents can be examined and changed by any tool built to manipulate its structure, even without the class files of the objects that originally created the Archive. With a binary stream archive, the only way to read the Archive's contents is by reconstituting the objects it contains, because only the code for those objects understands how its data was written into the Archive.<P></A>

<hr><br>

<P>
<SCRIPT>
document.write("<FONT SIZE=-2>Last modified " + document.lastModified)
</SCRIPT>
<P>
</body>
</html>
