<html><head><title></title></head>
<body bgcolor=#ffffff>

<A NAME="1001595">
<P>
</A><A NAME="996824">
<h1><FONT FACE="Helvetica,Arial">
   <center><i>
      Drawing to the screen

   </i></center>
</FONT></h1>
</A><A NAME="1005516">

<img src="Graphics/drawing.mak.anc.gif">

ecause a view represents a portion of an application's user interface, such as a button or a text field, you must be able to display it on screen. Most of the functionality of the <code>View</code> class centers around drawing a view's contents and managing issues such as clipping, drawing subviews, making views transparent, and using offscreen drawing buffers. The <code>View</code> class makes it easy for subclasses to implement these details.<P></A>
<A NAME="1008121">
Each view has a <B>bounds</B>, a rectangle defining the location and size of the <em>View</em> within the application's user interface. In the IFC, this <B>bounding rectangle</B> is represented by the <code>Rect</code> class. Any drawing performed by a view is clipped to this rectangle. The view receives events, such as mouse clicks, only if they fall within the bounding rectangle.<P></A>
<HR>
<A NAME="How drawing works"></A>
<A NAME="1006576">
<H1><FONT FACE="Helvetica,Arial"> How drawing works</FONT></H1>
</A><A NAME="1008468">
Call the draw method in the <code>View</code> class when your application needs to draw to the screen. The <code>draw</code> method calls the <code>drawView</code> method, which performs the actual work of drawing to the screen.<P></A>
<A NAME="1008534">
Every component that is a subclass of the View class implements a <code>drawView</code> method; some components also have special methods that handle specific aspects of the drawing. The names of these special methods begin with drawView, and <code>drawView</code> calls these methods when it draws the component. For example, <code>drawView</code> calls <code>drawViewGroove</code> to draw the groove of a slider and <code>drawViewKnob</code> to draw the slider's knob.<P></A>
<A NAME="1009823">
You never call <code>drawView</code> or any method prefixed by drawView directly. When you call <code>draw</code>, it redraws a bounding rectangle that you specify, or the entire view, if you do not specify a bounding rectangle. If the redrawn rectangle intersects the bounds of a subview, the <code>draw</code> method also calls the <code>drawView</code> method of the subview.<P></A>
<A NAME="1006687">
When you create a custom view, you override its <code>drawView</code> method to specify drawing behavior, but you still draw to the screen by calling <code>draw</code>. <a href="drawing.mak.html#1006795">See&nbsp;"Drawing custom views" on page 39 for more information.</a> To customize specific aspects of a component's drawing, override methods prefixed by drawView. <a href="drawing.mak.html#1005588">See&nbsp;"Custom drawing" on page 40 for more information.</a><P></A>
<A NAME="The IFC imaging model"></A>
<A NAME="1006218">
<H2><FONT FACE="Helvetica,Arial"> The IFC imaging model</FONT></H2>
</A><A NAME="1005526">
The IFC imaging model is based on the imaging model provided by the AWT. An application drawing area is represented by a two-dimensional grid, with its origin in the upper-left corner, the positive x-axis extending to the right, and the positive y-axis extending down. Coordinates are integers and fall between physical screen pixels. The pixel corresponding to a coordinate occupies the space down and to the right of the coordinate.<P></A>
<A NAME="1008918">
<B>IFC drawing coordinates
<img src="Graphics/drawing.mak.anc1.gif">


</B>
<P>
</A>


<A NAME="1009579">
The bounding rectangle of a view and all drawing operations are specified in terms of this coordinate system. Each view has its own coordinate system.<P></A>
<A NAME="1009581">
You perform drawing operations by sending messages to a <B>graphics object</B>. The graphics object encapsulates a drawing environment, maintaining important state information such as the current color and font. Sending messages to a graphics object causes it to perform a drawing operation. For example, the following code draws some text using the font Helvetica, the point size12.0, and the color green:<P></A>
<A NAME="1005561">
<PRE>g.setFont(font.helvetica12);<br>g.setColor(Color.green);<br>g.drawStringAt("Some text",0,0);</PRE>
</A>
<A NAME="1005564">
A <em></em>graphics object also maintains a <B>clipping rectangle</B>, which delimits the area in which the graphics object can draw. Any part of the intended output that falls outside of this rectangle is not displayed<P></A>
<A NAME="1008937">
<B>The clipping rectangle
<img src="Graphics/drawing.mak.anc2.gif">


</B>
<P>
</A>


<A NAME="How the IFC implements draw"></A>
<A NAME="1005578">
<H2><FONT FACE="Helvetica,Arial"> How the IFC implements draw</FONT></H2>
</A><A NAME="1009829">
You never call <code>drawView</code> directly because drawing a view typically requires some preparation, such as setting the graphics object's' clipping rectangle and calling the <code>drawView</code> methods of the view's descendants.<P></A>
<A NAME="1009831">
You call <code>draw</code> to draw to the screen because the <code>draw</code> method manages these details for you. The following code shows how the IFC implements the <code>draw</code> method:<P></A>
<A NAME="1005583">
<PRE>public void draw(Rect clipRect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics g;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rect drawRect;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g = mainRootView().graphics();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.pushState();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawRect = new Rect(clipRect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawRect.intersectWith(0, 0, width(), height());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setClipRect(drawRect);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.translate(bounds().x, bounds().y)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawView(g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawSubviews(g);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.popState();<br>}</PRE>
</A>
<A NAME="1005585">
Notice that the graphics object passed to the <code>drawSubviews</code> method has already been clipped to the view's bounds. Any drawing that a subview performs will be clipped to its superview's bounds.<P></A>
<A NAME="Implementation of drawView"></A>
<A NAME="1007030">
<H3><FONT FACE="Helvetica,Arial"> Implementation of drawView</FONT></H3>
</A><A NAME="1007034">
All the code required to draw a subview resides in its <code>drawView</code> method. For example, the <code>drawView</code> method of a component might look like this:<P></A>
<A NAME="1009627">
<PRE><code>p</code>ublic void drawView(Graphics g) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setFont(font.helvetica12);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.green);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.drawStringAt("Some text",0,0);<br>}</PRE>
</A>
<A NAME="1009628">
The <code>drawView</code> method takes a single argument, the graphics object that the view uses to perform its drawing operations. The drawing logic of the <code>View</code> class sets the grahics object's clipping rectangle to the view's bounds, so that no drawing occurs outside the view. Because a graphics object is reused, never assume anything about its current state, such as the current drawing color or font.<P></A>
<HR>
<A NAME="Drawing a view"></A>
<A NAME="1006882">
<H1><FONT FACE="Helvetica,Arial"> Drawing a view</FONT></H1>
</A><A NAME="1006883">
As described in <a href="drawing.mak.html#1006576">"How drawing works" on page&nbsp;35</a>, you call the <code>draw</code> method of the <code>View</code> class when your application needs to draw to the screen. For example, the following application contains of a button that changes the color of the background:<P></A>
<A NAME="1006884">
<PRE>import netscape.application.*;<br><br>public class Draw1 extends Application implements Target {<br>    Button button;<br>    <br>    public void init() {<br>        super.init();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Change the color of the background<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().setColor(Color.yellow);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create a button<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button = new Button(24, 146, 100, 24);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setTarget(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setTitle("Change color");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().addSubview(button);<br>    }<br>    <br>    public void performCommand(String command, Object arg) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (mainRootView().color().equals(Color.yellow))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().setColor(Color.lightGray);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().setColor(Color.yellow);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().draw();<br>    }<br>}</PRE>
</A>
<A NAME="1008357">
When a user clicks the button, the <code>performCommand</code> method executes and changes the color of the background. <a href="targets.mak.html#996824">See&nbsp;"Communication between objects" on page 73</a> for information about responding to user interactions in this way; for now, you only need to look at the code within <code>performCommand</code>.<P></A>
<A NAME="1008363">
The <code>if</code> statement evaluates the background color of the root view. If the background is yellow, the <code>setColor</code> method changes it to light gray; if the background is light gray, the <code>setColor</code> method makes it yellow. The <code>draw</code> method forces the application to draw the root view after changing the color. If you try this same code without calling <code>draw</code>, you'll see that the background color never changes.<P></A>
<HR>
<A NAME="Drawing custom views"></A>
<A NAME="1006795">
<H1><FONT FACE="Helvetica,Arial"> Drawing custom views</FONT></H1>
</A><A NAME="1009693">
You draw a custom view just as you draw any other view--by calling the <code>draw</code> method of the view's superview. The <code>draw</code> method, in turn, calls the <code>drawView</code> method of the view you created.<P></A>
<A NAME="1006797">
When you subclass <code>View</code> to create a custom view, specify how this new view should be drawn by overriding the <code>drawView</code> method of <code>View</code>. For example, the following code creates a gray rectangle:<P></A>
<A NAME="1006967">
<PRE>public class GrayRectangle extends View {<br>    <br>    public GrayRectangle(int x, int y, int width, int height) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y, width, height);<br>    }<br>    <br>    public void drawView(Graphics g) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.lightGray);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillRect(0, 0, width(), height());<br>    }<br>}</PRE>
</A>
<A NAME="1006957">
In this example, the constructor specifies the dimensions of the rectangle, and the <code>drawView</code> method fills the entire rectangle with the color light gray.<P></A>
<HR>
<A NAME="Custom drawing"></A>
<A NAME="1005588">
<H1><FONT FACE="Helvetica,Arial"> Custom drawing</FONT></H1>
</A><A NAME="1006914">
All subclasses of <code>View</code> contain methods whose names begin with drawView, as described in <a href="drawing.mak.html#1006576">"How drawing works" on page&nbsp;35</a>. These methods specify how individual areas of the component should be drawn. You can override these methods to implement custom drawing for a component.<P></A>
<A NAME="1009839">
For example, the <code>Button</code> class implements the <code>drawViewBackground</code>, <code>drawViewInterior</code>, and <code>drawViewTitleInRect</code> methods to draw different areas of a button. If you want to create a button with a rounded, three-dimensional appearance, you can extend <code>Button</code> and override its <code>drawViewInterior</code><B> </B>method, as shown in the following example:<P></A>
<A NAME="1007578">
<PRE>public class RoundedButton extends Button {<br>    public RoundedButton(int x, int y, int width, int height) {<br>        init(x, y, width, height);<br>    }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>    public void drawViewInterior(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics g, Image image, Rect interiorRect) {<br>        int i;<br>        int x1 = interiorRect.x;<br>        int y1 = interiorRect.y;<br>        int x2 = x1 + interiorRect.width;<br>        int y2 = y1 + interiorRect.height;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>        // Start at the top with a brightness of 0.8;<br>        float brightness = 0.8f;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>        // Decrement brightness by a small amount as we go down<br>        float f = 0.5f / (float)interiorRect.height;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>        // Fill the Rect with lines of gradually decreasing brightness<br>        while (y1 &lt; y2) {<br>            g.setColor(Color.colorForHSB(0.0f, 0.0f, brightness));<br>            g.drawLine(x1, y1, x2, y1);<br>            y1++;<br>            brightness -= f;<br>        }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>        // Now draw the title<br>        g.setColor(titleColor());<br>        drawViewTitleInRect(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g, title(), font(), interiorRect, Graphics.CENTERED);<br>    }<br>}</PRE>
</A>
<A NAME="1007420">
In this example, <code>RoundedButton</code> is an extension of <code>Button</code>. The <code>drawViewInterior</code> method of <code>RoundedButton</code> specifies that the interior of the button is drawn with individual lines of gradually decreasing brightness, creating the illusion of a rounded button.<P></A>
<A NAME="1007666">
You draw a <code>RoundedButton</code> object as usual: call the <code>draw</code> method of the view's superview. The <code>draw</code> method calls the <code>drawView</code> method of <code>RoundedButton</code>, which in turn calls the <code>drawViewInterior</code> method.<P></A>
<HR>
<A NAME="Drawing part of a view"></A>
<A NAME="1006906">
<H1><FONT FACE="Helvetica,Arial"> Drawing part of a view</FONT></H1>
</A><A NAME="1007821">
By default, the <code>drawView</code> method must completely draw the area within its bounds. However, you may not want to draw this area completely. For example, you may want to draw a button as a circle and let the contents of its superview appear around the button's edge. In this case, the button<em> </em>should not completely redraw the area defined by its bounds. To redraw it correctly, you must first draw the button's superview (clipped to the view's bounds), then draw the button.<P></A>
<A NAME="1007850">
The <code>setTransparent</code> method informs the IFC library that a view does not draw its contents completely. When the view receives a drawing request, it redraws its superview (or nearest opaque ancestor).<P></A>
<A NAME="1007811">
For example, the following code implements the class <code>SpecialButton</code>, which draws a button as an oval:<P></A>
<A NAME="1009296">
<PRE>public class SpecialButton extends Button {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public SpecialButton(int x, int y, int width, int height) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y, width, height);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public void drawViewInterior(Graphics g, String title,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Image image, Rect interiorRect) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Draw the button as an oval<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(Color.darkGray);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.fillOval(0, 0, width(), height());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Now draw the button title<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;g.setColor(titleColor());<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawViewTitleInRect(g, title(), font(), interiorRect,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Graphics.CENTERED);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>}</PRE>
</A>
<A NAME="1007833">
The <code>SpecialButton</code> class overrides the <code>drawViewInterior</code> method of <code>Button</code> to draw the oval button.<P></A>
<A NAME="1007839">
The following code instantiates an object of the <code>SpecialButton</code> class; the <code>setTransparent</code> method specifies that you do not want to draw the entire default button.<P></A>
<A NAME="1007862">
<PRE>SpecialButton button;<br>    <br>public void init() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super.init();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Create a button<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button = new SpecialButton(24, 146, 100, 24);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setTransparent(true);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setTitleColor(Color.cyan);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;button.setTitle("OK");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mainRootView().addSubview(button);<br>}</PRE>
</A>
<HR>
<A NAME="Preventing screen flicker while drawing"></A>
<A NAME="1005599">
<H1><FONT FACE="Helvetica,Arial"> Preventing screen flicker while drawing</FONT></H1>
</A><A NAME="1007991">
Because transparent views redraw themselves by first drawing their superview, they often appear to flicker--a user sees the underlying superview for a moment before seeing the transparent view's contents. Similarly, a complex rendering process, such as redrawing the screen when a user manipulates scroll bars, can cause the screen to flicker.<P></A>
<A NAME="1007998">
You can avoid screen flicker by composing the drawing in an offscreen buffer and displaying the final result instead of composing the result onscreen. Use the <code>setBuffered</code> method of <code>View</code> for this purpose. When the rendering is complete, the final result is displayed on screen automatically.<P></A>
<A NAME="1008057">
For example, to use a drawing buffer for the scroll group <code>textGroup</code> defined in <a href="compon.mak.html#1009396">"Making views scrollable" on page&nbsp;29</a>, add the following code:<P></A>
<A NAME="1008062">
<PRE>textGroup.setBuffered(true);</PRE>
</A>
<A NAME="1005604">
Although using a drawing buffer alleviates flicker, it increases memory consumption. It also decreases drawing performance because the IFC copies the final result from the offscreen buffer to the screen.<P></A>

<hr><br>

<P>
<SCRIPT>
document.write("<FONT SIZE=-2>Last modified " + document.lastModified)
</SCRIPT>
<P>
</body>
</html>
