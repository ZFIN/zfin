buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.postgresql:postgresql:42.0.0'
    }
}
plugins {
    id "org.liquibase.gradle" version "1.2.4"
}

apply plugin: 'java'
apply plugin: 'groovy'

//apply from : '../zfinGradle/build.gradle'

def env = System.getenv()
def dbname = env['DBNAME']
def sourceroot = env['SOURCEROOT']
def pgbindir = env['PGBINDIR']
def pgdata = env['PGDATA']
def targetroot = env['TARGETROOT']

dependencies {
    compile 'org.liquibase:liquibase-core:3.4.1'
    compile "org.liquibase:liquibase-gradle-plugin:1.1.1"
    compile gradleApi()
    compile localGroovy()
}

task deployPostgres(dependsOn: ['lib:DB_functions:postgresFunctions:deployPostgresFunctions',
                                'lib:DB_triggers:postgresTriggerProcedures:deployPostgresTrigger']) {
    description "Deploy all postgres code"
}

defaultTasks 'defaultTask'

project.ext.set("dbname", dbname)
project.ext.set("sourceroot", sourceroot)
project.ext.set("pgdata", pgdata)
project.ext.set("pgbindir", pgbindir)

//dependsOn: ['lib:DB_functions:postgresFunctions:killConnectionsToPostgres']
task loadDb() {
    doLast {
        File unloads = file('/research/zunloads/databases/postgres_self_dumps/darwindb/')
        String unloadPath;
        if (unloads.exists()) {
            File latest = unloads.listFiles().last()
            unloadPath = latest.getPath()
        }

        //use -DB=... path if specified, also, yes, I'm being cute so that it will be -DB=...
        //rather than -Ddb=...
        if (System.getProperty("B")) {
            unloadPath = System.getProperty("B")
        }

        //might as well support -Dunload also
        if (System.getProperty("unload")) {
            unloadPath = System.getProperty("unload")
        }

        println "Loading $unloadPath into $dbname"
        exec { commandLine 'dropdb', dbname }
        exec { commandLine 'createdb', dbname }
        exec { commandLine "bash", "-c", "pg_restore -j 4 -d $dbname $unloadPath" }
        exec { commandLine "bash", "-c", "echo 'vacuum (analyze)' | psql $dbname" }
    }
}
task loaddb(dependsOn: loadDb) //just an alias, since we're used to loaddb.pl


sourceSets {
    main {
        java {
            srcDirs = ['source']
        }
        resources {
            srcDirs = ['home']
        }
    }
}

def changeLog = "$projectDir/source/org/zfin/db/load/db.changelog.master.xml"

task buildDatabase() {
    liquibase {
        activities {
            main {
                changeLogFile changeLog
                url 'jdbc:postgresql://localhost:5432/' + dbname
            }
        }
    }
}

update {
/*
    println dbname
    println "Running liquibase updates..."
    println "change logs: " + changeLog
*/

}

task defaultTask {
/*
    println "Hello"
    subprojects.each { subproject ->
        println subproject.path
        println subproject.defaultTasks
        subproject.defaultTasks.each {
            println subproject.path+":"+it
            dependsOn subproject.path+":"+it
        }
    }
*/
}

project.ext.ttNameMap = ['TARGETROOT'               : env['TARGETROOT'],
                         'WEBDRIVER_PATH_FROM_ROOT' : env['WEBDRIVER_PATH_FROM_ROOT'],
                         'ROOT_PATH'                : env['ROOT_PATH'],
                         'CATALINA_HOME'            : env['CATALINA_HOME'],
                         'SOURCEROOT'               : env['SOURCEROOT'],
                         'MUTANT_NAME'              : env['MUTANT_NAME'],
                         'INSTANCE'                 : env['INSTANCE'],
                         'DB_NAME'                  : env['DB_NAME'],
                         'INFORMIX_DIR'             : env['INFORMIX_DIR'],
                         'INFORMIX_SERVER'          : env['INFORMIX_SERVER'],
                         'INFORMIXSQLHOSTS'         : env['INFORMIXSQLHOSTS'],
                         'SHARED_DOMAIN_NAME'       : env['SHARED_DOMAIN_NAME'],
                         'PARTNER_DBNAME'           : env['PARTNER_DBNAME'],
                         'LOADUP_FULL_PATH'         : env['LOADUP_FULL_PATH'],
                         'PARTNER_INTERNAL_INSTANCE': env['PARTNER_INTERNAL_INSTANCE'],
                         'SQLHOSTS_FILE'            : env['SQLHOSTS_FILE'],
                         'ONCONFIG_FILE'            : env['ONCONFIG_FILE'],
                         'VALIDATION_EMAIL_DBA'     : env['VALIDATION_EMAIL_DBA'],
                         'DEFAULT_EMAIL'            : env['DEFAULT_EMAIL'],
                         'GBROWSE_PATH_FROM_ROOT'   : env['GBROWSE_PATH_FROM_ROOT']]

task makePostgresVersion(type: Copy) {
    def serverApps = ''
    serverApps += projectDir
    serverApps += '/server_apps'
    println "Copying files in directory:: " + serverApps
    from(serverApps) {
        include '**/*_PG.sql', '**/*_PG.sqlj', '**/*_PG.pl', '**/*_PG.sh'
        rename '(.*)_PG(.*)', '$1$2'
    }
    into serverApps
    eachFile { FileCopyDetails fcd ->
        println fcd.path
    }
}

def copyFiles(String directory) {
    int numberOfFiles = 0;
    println "Copying files in directory: " + fileList(directory)[0].getParent()
    fileList(directory).each {
        File file ->
            if ((file.getName().endsWith(".sql") ||
                    file.getName().endsWith(".sqlj") ||
                    file.getName().endsWith(".pl") ||
                    file.getName().endsWith(".sh"))
                    && file.getName().contains("_PG.")) {
                String newName = file.getName().replace("_PG", "");
                File dest = new File(file.getParent(), newName);
                String newFileName = dest.getAbsolutePath()
                dest.delete()
                dest << file.text
                println("\t" + file.getName() + " -> " + newName)
                if (newFileName.endsWith("pl"))
                    exec { commandLine 'chmod', '755', newFileName }
                numberOfFiles++;
            }
    }
    println "Copied " + numberOfFiles + " files."
}

File[] fileList(String dir) {
    file(dir).listFiles({ file -> file.isFile() } as FileFilter).sort()
}

File[] directoryList(String dir) {
    file(dir).listFiles({ file -> file.isDirectory() } as FileFilter).sort()
}

/*
    allprojects.findAll { it.path.startsWith(":server_apps:data_transfer:") }.each { p ->
        println p.path
    }
*/

